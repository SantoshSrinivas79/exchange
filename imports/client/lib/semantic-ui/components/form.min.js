!(function(e, t, n, r) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.form = function(t) {
        let i; const a = e(this); const o = a.selector || ''; let l = (new Date()).getTime(); let s = []; const u = arguments[0]; const c = arguments[1]; const d = typeof u === 'string'; const f = [].slice.call(arguments, 1); return a.each(function() {
            let p; let m; let g; let h; let v; let b; let y; let x; let k; let E; let w; let C; let V; let R; let S; let F; const A = e(this); const T = this; let D = []; let O = !1; (F = {
                initialize() { F.get.settings(), d ? (S === r && F.instantiate(), F.invoke(u)) : (S !== r && S.invoke('destroy'), F.verbose('Initializing form validation', A, v), F.bindEvents(), F.set.defaults(), F.instantiate()); },
                instantiate() { F.verbose('Storing instance of module', F), S = F, A.data(V, F); },
                destroy() { F.verbose('Destroying previous module', S), F.removeEvents(), A.removeData(V); },
                refresh() { F.verbose('Refreshing selector cache'), p = A.find(x.field), m = A.find(x.group), g = A.find(x.message), A.find(x.prompt), h = A.find(x.submit), A.find(x.clear), A.find(x.reset); },
                submit() { F.verbose('Submitting form', A), A.submit(); },
                attachEvents(t, n) { n = n || 'submit', e(t).on(`click${R}`, function(e) { F[n](), e.preventDefault(); }); },
                bindEvents() {
                    F.verbose('Attaching form events'), A.on(`submit${R}`, F.validate.form).on(`blur${R}`, x.field, F.event.field.blur).on(`click${R}`, x.submit, F.submit).on(`click${R}`, x.reset, F.reset)
                        .on(`click${R}`, x.clear, F.clear), v.keyboardShortcuts && A.on(`keydown${R}`, x.field, F.event.field.keydown), p.each(function() { const t = e(this); const n = t.prop('type'); const r = F.get.changeEvent(n, t); e(this).on(r + R, F.event.field.change); });
                },
                clear() { p.each(function() { const t = e(this); const n = t.parent(); const r = t.closest(m); const i = r.find(x.prompt); const a = t.data(y.defaultValue) || ''; const o = n.is(x.uiCheckbox); const l = n.is(x.uiDropdown); r.hasClass(k.error) && (F.verbose('Resetting error on field', r), r.removeClass(k.error), i.remove()), l ? (F.verbose('Resetting dropdown value', n, a), n.dropdown('clear')) : o ? t.prop('checked', !1) : (F.verbose('Resetting field value', t, a), t.val('')); }); },
                reset() { p.each(function() { const t = e(this); const n = t.parent(); const i = t.closest(m); const a = i.find(x.prompt); const o = t.data(y.defaultValue); const l = n.is(x.uiCheckbox); const s = n.is(x.uiDropdown); const u = i.hasClass(k.error); o !== r && (u && (F.verbose('Resetting error on field', i), i.removeClass(k.error), a.remove()), s ? (F.verbose('Resetting dropdown value', n, o), n.dropdown('restore defaults')) : l ? (F.verbose('Resetting checkbox value', n, o), t.prop('checked', o)) : (F.verbose('Resetting field value', t, o), t.val(o))); }); },
                determine: { isValid() { let t = !0; return e.each(b, function(e, n) { F.validate.field(n, e, !0) || (t = !1); }), t; } },
                is: {
                    bracketedRule(e) { return e.type && e.type.match(v.regExp.bracket); }, shorthandFields(e) { const t = e[Object.keys(e)[0]]; return F.is.shorthandRules(t); }, shorthandRules(t) { return typeof t === 'string' || e.isArray(t); }, empty(e) { return !e || e.length === 0 || (e.is('input[type="checkbox"]') ? !e.is(':checked') : F.is.blank(e)); }, blank(t) { return e.trim(t.val()) === ''; }, valid(t) { let n = !0; return t ? (F.verbose('Checking if field is valid', t), F.validate.field(b[t], t, !1)) : (F.verbose('Checking if form is valid'), e.each(b, function(e, t) { F.is.valid(e) || (n = !1); }), n); },
                },
                removeEvents() { A.off(R), p.off(R), h.off(R), p.off(R); },
                event: {
                    field: {
                        keydown(t) { const n = e(this); const r = t.which; const i = n.is(x.input); const a = n.is(x.checkbox); const o = n.closest(x.uiDropdown).length > 0; const l = 13; r == 27 && (F.verbose('Escape key pressed blurring field'), n.blur()), t.ctrlKey || r != l || !i || o || a || (O || (n.one(`keyup${R}`, F.event.field.keyup), F.submit(), F.debug('Enter pressed on input submitting form')), O = !0); }, keyup() { O = !1; }, blur(t) { const n = e(this); const r = n.closest(m); const i = F.get.validation(n); r.hasClass(k.error) ? (F.debug('Revalidating field', n, i), i && F.validate.field(i)) : v.on == 'blur' && i && F.validate.field(i); }, change(t) { const n = e(this); const r = n.closest(m); const i = F.get.validation(n); i && (v.on == 'change' || r.hasClass(k.error) && v.revalidate) && (clearTimeout(F.timer), F.timer = setTimeout(function() { F.debug('Revalidating field', n, F.get.validation(n)), F.validate.field(i); }, v.delay)); },
                    },
                },
                get: {
                    ancillaryValue(e) { return !(!e.type || !e.value && !F.is.bracketedRule(e)) && (e.value !== r ? e.value : `${e.type.match(v.regExp.bracket)[1]}`); }, ruleName(e) { return F.is.bracketedRule(e) ? e.type.replace(e.type.match(v.regExp.bracket)[0], '') : e.type; }, changeEvent(e, t) { return e == 'checkbox' || e == 'radio' || e == 'hidden' || t.is('select') ? 'change' : F.get.inputEvent(); }, inputEvent() { return n.createElement('input').oninput !== r ? 'input' : n.createElement('input').onpropertychange !== r ? 'propertychange' : 'keyup'; }, fieldsFromShorthand(t) { const n = {}; return e.each(t, function(t, r) { typeof r === 'string' && (r = [r]), n[t] = { rules: [] }, e.each(r, function(e, r) { n[t].rules.push({ type: r }); }); }), n; }, prompt(e, t) { let n; let r; let i; const a = F.get.ruleName(e); const o = F.get.ancillaryValue(e); let l = e.prompt || v.prompt[a] || v.text.unspecifiedRule; const s = l.search('{value}') !== -1; const u = l.search('{name}') !== -1; return (u || s) && (r = F.get.field(t.identifier)), s && (l = l.replace('{value}', r.val())), u && (i = (n = r.closest(x.group).find('label').eq(0)).length == 1 ? n.text() : r.prop('placeholder') || v.text.unspecifiedField, l = l.replace('{name}', i)), l = (l = l.replace('{identifier}', t.identifier)).replace('{ruleValue}', o), e.prompt || F.verbose('Using default validation prompt for type', l, a), l; }, settings() { if (e.isPlainObject(t)) { const n = Object.keys(t); n.length > 0 && (t[n[0]].identifier !== r && t[n[0]].rules !== r) ? (v = e.extend(!0, {}, e.fn.form.settings, c), b = e.extend({}, e.fn.form.settings.defaults, t), F.error(v.error.oldSyntax, T), F.verbose('Extending settings from legacy parameters', b, v)) : (t.fields && F.is.shorthandFields(t.fields) && (t.fields = F.get.fieldsFromShorthand(t.fields)), v = e.extend(!0, {}, e.fn.form.settings, t), b = e.extend({}, e.fn.form.settings.defaults, v.fields), F.verbose('Extending settings', b, v)); } else v = e.fn.form.settings, b = e.fn.form.settings.defaults, F.verbose('Using default form validation', b, v); C = v.namespace, y = v.metadata, x = v.selector, k = v.className, E = v.regExp, w = v.error, V = `module-${C}`, R = `.${C}`, S = A.data(V), F.refresh(); }, field(t) { return F.verbose('Finding field with identifier', t), t = F.escape.string(t), p.filter(`#${t}`).length > 0 ? p.filter(`#${t}`) : p.filter(`[name="${t}"]`).length > 0 ? p.filter(`[name="${t}"]`) : p.filter(`[name="${t}[]"]`).length > 0 ? p.filter(`[name="${t}[]"]`) : p.filter(`[data-${y.validate}="${t}"]`).length > 0 ? p.filter(`[data-${y.validate}="${t}"]`) : e('<input/>'); }, fields(t) { let n = e(); return e.each(t, function(e, t) { n = n.add(F.get.field(t)); }), n; }, validation(t) { let n; let r; return !!b && (e.each(b, function(e, i) { r = i.identifier || e, F.get.field(r)[0] == t[0] && (i.identifier = r, n = i); }), n || !1); }, value(e) { const t = []; return t.push(e), F.get.values.call(T, t)[e]; }, values(t) { const n = {}; return (e.isArray(t) ? F.get.fields(t) : p).each(function(t, i) { const a = e(i); let o = (a.prop('type'), a.prop('name')); const l = a.val(); const s = a.is(x.checkbox); const u = a.is(x.radio); const c = o.indexOf('[]') !== -1; const d = !!s && a.is(':checked'); o && (c ? (o = o.replace('[]', ''), n[o] || (n[o] = []), s ? d ? n[o].push(l || !0) : n[o].push(!1) : n[o].push(l)) : u ? n[o] !== r && n[o] != 0 || (n[o] = !!d && (l || !0)) : n[o] = s ? !!d && (l || !0) : l); }), n; },
                },
                has: { field(e) { return F.verbose('Checking for existence of a field with identifier', e), typeof (e = F.escape.string(e)) !== 'string' && F.error(w.identifier, e), p.filter(`#${e}`).length > 0 || (p.filter(`[name="${e}"]`).length > 0 || p.filter(`[data-${y.validate}="${e}"]`).length > 0); } },
                escape: { string(e) { return (e = String(e)).replace(E.escape, '\\$&'); } },
                add: {
                    rule(e, t) { F.add.field(e, t); }, field(t, n) { const r = {}; F.is.shorthandRules(n) ? (n = e.isArray(n) ? n : [n], r[t] = { rules: [] }, e.each(n, function(e, n) { r[t].rules.push({ type: n }); })) : r[t] = n, b = e.extend({}, b, r), F.debug('Adding rules', r, b); }, fields(t) { let n; n = t && F.is.shorthandFields(t) ? F.get.fieldsFromShorthand(t) : t, b = e.extend({}, b, n); }, prompt(t, n) { const i = F.get.field(t).closest(m); let a = i.children(x.prompt); const o = a.length !== 0; n = typeof n === 'string' ? [n] : n, F.verbose('Adding field error state', t), i.addClass(k.error), v.inline && (o || (a = v.templates.prompt(n)).appendTo(i), a.html(n[0]), o ? F.verbose('Inline errors are disabled, no inline error added', t) : v.transition && e.fn.transition !== r && A.transition('is supported') ? (F.verbose('Displaying error with css transition', v.transition), a.transition(`${v.transition} in`, v.duration)) : (F.verbose('Displaying error with fallback javascript animation'), a.fadeIn(v.duration))); }, errors(e) { F.debug('Adding form error messages', e), F.set.error(), g.html(v.templates.error(e)); },
                },
                remove: {
                    rule(t, n) { const i = e.isArray(n) ? n : [n]; if (n == r) return F.debug('Removed all rules'), void (b[t].rules = []); b[t] != r && e.isArray(b[t].rules) && e.each(b[t].rules, function(e, n) { i.indexOf(n.type) !== -1 && (F.debug('Removed rule', n.type), b[t].rules.splice(e, 1)); }); }, field(t) { const n = e.isArray(t) ? t : [t]; e.each(n, function(e, t) { F.remove.rule(t); }); }, rules(t, n) { e.isArray(t) ? e.each(fields, function(e, t) { F.remove.rule(t, n); }) : F.remove.rule(t, n); }, fields(e) { F.remove.field(e); }, prompt(t) { const n = F.get.field(t).closest(m); const i = n.children(x.prompt); n.removeClass(k.error), v.inline && i.is(':visible') && (F.verbose('Removing prompt for field', t), v.transition && e.fn.transition !== r && A.transition('is supported') ? i.transition(`${v.transition} out`, v.duration, function() { i.remove(); }) : i.fadeOut(v.duration, function() { i.remove(); })); },
                },
                set: {
                    success() { A.removeClass(k.error).addClass(k.success); }, defaults() { p.each(function() { const t = e(this); const n = t.filter(x.checkbox).length > 0 ? t.is(':checked') : t.val(); t.data(y.defaultValue, n); }); }, error() { A.removeClass(k.success).addClass(k.error); }, value(e, t) { const n = {}; return n[e] = t, F.set.values.call(T, n); }, values(t) { e.isEmptyObject(t) || e.each(t, function(t, n) { let r; const i = F.get.field(t); let a = i.parent(); const o = e.isArray(n); const l = a.is(x.uiCheckbox); const s = a.is(x.uiDropdown); const u = i.is(x.radio) && l; i.length > 0 && (o && l ? (F.verbose('Selecting multiple', n, i), a.checkbox('uncheck'), e.each(n, function(e, t) { r = i.filter(`[value="${t}"]`), a = r.parent(), r.length > 0 && a.checkbox('check'); })) : u ? (F.verbose('Selecting radio value', n, i), i.filter(`[value="${n}"]`).parent(x.uiCheckbox).checkbox('check')) : l ? (F.verbose('Setting checkbox value', n, a), !0 === n ? a.checkbox('check') : a.checkbox('uncheck')) : s ? (F.verbose('Setting dropdown value', n, a), a.dropdown('set selected', n)) : (F.verbose('Setting field value', n, i), i.val(n))); }); },
                },
                validate: { form(e, t) { const n = F.get.values(); if (O) return !1; if (D = [], F.determine.isValid()) { if (F.debug('Form has no validation errors, submitting'), F.set.success(), !0 !== t) return v.onSuccess.call(T, e, n); } else if (F.debug('Form has errors'), F.set.error(), v.inline || F.add.errors(D), A.data('moduleApi') !== r && e.stopImmediatePropagation(), !0 !== t) return v.onFailure.call(T, D, n); }, field(t, n, i) { i = i === r || i, typeof t === 'string' && (F.verbose('Validating field', t), n = t, t = b[t]); const a = t.identifier || n; const o = F.get.field(a); const l = !!t.depends && F.get.field(t.depends); let s = !0; const u = []; return t.identifier || (F.debug('Using field name as identifier', a), t.identifier = a), o.prop('disabled') ? (F.debug('Field is disabled. Skipping', a), s = !0) : t.optional && F.is.blank(o) ? (F.debug('Field is optional and blank. Skipping', a), s = !0) : t.depends && F.is.empty(l) ? (F.debug('Field depends on another value that is not present or empty. Skipping', l), s = !0) : t.rules !== r && e.each(t.rules, function(e, n) { F.has.field(a) && !F.validate.rule(t, n) && (F.debug('Field is invalid', a, n.type), u.push(F.get.prompt(n, t)), s = !1); }), s ? (i && (F.remove.prompt(a, u), v.onValid.call(o)), !0) : (i && (D = D.concat(u), F.add.prompt(a, u), v.onInvalid.call(o, u)), !1); }, rule(t, n) { const i = F.get.field(t.identifier); let a = (n.type, i.val()); const o = F.get.ancillaryValue(n); const l = F.get.ruleName(n); const s = v.rules[l]; if (e.isFunction(s)) return a = a === r || a === '' || a === null ? '' : e.trim(`${a}`), s.call(i, a, o); F.error(w.noRule, l); } },
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, v, t); else { if (n === r) return v[t]; v[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, F, t); else { if (n === r) return F[t]; F[t] = n; } },
                debug() { !v.silent && v.debug && (v.performance ? F.performance.log(arguments) : (F.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), F.debug.apply(console, arguments))); },
                verbose() { !v.silent && v.verbose && v.debug && (v.performance ? F.performance.log(arguments) : (F.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), F.verbose.apply(console, arguments))); },
                error() { v.silent || (F.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), F.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; v.performance && (n = (t = (new Date()).getTime()) - (l || t), l = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: T, 'Execution Time': n,
                        })), clearTimeout(F.performance.timer), F.performance.timer = setTimeout(F.performance.display, 500);
                    },
                    display() { let t = `${v.name}:`; let n = 0; l = !1, clearTimeout(F.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, o && (t += ` '${o}'`), a.length > 1 && (t += ` (${a.length})`), (console.group !== r || console.table !== r) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, n, a) { let o; let l; let s; let u = S; return n = n || f, a = T || a, typeof t === 'string' && u !== r && (t = t.split(/[\. ]/), o = t.length - 1, e.each(t, function(n, i) { const a = n != o ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(u[a]) && n != o)u = u[a]; else { if (u[a] !== r) return l = u[a], !1; if (!e.isPlainObject(u[i]) || n == o) return u[i] !== r && (l = u[i], !1); u = u[i]; } })), e.isFunction(l) ? s = l.apply(a, n) : l !== r && (s = l), e.isArray(i) ? i.push(s) : i !== r ? i = [i, s] : s !== r && (i = s), l; },
            }).initialize();
        }), i !== r ? i : this;
    }, e.fn.form.settings = {
        name: 'Form',
        namespace: 'form',
        debug: !1,
        verbose: !1,
        performance: !0,
        fields: !1,
        keyboardShortcuts: !0,
        on: 'submit',
        inline: !1,
        delay: 200,
        revalidate: !0,
        transition: 'scale',
        duration: 200,
        onValid() {},
        onInvalid() {},
        onSuccess() { return !0; },
        onFailure() { return !1; },
        metadata: { defaultValue: 'default', validate: 'validate' },
        regExp: {
            htmlID: /^[a-zA-Z][\w:.-]*$/g, bracket: /\[(.*)\]/i, decimal: /^\d+\.?\d*$/, email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, flags: /^\/(.*)\/(.*)?/, integer: /^\-?\d+$/, number: /^\-?\d*(\.\d+)?$/, url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i,
        },
        text: { unspecifiedRule: 'Please enter a valid value', unspecifiedField: 'This field' },
        prompt: {
            empty: '{name} must have a value', checked: '{name} must be checked', email: '{name} must be a valid e-mail', url: '{name} must be a valid url', regExp: '{name} is not formatted correctly', integer: '{name} must be an integer', decimal: '{name} must be a decimal number', number: '{name} must be set to a number', is: '{name} must be "{ruleValue}"', isExactly: '{name} must be exactly "{ruleValue}"', not: '{name} cannot be set to "{ruleValue}"', notExactly: '{name} cannot be set to exactly "{ruleValue}"', contain: '{name} must contain "{ruleValue}"', containExactly: '{name} must contain exactly "{ruleValue}"', doesntContain: '{name} cannot contain  "{ruleValue}"', doesntContainExactly: '{name} cannot contain exactly "{ruleValue}"', minLength: '{name} must be at least {ruleValue} characters', length: '{name} must be at least {ruleValue} characters', exactLength: '{name} must be exactly {ruleValue} characters', maxLength: '{name} cannot be longer than {ruleValue} characters', match: '{name} must match {ruleValue} field', different: '{name} must have a different value than {ruleValue} field', creditCard: '{name} must be a valid credit card number', minCount: '{name} must have at least {ruleValue} choices', exactCount: '{name} must have exactly {ruleValue} choices', maxCount: '{name} must have {ruleValue} or less choices',
        },
        selector: {
            checkbox: 'input[type="checkbox"], input[type="radio"]', clear: '.clear', field: 'input, textarea, select', group: '.field', input: 'input', message: '.error.message', prompt: '.prompt.label', radio: 'input[type="radio"]', reset: '.reset:not([type="reset"])', submit: '.submit:not([type="submit"])', uiCheckbox: '.ui.checkbox', uiDropdown: '.ui.dropdown',
        },
        className: {
            error: 'error', label: 'ui prompt label', pressed: 'down', success: 'success',
        },
        error: {
            identifier: 'You must specify a string identifier for each field', method: 'The method you called is not defined.', noRule: 'There is no rule matching the one you specified', oldSyntax: 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.',
        },
        templates: { error(t) { let n = '<ul class="list">'; return e.each(t, function(e, t) { n += `<li>${t}</li>`; }), e(n += '</ul>'); }, prompt(t) { return e('<div/>').addClass('ui basic red pointing prompt label').html(t[0]); } },
        rules: {
            empty(t) { return !(t === r || t === '' || e.isArray(t) && t.length === 0); },
            checked() { return e(this).filter(':checked').length > 0; },
            email(t) { return e.fn.form.settings.regExp.email.test(t); },
            url(t) { return e.fn.form.settings.regExp.url.test(t); },
            regExp(t, n) { if (n instanceof RegExp) return t.match(n); let r; const i = n.match(e.fn.form.settings.regExp.flags); return i && (n = i.length >= 2 ? i[1] : n, r = i.length >= 3 ? i[2] : ''), t.match(new RegExp(n, r)); },
            integer(t, n) { let i; let a; let o; const l = e.fn.form.settings.regExp.integer; return n && ['', '..'].indexOf(n) === -1 && (n.indexOf('..') == -1 ? l.test(n) && (i = a = n - 0) : (o = n.split('..', 2), l.test(o[0]) && (i = o[0] - 0), l.test(o[1]) && (a = o[1] - 0))), l.test(t) && (i === r || t >= i) && (a === r || t <= a); },
            decimal(t) { return e.fn.form.settings.regExp.decimal.test(t); },
            number(t) { return e.fn.form.settings.regExp.number.test(t); },
            is(e, t) { return t = typeof t === 'string' ? t.toLowerCase() : t, (e = typeof e === 'string' ? e.toLowerCase() : e) == t; },
            isExactly(e, t) { return e == t; },
            not(e, t) { return (e = typeof e === 'string' ? e.toLowerCase() : e) != (t = typeof t === 'string' ? t.toLowerCase() : t); },
            notExactly(e, t) { return e != t; },
            contains(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n, 'i')) !== -1; },
            containsExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n)) !== -1; },
            doesntContain(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n, 'i')) === -1; },
            doesntContainExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n)) === -1; },
            minLength(e, t) { return e !== r && e.length >= t; },
            length(e, t) { return e !== r && e.length >= t; },
            exactLength(e, t) { return e !== r && e.length == t; },
            maxLength(e, t) { return e !== r && e.length <= t; },
            match(t, n) { let i; e(this); return e(`[data-validate="${n}"]`).length > 0 ? i = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? i = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? i = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (i = e(`[name="${n}[]"]`)), i !== r && t.toString() == i.toString(); },
            different(t, n) { let i; e(this); return e(`[data-validate="${n}"]`).length > 0 ? i = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? i = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? i = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (i = e(`[name="${n}[]"]`)), i !== r && t.toString() !== i.toString(); },
            creditCard(t, n) {
                let r; let i; const a = {
                    visa: { pattern: /^4/, length: [16] }, amex: { pattern: /^3[47]/, length: [15] }, mastercard: { pattern: /^5[1-5]/, length: [16] }, discover: { pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/, length: [16] }, unionPay: { pattern: /^(62|88)/, length: [16, 17, 18, 19] }, jcb: { pattern: /^35(2[89]|[3-8][0-9])/, length: [16] }, maestro: { pattern: /^(5018|5020|5038|6304|6759|676[1-3])/, length: [12, 13, 14, 15, 16, 17, 18, 19] }, dinersClub: { pattern: /^(30[0-5]|^36)/, length: [14] }, laser: { pattern: /^(6304|670[69]|6771)/, length: [16, 17, 18, 19] }, visaElectron: { pattern: /^(4026|417500|4508|4844|491(3|7))/, length: [16] },
                }; let o = {}; let l = !1; const s = typeof n === 'string' && n.split(','); if (typeof t === 'string' && t.length !== 0) { if (t = t.replace(/[\-]/g, ''), s && (e.each(s, function(n, r) { (i = a[r]) && (o = { length: e.inArray(t.length, i.length) !== -1, pattern: t.search(i.pattern) !== -1 }).length && o.pattern && (l = !0); }), !l)) return !1; if ((r = { number: e.inArray(t.length, a.unionPay.length) !== -1, pattern: t.search(a.unionPay.pattern) !== -1 }).number && r.pattern) return !0; for (var u = t.length, c = 0, d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], f = 0; u--;)f += d[c][parseInt(t.charAt(u), 10)], c ^= 1; return f % 10 == 0 && f > 0; }
            },
            minCount(e, t) { return t == 0 || (t == 1 ? e !== '' : e.split(',').length >= t); },
            exactCount(e, t) { return t == 0 ? e === '' : t == 1 ? e !== '' && e.search(',') === -1 : e.split(',').length == t; },
            maxCount(e, t) { return t != 0 && (t == 1 ? e.search(',') === -1 : e.split(',').length <= t); },
        },
    };
}(jQuery, window, document));
