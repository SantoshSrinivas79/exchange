!(function(e, t, a, n) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.tab = function(i) {
        let o; const r = e.isFunction(this) ? e(t) : e(this); const s = r.selector || ''; let c = (new Date()).getTime(); let l = []; const d = arguments[0]; const u = typeof d === 'string'; const b = [].slice.call(arguments, 1); let g = !1; return r.each(function() {
            let f; let h; let p; let m; let v; let y; let T = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.tab.settings, i) : e.extend({}, e.fn.tab.settings); const L = T.className; const x = T.metadata; const A = T.selector; const P = T.error; const C = `.${T.namespace}`; const F = `module-${T.namespace}`; const S = e(this); const j = {}; let E = !0; let O = 0; const w = this; let k = S.data(F); v = {
                initialize() { v.debug('Initializing tab menu item', S), v.fix.callbacks(), v.determineTabs(), v.debug('Determining tabs', T.context, h), T.auto && v.set.auto(), v.bind.events(), T.history && !g && (v.initializeHistory(), g = !0), v.instantiate(); },
                instantiate() { v.verbose('Storing instance of module', v), k = v, S.data(F, v); },
                destroy() { v.debug('Destroying tabs', S), S.removeData(F).off(C); },
                bind: { events() { e.isWindow(w) || (v.debug('Attaching tab activation events to element', S), S.on(`click${C}`, v.event.click)); } },
                determineTabs() { let t; T.context === 'parent' ? (S.closest(A.ui).length > 0 ? (t = S.closest(A.ui), v.verbose('Using closest UI element as parent', t)) : t = S, f = t.parent(), v.verbose('Determined parent element for creating context', f)) : T.context ? (f = e(T.context), v.verbose('Using selector for tab context', T.context, f)) : f = e('body'), T.childrenOnly ? (h = f.children(A.tabs), v.debug('Searching tab context children for tabs', f, h)) : (h = f.find(A.tabs), v.debug('Searching tab context for tabs', f, h)); },
                fix: { callbacks() { e.isPlainObject(i) && (i.onTabLoad || i.onTabInit) && (i.onTabLoad && (i.onLoad = i.onTabLoad, delete i.onTabLoad, v.error(P.legacyLoad, i.onLoad)), i.onTabInit && (i.onFirstLoad = i.onTabInit, delete i.onTabInit, v.error(P.legacyInit, i.onFirstLoad)), T = e.extend(!0, {}, e.fn.tab.settings, i)); } },
                initializeHistory() { if (v.debug('Initializing page state'), e.address === n) return v.error(P.state), !1; if (T.historyType == 'state') { if (v.debug('Using HTML5 to manage state'), !1 === T.path) return v.error(P.path), !1; e.address.history(!0).state(T.path); }e.address.bind('change', v.event.history.change); },
                event: { click(t) { const a = e(this).data(x.tab); a !== n ? (T.history ? (v.verbose('Updating page state', t), e.address.value(a)) : (v.verbose('Changing tab', t), v.changeTab(a)), t.preventDefault()) : v.debug('No tab specified'); }, history: { change(t) { const a = t.pathNames.join('/') || v.get.initialPath(); const i = T.templates.determineTitle(a) || !1; v.performance.display(), v.debug('History change event', a, t), y = t, a !== n && v.changeTab(a), i && e.address.title(i); } } },
                refresh() { p && (v.debug('Refreshing tab', p), v.changeTab(p)); },
                cache: { read(e) { return e !== n && j[e]; }, add(e, t) { e = e || p, v.debug('Adding cached content for', e), j[e] = t; }, remove(e) { e = e || p, v.debug('Removing cached content for', e), delete j[e]; } },
                set: { auto() { const t = typeof T.path === 'string' ? `${T.path.replace(/\/$/, '')}/{$tab}` : '/{$tab}'; v.verbose('Setting up automatic tab retrieval from server', t), e.isPlainObject(T.apiSettings) ? T.apiSettings.url = t : T.apiSettings = { url: t }; }, loading(e) { const t = v.get.tabElement(e); t.hasClass(L.loading) || (v.verbose('Setting loading state for', t), t.addClass(L.loading).siblings(h).removeClass(`${L.active} ${L.loading}`), t.length > 0 && T.onRequest.call(t[0], e)); }, state(t) { e.address.value(t); } },
                changeTab(a) { const n = t.history && t.history.pushState && T.ignoreFirstLoad && E; const i = T.auto || e.isPlainObject(T.apiSettings); const o = i && !n ? v.utilities.pathToArray(a) : v.get.defaultPathArray(a); a = v.utilities.arrayToPath(o), e.each(o, function(t, r) { let s; let c; let l; let d; const u = o.slice(0, t + 1); let b = v.utilities.arrayToPath(u); const g = v.is.tab(b); const h = t + 1 == o.length; let A = v.get.tabElement(b); if (v.verbose('Looking for tab', r), g) { if (v.verbose('Tab was found', r), p = b, m = v.utilities.filterArray(o, u), h ? d = !0 : (c = o.slice(0, t + 2), l = v.utilities.arrayToPath(c), (d = !v.is.tab(l)) && v.verbose('Tab parameters found', c)), d && i) return n ? (v.debug('Ignoring remote content on first tab load', b), E = !1, v.cache.add(a, A.html()), v.activate.all(b), T.onFirstLoad.call(A[0], b, m, y), T.onLoad.call(A[0], b, m, y)) : (v.activate.navigation(b), v.fetch.content(b, a)), !1; v.debug('Opened local tab', b), v.activate.all(b), v.cache.read(b) || (v.cache.add(b, !0), v.debug('First time tab loaded calling tab init'), T.onFirstLoad.call(A[0], b, m, y)), T.onLoad.call(A[0], b, m, y); } else { if (a.search('/') != -1 || a === '') return v.error(P.missingTab, S, f, b), !1; if (b = (s = e(`#${a}, a[name="${a}"]`)).closest('[data-tab]').data(x.tab), A = v.get.tabElement(b), s && s.length > 0 && b) return v.debug('Anchor link used, opening parent tab', A, s), A.hasClass(L.active) || setTimeout(function() { v.scrollTo(s); }, 0), v.activate.all(b), v.cache.read(b) || (v.cache.add(b, !0), v.debug('First time tab loaded calling tab init'), T.onFirstLoad.call(A[0], b, m, y)), T.onLoad.call(A[0], b, m, y), !1; } }); },
                scrollTo(t) { const n = !!(t && t.length > 0) && t.offset().top; !1 !== n && (v.debug('Forcing scroll to an in-page link in a hidden tab', n, t), e(a).scrollTop(n)); },
                update: { content(t, a, i) { const o = v.get.tabElement(t); const r = o[0]; i = i !== n ? i : T.evaluateScripts, typeof T.cacheType === 'string' && T.cacheType.toLowerCase() == 'dom' && typeof a !== 'string' ? o.empty().append(e(a).clone(!0)) : i ? (v.debug('Updating HTML and evaluating inline scripts', t, a), o.html(a)) : (v.debug('Updating HTML', t, a), r.innerHTML = a); } },
                fetch: {
                    content(t, a) {
                        let i; let o; const r = v.get.tabElement(t); const s = {
                            dataType: 'html', encodeParameters: !1, on: 'now', cache: T.alwaysRefresh, headers: { 'X-Remote': !0 }, onSuccess(e) { T.cacheType == 'response' && v.cache.add(a, e), v.update.content(t, e), t == p ? (v.debug('Content loaded', t), v.activate.tab(t)) : v.debug('Content loaded in background', t), T.onFirstLoad.call(r[0], t, m, y), T.onLoad.call(r[0], t, m, y), T.loadOnce ? v.cache.add(a, !0) : typeof T.cacheType === 'string' && T.cacheType.toLowerCase() == 'dom' && r.children().length > 0 ? setTimeout(function() { let e = r.children().clone(!0); e = e.not('script'), v.cache.add(a, e); }, 0) : v.cache.add(a, r.html()); }, urlData: { tab: a },
                        }; const c = r.api('get request') || !1; const l = c && c.state() === 'pending'; a = a || t, o = v.cache.read(a), T.cache && o ? (v.activate.tab(t), v.debug('Adding cached content', a), T.loadOnce || (T.evaluateScripts == 'once' ? v.update.content(t, o, !1) : v.update.content(t, o)), T.onLoad.call(r[0], t, m, y)) : l ? (v.set.loading(t), v.debug('Content is already loading', a)) : e.api !== n ? (i = e.extend(!0, {}, T.apiSettings, s), v.debug('Retrieving remote content', a, i), v.set.loading(t), r.api(i)) : v.error(P.api);
                    },
                },
                activate: { all(e) { v.activate.tab(e), v.activate.navigation(e); }, tab(e) { const t = v.get.tabElement(e); const a = T.deactivate == 'siblings' ? t.siblings(h) : h.not(t); const n = t.hasClass(L.active); v.verbose('Showing tab content for', t), n || (t.addClass(L.active), a.removeClass(`${L.active} ${L.loading}`), t.length > 0 && T.onVisible.call(t[0], e)); }, navigation(e) { const t = v.get.navElement(e); const a = T.deactivate == 'siblings' ? t.siblings(r) : r.not(t); const n = t.hasClass(L.active); v.verbose('Activating tab navigation for', t, e), n || (t.addClass(L.active), a.removeClass(`${L.active} ${L.loading}`)); } },
                deactivate: { all() { v.deactivate.navigation(), v.deactivate.tabs(); }, navigation() { r.removeClass(L.active); }, tabs() { h.removeClass(`${L.active} ${L.loading}`); } },
                is: { tab(e) { return e !== n && v.get.tabElement(e).length > 0; } },
                get: {
                    initialPath() { return r.eq(0).data(x.tab) || h.eq(0).data(x.tab); }, path() { return e.address.value(); }, defaultPathArray(e) { return v.utilities.pathToArray(v.get.defaultPath(e)); }, defaultPath(e) { const t = r.filter(`[data-${x.tab}^="${e}/"]`).eq(0).data(x.tab) || !1; if (t) { if (v.debug('Found default tab', t), O < T.maxDepth) return O++, v.get.defaultPath(t); v.error(P.recursion); } else v.debug('No default tabs found for', e, h); return O = 0, e; }, navElement(e) { return e = e || p, r.filter(`[data-${x.tab}="${e}"]`); }, tabElement(e) { let t; let a; let n; let i; return e = e || p, n = v.utilities.pathToArray(e), i = v.utilities.last(n), t = h.filter(`[data-${x.tab}="${e}"]`), a = h.filter(`[data-${x.tab}="${i}"]`), t.length > 0 ? t : a; }, tab() { return p; },
                },
                utilities: {
                    filterArray(t, a) { return e.grep(t, function(t) { return e.inArray(t, a) == -1; }); }, last(t) { return !!e.isArray(t) && t[t.length - 1]; }, pathToArray(e) { return e === n && (e = p), typeof e === 'string' ? e.split('/') : [e]; }, arrayToPath(t) { return !!e.isArray(t) && t.join('/'); },
                },
                setting(t, a) { if (v.debug('Changing setting', t, a), e.isPlainObject(t))e.extend(!0, T, t); else { if (a === n) return T[t]; e.isPlainObject(T[t]) ? e.extend(!0, T[t], a) : T[t] = a; } },
                internal(t, a) { if (e.isPlainObject(t))e.extend(!0, v, t); else { if (a === n) return v[t]; v[t] = a; } },
                debug() { !T.silent && T.debug && (T.performance ? v.performance.log(arguments) : (v.debug = Function.prototype.bind.call(console.info, console, `${T.name}:`), v.debug.apply(console, arguments))); },
                verbose() { !T.silent && T.verbose && T.debug && (T.performance ? v.performance.log(arguments) : (v.verbose = Function.prototype.bind.call(console.info, console, `${T.name}:`), v.verbose.apply(console, arguments))); },
                error() { T.silent || (v.error = Function.prototype.bind.call(console.error, console, `${T.name}:`), v.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let a; T.performance && (a = (t = (new Date()).getTime()) - (c || t), c = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: w, 'Execution Time': a,
                        })), clearTimeout(v.performance.timer), v.performance.timer = setTimeout(v.performance.display, 500);
                    },
                    display() { let t = `${T.name}:`; let a = 0; c = !1, clearTimeout(v.performance.timer), e.each(l, function(e, t) { a += t['Execution Time']; }), t += ` ${a}ms`, s && (t += ` '${s}'`), (console.group !== n || console.table !== n) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, a, i) { let r; let s; let c; let l = k; return a = a || b, i = w || i, typeof t === 'string' && l !== n && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, function(a, i) { const o = a != r ? i + t[a + 1].charAt(0).toUpperCase() + t[a + 1].slice(1) : t; if (e.isPlainObject(l[o]) && a != r)l = l[o]; else { if (l[o] !== n) return s = l[o], !1; if (!e.isPlainObject(l[i]) || a == r) return l[i] !== n ? (s = l[i], !1) : (v.error(P.method, t), !1); l = l[i]; } })), e.isFunction(s) ? c = s.apply(i, a) : s !== n && (c = s), e.isArray(o) ? o.push(c) : o !== n ? o = [o, c] : c !== n && (o = c), s; },
            }, u ? (k === n && v.initialize(), v.invoke(d)) : (k !== n && k.invoke('destroy'), v.initialize());
        }), o !== n ? o : this;
    }, e.tab = function() { e(t).tab.apply(this, arguments); }, e.fn.tab.settings = {
        name: 'Tab',
        namespace: 'tab',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        auto: !1,
        history: !1,
        historyType: 'hash',
        path: !1,
        context: !1,
        childrenOnly: !1,
        maxDepth: 25,
        deactivate: 'siblings',
        alwaysRefresh: !1,
        cache: !0,
        loadOnce: !1,
        cacheType: 'response',
        ignoreFirstLoad: !1,
        apiSettings: !1,
        evaluateScripts: 'once',
        onFirstLoad(e, t, a) {},
        onLoad(e, t, a) {},
        onVisible(e, t, a) {},
        onRequest(e, t, a) {},
        templates: { determineTitle(e) {} },
        error: {
            api: 'You attempted to load content without API module', method: 'The method you called is not defined', missingTab: 'Activated tab cannot be found. Tabs are case-sensitive.', noContent: 'The tab you specified is missing a content url.', path: 'History enabled, but no path was specified', recursion: 'Max recursive depth reached', legacyInit: 'onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.', legacyLoad: 'onTabLoad has been renamed to onLoad in 2.0. Please adjust your code', state: "History requires Asual's Address library <https://github.com/asual/jquery-address>",
        },
        metadata: { tab: 'tab', loaded: 'loaded', promise: 'promise' },
        className: { loading: 'loading', active: 'active' },
        selector: { tabs: '.ui.tab', ui: '.ui' },
    };
}(jQuery, window, document));
