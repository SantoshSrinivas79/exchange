!(function(e, n, t, i) {
    n = void 0 !== n && n.Math == Math ? n : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.checkbox = function(o) {
        let a; const c = e(this); const r = c.selector || ''; let l = (new Date()).getTime(); let d = []; const s = arguments[0]; const u = typeof s === 'string'; const b = [].slice.call(arguments, 1); return c.each(function() {
            let c; let h; const g = e.extend(!0, {}, e.fn.checkbox.settings, o); const f = g.className; const p = g.namespace; const k = g.selector; const m = g.error; const v = `.${p}`; const y = `module-${p}`; let C = e(this); let x = e(this).children(k.label); let w = e(this).children(k.input); let I = w[0]; let D = !1; let S = !1; let E = C.data(y); const O = this; h = {
                initialize() { h.verbose('Initializing checkbox', g), h.create.label(), h.bind.events(), h.set.tabbable(), h.hide.input(), h.observeChanges(), h.instantiate(), h.setup(); },
                instantiate() { h.verbose('Storing instance of module', h), E = h, C.data(y, h); },
                destroy() { h.verbose('Destroying module'), h.unbind.events(), h.show.input(), C.removeData(y); },
                fix: { reference() { C.is(k.input) && (h.debug('Behavior called on <input> adjusting invoked element'), C = C.closest(k.checkbox), h.refresh()); } },
                setup() { h.set.initialLoad(), h.is.indeterminate() ? (h.debug('Initial value is indeterminate'), h.indeterminate()) : h.is.checked() ? (h.debug('Initial value is checked'), h.check()) : (h.debug('Initial value is unchecked'), h.uncheck()), h.remove.initialLoad(); },
                refresh() { x = C.children(k.label), w = C.children(k.input), I = w[0]; },
                hide: { input() { h.verbose('Modifying <input> z-index to be unselectable'), w.addClass(f.hidden); } },
                show: { input() { h.verbose('Modifying <input> z-index to be selectable'), w.removeClass(f.hidden); } },
                observeChanges() { 'MutationObserver' in n && ((c = new MutationObserver(function(e) { h.debug('DOM tree modified, updating selector cache'), h.refresh(); })).observe(O, { childList: !0, subtree: !0 }), h.debug('Setting up mutation observer', c)); },
                attachEvents(n, t) { const i = e(n); t = e.isFunction(h[t]) ? h[t] : h.toggle, i.length > 0 ? (h.debug('Attaching checkbox events to element', n, t), i.on(`click${v}`, t)) : h.error(m.notFound); },
                event: { click(n) { const t = e(n.target); t.is(k.input) ? h.verbose('Using default check action on initialized checkbox') : t.is(k.link) ? h.debug('Clicking link inside checkbox, skipping toggle') : (h.toggle(), w.focus(), n.preventDefault()); }, keydown(e) { const n = e.which; const t = 13; const i = 32; n == 27 ? (h.verbose('Escape key pressed blurring field'), w.blur(), S = !0) : e.ctrlKey || n != i && n != t ? S = !1 : (h.verbose('Enter/space key pressed, toggling checkbox'), h.toggle(), S = !0); }, keyup(e) { S && e.preventDefault(); } },
                check() { h.should.allowCheck() && (h.debug('Checking checkbox', w), h.set.checked(), h.should.ignoreCallbacks() || (g.onChecked.call(I), g.onChange.call(I))); },
                uncheck() { h.should.allowUncheck() && (h.debug('Unchecking checkbox'), h.set.unchecked(), h.should.ignoreCallbacks() || (g.onUnchecked.call(I), g.onChange.call(I))); },
                indeterminate() { h.should.allowIndeterminate() ? h.debug('Checkbox is already indeterminate') : (h.debug('Making checkbox indeterminate'), h.set.indeterminate(), h.should.ignoreCallbacks() || (g.onIndeterminate.call(I), g.onChange.call(I))); },
                determinate() { h.should.allowDeterminate() ? h.debug('Checkbox is already determinate') : (h.debug('Making checkbox determinate'), h.set.determinate(), h.should.ignoreCallbacks() || (g.onDeterminate.call(I), g.onChange.call(I))); },
                enable() { h.is.enabled() ? h.debug('Checkbox is already enabled') : (h.debug('Enabling checkbox'), h.set.enabled(), g.onEnable.call(I), g.onEnabled.call(I)); },
                disable() { h.is.disabled() ? h.debug('Checkbox is already disabled') : (h.debug('Disabling checkbox'), h.set.disabled(), g.onDisable.call(I), g.onDisabled.call(I)); },
                get: { radios() { const n = h.get.name(); return e(`input[name="${n}"]`).closest(k.checkbox); }, otherRadios() { return h.get.radios().not(C); }, name() { return w.attr('name'); } },
                is: {
                    initialLoad() { return D; }, radio() { return w.hasClass(f.radio) || w.attr('type') == 'radio'; }, indeterminate() { return w.prop('indeterminate') !== i && w.prop('indeterminate'); }, checked() { return w.prop('checked') !== i && w.prop('checked'); }, disabled() { return w.prop('disabled') !== i && w.prop('disabled'); }, enabled() { return !h.is.disabled(); }, determinate() { return !h.is.indeterminate(); }, unchecked() { return !h.is.checked(); },
                },
                should: {
                    allowCheck() { return h.is.determinate() && h.is.checked() && !h.should.forceCallbacks() ? (h.debug('Should not allow check, checkbox is already checked'), !1) : !1 !== g.beforeChecked.apply(I) || (h.debug('Should not allow check, beforeChecked cancelled'), !1); }, allowUncheck() { return h.is.determinate() && h.is.unchecked() && !h.should.forceCallbacks() ? (h.debug('Should not allow uncheck, checkbox is already unchecked'), !1) : !1 !== g.beforeUnchecked.apply(I) || (h.debug('Should not allow uncheck, beforeUnchecked cancelled'), !1); }, allowIndeterminate() { return h.is.indeterminate() && !h.should.forceCallbacks() ? (h.debug('Should not allow indeterminate, checkbox is already indeterminate'), !1) : !1 !== g.beforeIndeterminate.apply(I) || (h.debug('Should not allow indeterminate, beforeIndeterminate cancelled'), !1); }, allowDeterminate() { return h.is.determinate() && !h.should.forceCallbacks() ? (h.debug('Should not allow determinate, checkbox is already determinate'), !1) : !1 !== g.beforeDeterminate.apply(I) || (h.debug('Should not allow determinate, beforeDeterminate cancelled'), !1); }, forceCallbacks() { return h.is.initialLoad() && g.fireOnInit; }, ignoreCallbacks() { return D && !g.fireOnInit; },
                },
                can: { change() { return !(C.hasClass(f.disabled) || C.hasClass(f.readOnly) || w.prop('disabled') || w.prop('readonly')); }, uncheck() { return typeof g.uncheckable === 'boolean' ? g.uncheckable : !h.is.radio(); } },
                set: {
                    initialLoad() { D = !0; }, checked() { h.verbose('Setting class to checked'), C.removeClass(f.indeterminate).addClass(f.checked), h.is.radio() && h.uncheckOthers(), h.is.indeterminate() || !h.is.checked() ? (h.verbose('Setting state to checked', I), w.prop('indeterminate', !1).prop('checked', !0), h.trigger.change()) : h.debug('Input is already checked, skipping input property change'); }, unchecked() { h.verbose('Removing checked class'), C.removeClass(f.indeterminate).removeClass(f.checked), h.is.indeterminate() || !h.is.unchecked() ? (h.debug('Setting state to unchecked'), w.prop('indeterminate', !1).prop('checked', !1), h.trigger.change()) : h.debug('Input is already unchecked'); }, indeterminate() { h.verbose('Setting class to indeterminate'), C.addClass(f.indeterminate), h.is.indeterminate() ? h.debug('Input is already indeterminate, skipping input property change') : (h.debug('Setting state to indeterminate'), w.prop('indeterminate', !0), h.trigger.change()); }, determinate() { h.verbose('Removing indeterminate class'), C.removeClass(f.indeterminate), h.is.determinate() ? h.debug('Input is already determinate, skipping input property change') : (h.debug('Setting state to determinate'), w.prop('indeterminate', !1)); }, disabled() { h.verbose('Setting class to disabled'), C.addClass(f.disabled), h.is.disabled() ? h.debug('Input is already disabled, skipping input property change') : (h.debug('Setting state to disabled'), w.prop('disabled', 'disabled'), h.trigger.change()); }, enabled() { h.verbose('Removing disabled class'), C.removeClass(f.disabled), h.is.enabled() ? h.debug('Input is already enabled, skipping input property change') : (h.debug('Setting state to enabled'), w.prop('disabled', !1), h.trigger.change()); }, tabbable() { h.verbose('Adding tabindex to checkbox'), w.attr('tabindex') === i && w.attr('tabindex', 0); },
                },
                remove: { initialLoad() { D = !1; } },
                trigger: { change() { const e = t.createEvent('HTMLEvents'); const n = w[0]; n && (h.verbose('Triggering native change event'), e.initEvent('change', !0, !1), n.dispatchEvent(e)); } },
                create: { label() { w.prevAll(k.label).length > 0 ? (w.prev(k.label).detach().insertAfter(w), h.debug('Moving existing label', x)) : h.has.label() || (x = e('<label>').insertAfter(w), h.debug('Creating label', x)); } },
                has: { label() { return x.length > 0; } },
                bind: { events() { h.verbose('Attaching checkbox events'), C.on(`click${v}`, h.event.click).on(`keydown${v}`, k.input, h.event.keydown).on(`keyup${v}`, k.input, h.event.keyup); } },
                unbind: { events() { h.debug('Removing events'), C.off(v); } },
                uncheckOthers() { const e = h.get.otherRadios(); h.debug('Unchecking other radios', e), e.removeClass(f.checked); },
                toggle() { h.can.change() ? h.is.indeterminate() || h.is.unchecked() ? (h.debug('Currently unchecked'), h.check()) : h.is.checked() && h.can.uncheck() && (h.debug('Currently checked'), h.uncheck()) : h.is.radio() || h.debug('Checkbox is read-only or disabled, ignoring toggle'); },
                setting(n, t) { if (h.debug('Changing setting', n, t), e.isPlainObject(n))e.extend(!0, g, n); else { if (t === i) return g[n]; e.isPlainObject(g[n]) ? e.extend(!0, g[n], t) : g[n] = t; } },
                internal(n, t) { if (e.isPlainObject(n))e.extend(!0, h, n); else { if (t === i) return h[n]; h[n] = t; } },
                debug() { !g.silent && g.debug && (g.performance ? h.performance.log(arguments) : (h.debug = Function.prototype.bind.call(console.info, console, `${g.name}:`), h.debug.apply(console, arguments))); },
                verbose() { !g.silent && g.verbose && g.debug && (g.performance ? h.performance.log(arguments) : (h.verbose = Function.prototype.bind.call(console.info, console, `${g.name}:`), h.verbose.apply(console, arguments))); },
                error() { g.silent || (h.error = Function.prototype.bind.call(console.error, console, `${g.name}:`), h.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let n; let t; g.performance && (t = (n = (new Date()).getTime()) - (l || n), l = n, d.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: O, 'Execution Time': t,
                        })), clearTimeout(h.performance.timer), h.performance.timer = setTimeout(h.performance.display, 500);
                    },
                    display() { let n = `${g.name}:`; let t = 0; l = !1, clearTimeout(h.performance.timer), e.each(d, function(e, n) { t += n['Execution Time']; }), n += ` ${t}ms`, r && (n += ` '${r}'`), (console.group !== i || console.table !== i) && d.length > 0 && (console.groupCollapsed(n), console.table ? console.table(d) : e.each(d, function(e, n) { console.log(`${n.Name}: ${n['Execution Time']}ms`); }), console.groupEnd()), d = []; },
                },
                invoke(n, t, o) { let c; let r; let l; let d = E; return t = t || b, o = O || o, typeof n === 'string' && d !== i && (n = n.split(/[\. ]/), c = n.length - 1, e.each(n, function(t, o) { const a = t != c ? o + n[t + 1].charAt(0).toUpperCase() + n[t + 1].slice(1) : n; if (e.isPlainObject(d[a]) && t != c)d = d[a]; else { if (d[a] !== i) return r = d[a], !1; if (!e.isPlainObject(d[o]) || t == c) return d[o] !== i ? (r = d[o], !1) : (h.error(m.method, n), !1); d = d[o]; } })), e.isFunction(r) ? l = r.apply(o, t) : r !== i && (l = r), e.isArray(a) ? a.push(l) : a !== i ? a = [a, l] : l !== i && (a = l), r; },
            }, u ? (E === i && h.initialize(), h.invoke(s)) : (E !== i && E.invoke('destroy'), h.initialize());
        }), a !== i ? a : this;
    }, e.fn.checkbox.settings = {
        name: 'Checkbox',
        namespace: 'checkbox',
        silent: !1,
        debug: !1,
        verbose: !0,
        performance: !0,
        uncheckable: 'auto',
        fireOnInit: !1,
        onChange() {},
        beforeChecked() {},
        beforeUnchecked() {},
        beforeDeterminate() {},
        beforeIndeterminate() {},
        onChecked() {},
        onUnchecked() {},
        onDeterminate() {},
        onIndeterminate() {},
        onEnable() {},
        onDisable() {},
        onEnabled() {},
        onDisabled() {},
        className: {
            checked: 'checked', indeterminate: 'indeterminate', disabled: 'disabled', hidden: 'hidden', radio: 'radio', readOnly: 'read-only',
        },
        error: { method: 'The method you called is not defined' },
        selector: {
            checkbox: '.ui.checkbox', label: 'label, .box', input: 'input[type="checkbox"], input[type="radio"]', link: 'a[href]',
        },
    };
}(jQuery, window, document));
