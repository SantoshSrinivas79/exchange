!(function(e, t, r, n) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); e.api = e.fn.api = function(r) {
        let o; const s = e.isFunction(this) ? e(t) : e(this); const i = s.selector || ''; let a = (new Date()).getTime(); let u = []; const c = arguments[0]; const d = typeof c === 'string'; const l = [].slice.call(arguments, 1); return s.each(function() {
            let s; let g; let f; let p; let m; let b; const v = e.isPlainObject(r) ? e.extend(!0, {}, e.fn.api.settings, r) : e.extend({}, e.fn.api.settings); const h = v.namespace; const y = v.metadata; const q = v.selector; const R = v.error; const x = v.className; const S = `.${h}`; const A = `module-${h}`; const k = e(this); const T = k.closest(q.form); const P = v.stateContext ? e(v.stateContext) : k; const j = this; const O = P[0]; let w = k.data(A); b = {
                initialize() { d || b.bind.events(), b.instantiate(); },
                instantiate() { b.verbose('Storing instance of module', b), w = b, k.data(A, w); },
                destroy() { b.verbose('Destroying previous module for', j), k.removeData(A).off(S); },
                bind: { events() { const e = b.get.event(); e ? (b.verbose('Attaching API events to element', e), k.on(e + S, b.event.trigger)) : v.on == 'now' && (b.debug('Querying API endpoint immediately'), b.query()); } },
                decode: { json(e) { if (e !== n && typeof e === 'string') try { e = JSON.parse(e); } catch (e) {} return e; } },
                read: { cachedResponse(e) { let r; if (t.Storage !== n) return r = sessionStorage.getItem(e), b.debug('Using cached response', e, r), r = b.decode.json(r); b.error(R.noStorage); } },
                write: { cachedResponse(r, o) { o && o === '' ? b.debug('Response empty, not caching', o) : t.Storage !== n ? (e.isPlainObject(o) && (o = JSON.stringify(o)), sessionStorage.setItem(r, o), b.verbose('Storing cached response for url', r, o)) : b.error(R.noStorage); } },
                query() {
                    if (b.is.disabled())b.debug('Element is disabled API request aborted'); else {
                        if (b.is.loading()) { if (!v.interruptRequests) return void b.debug('Cancelling request, previous request is still pending'); b.debug('Interrupting previous request'), b.abort(); } if (v.defaultData && e.extend(!0, v.urlData, b.get.defaultData()), v.serializeForm && (v.data = b.add.formData(v.data)), !1 === (g = b.get.settings())) return b.cancelled = !0, void b.error(R.beforeSend); if (b.cancelled = !1, (f = b.get.templatedURL()) || b.is.mocked()) {
                            if ((f = b.add.urlData(f)) || b.is.mocked()) {
                                if (g.url = v.base + f, s = e.extend(!0, {}, v, {
                                    type: v.method || v.type, data: p, url: v.base + f, beforeSend: v.beforeXHR, success() {}, failure() {}, complete() {},
                                }), b.debug('Querying URL', s.url), b.verbose('Using AJAX settings', s), v.cache === 'local' && b.read.cachedResponse(f)) return b.debug('Response returned from local cache'), b.request = b.create.request(), void b.request.resolveWith(O, [b.read.cachedResponse(f)]); v.throttle ? v.throttleFirstRequest || b.timer ? (b.debug('Throttling request', v.throttle), clearTimeout(b.timer), b.timer = setTimeout(function() { b.timer && delete b.timer, b.debug('Sending throttled request', p, s.method), b.send.request(); }, v.throttle)) : (b.debug('Sending request', p, s.method), b.send.request(), b.timer = setTimeout(function() {}, v.throttle)) : (b.debug('Sending request', p, s.method), b.send.request());
                            }
                        } else b.error(R.missingURL);
                    }
                },
                should: { removeError() { return !0 === v.hideError || v.hideError === 'auto' && !b.is.form(); } },
                is: {
                    disabled() { return k.filter(q.disabled).length > 0; }, expectingJSON() { return v.dataType === 'json' || v.dataType === 'jsonp'; }, form() { return k.is('form') || P.is('form'); }, mocked() { return v.mockResponse || v.mockResponseAsync || v.response || v.responseAsync; }, input() { return k.is('input'); }, loading() { return !!b.request && b.request.state() == 'pending'; }, abortedRequest(e) { return e && e.readyState !== n && e.readyState === 0 ? (b.verbose('XHR request determined to be aborted'), !0) : (b.verbose('XHR request was not aborted'), !1); }, validResponse(t) { return b.is.expectingJSON() && e.isFunction(v.successTest) ? (b.debug('Checking JSON returned success', v.successTest, t), v.successTest(t) ? (b.debug('Response passed success test', t), !0) : (b.debug('Response failed success test', t), !1)) : (b.verbose('Response is not JSON, skipping validation', v.successTest, t), !0); },
                },
                was: {
                    cancelled() { return b.cancelled || !1; }, succesful() { return b.request && b.request.state() == 'resolved'; }, failure() { return b.request && b.request.state() == 'rejected'; }, complete() { return b.request && (b.request.state() == 'resolved' || b.request.state() == 'rejected'); },
                },
                add: { urlData(t, r) { let o; let s; return t && (o = t.match(v.regExp.required), s = t.match(v.regExp.optional), r = r || v.urlData, o && (b.debug('Looking for required URL variables', o), e.each(o, function(o, s) { const i = s.indexOf('$') !== -1 ? s.substr(2, s.length - 3) : s.substr(1, s.length - 2); let a = e.isPlainObject(r) && r[i] !== n ? r[i] : k.data(i) !== n ? k.data(i) : P.data(i) !== n ? P.data(i) : r[i]; if (a === n) return b.error(R.requiredParameter, i, t), t = !1, !1; b.verbose('Found required variable', i, a), a = v.encodeParameters ? b.get.urlEncodedValue(a) : a, t = t.replace(s, a); })), s && (b.debug('Looking for optional URL variables', o), e.each(s, function(o, s) { const i = s.indexOf('$') !== -1 ? s.substr(3, s.length - 4) : s.substr(2, s.length - 3); const a = e.isPlainObject(r) && r[i] !== n ? r[i] : k.data(i) !== n ? k.data(i) : P.data(i) !== n ? P.data(i) : r[i]; a !== n ? (b.verbose('Optional variable Found', i, a), t = t.replace(s, a)) : (b.verbose('Optional variable not found', i), t = t.indexOf(`/${s}`) !== -1 ? t.replace(`/${s}`, '') : t.replace(s, '')); }))), t; }, formData(t) { const r = e.fn.serializeObject !== n; const o = r ? T.serializeObject() : T.serialize(); return t = t || v.data, e.isPlainObject(t) ? r ? (b.debug('Extending existing data with form data', t, o), t = e.extend(!0, {}, t, o)) : (b.error(R.missingSerialize), b.debug('Cant extend data. Replacing data with form data', t, o), t = o) : (b.debug('Adding form data', o), t = o), t; } },
                send: { request() { b.set.loading(), b.request = b.create.request(), b.is.mocked() ? b.mockedXHR = b.create.mockedXHR() : b.xhr = b.create.xhr(), v.onRequest.call(O, b.request, b.xhr); } },
                event: { trigger(e) { b.query(), e.type != 'submit' && e.type != 'click' || e.preventDefault(); }, xhr: { always() {}, done(t, r, n) { const o = this; const s = (new Date()).getTime() - m; let i = v.loadingDuration - s; const a = !!e.isFunction(v.onResponse) && (b.is.expectingJSON() ? v.onResponse.call(o, e.extend(!0, {}, t)) : v.onResponse.call(o, t)); i = i > 0 ? i : 0, a && (b.debug('Modified API response in onResponse callback', v.onResponse, a, t), t = a), i > 0 && b.debug('Response completed early delaying state change by', i), setTimeout(function() { b.is.validResponse(t) ? b.request.resolveWith(o, [t, n]) : b.request.rejectWith(o, [n, 'invalid']); }, i); }, fail(e, t, r) { const n = this; const o = (new Date()).getTime() - m; let s = v.loadingDuration - o; (s = s > 0 ? s : 0) > 0 && b.debug('Response completed early delaying state change by', s), setTimeout(function() { b.is.abortedRequest(e) ? b.request.rejectWith(n, [e, 'aborted', r]) : b.request.rejectWith(n, [e, 'error', t, r]); }, s); } }, request: { done(e, t) { b.debug('Successful API Response', e), v.cache === 'local' && f && (b.write.cachedResponse(f, e), b.debug('Saving server response locally', b.cache)), v.onSuccess.call(O, e, k, t); }, complete(e, t) { let r; let n; b.was.succesful() ? (n = e, r = t) : (r = e, n = b.get.responseFromXHR(r)), b.remove.loading(), v.onComplete.call(O, n, k, r); }, fail(e, t, r) { const o = b.get.responseFromXHR(e); const i = b.get.errorFromRequest(o, t, r); if (t == 'aborted') return b.debug('XHR Aborted (Most likely caused by page navigation or CORS Policy)', t, r), v.onAbort.call(O, t, k, e), !0; t == 'invalid' ? b.debug('JSON did not pass success test. A server-side error has most likely occurred', o) : t == 'error' && e !== n && (b.debug('XHR produced a server error', t, r), e.status != 200 && r !== n && r !== '' && b.error(R.statusMessage + r, s.url), v.onError.call(O, i, k, e)), v.errorDuration && t !== 'aborted' && (b.debug('Adding error state'), b.set.error(), b.should.removeError() && setTimeout(b.remove.error, v.errorDuration)), b.debug('API Request failed', i, e), v.onFailure.call(O, o, k, e); } } },
                create: { request() { return e.Deferred().always(b.event.request.complete).done(b.event.request.done).fail(b.event.request.fail); }, mockedXHR() { let t; let r; let n; const o = v.mockResponse || v.response; const s = v.mockResponseAsync || v.responseAsync; return n = e.Deferred().always(b.event.xhr.complete).done(b.event.xhr.done).fail(b.event.xhr.fail), o ? (e.isFunction(o) ? (b.debug('Using specified synchronous callback', o), r = o.call(O, g)) : (b.debug('Using settings specified response', o), r = o), n.resolveWith(O, [r, !1, { responseText: r }])) : e.isFunction(s) && (t = function(e) { b.debug('Async callback returned response', e), e ? n.resolveWith(O, [e, !1, { responseText: e }]) : n.rejectWith(O, [{ responseText: e }, !1, !1]); }, b.debug('Using specified async response callback', s), s.call(O, g, t)), n; }, xhr() { let t; return t = e.ajax(s).always(b.event.xhr.always).done(b.event.xhr.done).fail(b.event.xhr.fail), b.verbose('Created server request', t, s), t; } },
                set: { error() { b.verbose('Adding error state to element', P), P.addClass(x.error); }, loading() { b.verbose('Adding loading state to element', P), P.addClass(x.loading), m = (new Date()).getTime(); } },
                remove: { error() { b.verbose('Removing error state from element', P), P.removeClass(x.error); }, loading() { b.verbose('Removing loading state from element', P), P.removeClass(x.loading); } },
                get: {
                    responseFromXHR(t) { return !!e.isPlainObject(t) && (b.is.expectingJSON() ? b.decode.json(t.responseText) : t.responseText); }, errorFromRequest(t, r, o) { return e.isPlainObject(t) && t.error !== n ? t.error : v.error[r] !== n ? v.error[r] : o; }, request() { return b.request || !1; }, xhr() { return b.xhr || !1; }, settings() { let t; return (t = v.beforeSend.call(O, v)) && (t.success !== n && (b.debug('Legacy success callback detected', t), b.error(R.legacyParameters, t.success), t.onSuccess = t.success), t.failure !== n && (b.debug('Legacy failure callback detected', t), b.error(R.legacyParameters, t.failure), t.onFailure = t.failure), t.complete !== n && (b.debug('Legacy complete callback detected', t), b.error(R.legacyParameters, t.complete), t.onComplete = t.complete)), t === n && b.error(R.noReturnedValue), !1 === t ? t : t !== n ? e.extend(!0, {}, t) : e.extend(!0, {}, v); }, urlEncodedValue(e) { const r = t.decodeURIComponent(e); const n = t.encodeURIComponent(e); return r !== e ? (b.debug('URL value is already encoded, avoiding double encoding', e), e) : (b.verbose('Encoding value using encodeURIComponent', e, n), n); }, defaultData() { const t = {}; return e.isWindow(j) || (b.is.input() ? t.value = k.val() : b.is.form() || (t.text = k.text())), t; }, event() { return e.isWindow(j) || v.on == 'now' ? (b.debug('API called without element, no events attached'), !1) : v.on == 'auto' ? k.is('input') ? j.oninput !== n ? 'input' : j.onpropertychange !== n ? 'propertychange' : 'keyup' : k.is('form') ? 'submit' : 'click' : v.on; }, templatedURL(e) { if (e = e || k.data(y.action) || v.action || !1, f = k.data(y.url) || v.url || !1) return b.debug('Using specified url', f), f; if (e) { if (b.debug('Looking up url for action', e, v.api), v.api[e] === n && !b.is.mocked()) return void b.error(R.missingAction, v.action, v.api); f = v.api[e]; } else b.is.form() && (f = k.attr('action') || P.attr('action') || !1, b.debug('No url or action specified, defaulting to form action', f)); return f; },
                },
                abort() { const e = b.get.xhr(); e && e.state() !== 'resolved' && (b.debug('Cancelling API request'), e.abort()); },
                reset() { b.remove.error(), b.remove.loading(); },
                setting(t, r) { if (b.debug('Changing setting', t, r), e.isPlainObject(t))e.extend(!0, v, t); else { if (r === n) return v[t]; e.isPlainObject(v[t]) ? e.extend(!0, v[t], r) : v[t] = r; } },
                internal(t, r) { if (e.isPlainObject(t))e.extend(!0, b, t); else { if (r === n) return b[t]; b[t] = r; } },
                debug() { !v.silent && v.debug && (v.performance ? b.performance.log(arguments) : (b.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), b.debug.apply(console, arguments))); },
                verbose() { !v.silent && v.verbose && v.debug && (v.performance ? b.performance.log(arguments) : (b.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), b.verbose.apply(console, arguments))); },
                error() { v.silent || (b.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), b.error.apply(console, arguments)); },
                performance: { log(e) { let t; let r; v.performance && (r = (t = (new Date()).getTime()) - (a || t), a = t, u.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': r })), clearTimeout(b.performance.timer), b.performance.timer = setTimeout(b.performance.display, 500); }, display() { let t = `${v.name}:`; let r = 0; a = !1, clearTimeout(b.performance.timer), e.each(u, function(e, t) { r += t['Execution Time']; }), t += ` ${r}ms`, i && (t += ` '${i}'`), (console.group !== n || console.table !== n) && u.length > 0 && (console.groupCollapsed(t), console.table ? console.table(u) : e.each(u, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), u = []; } },
                invoke(t, r, s) { let i; let a; let u; let c = w; return r = r || l, s = j || s, typeof t === 'string' && c !== n && (t = t.split(/[\. ]/), i = t.length - 1, e.each(t, function(r, o) { const s = r != i ? o + t[r + 1].charAt(0).toUpperCase() + t[r + 1].slice(1) : t; if (e.isPlainObject(c[s]) && r != i)c = c[s]; else { if (c[s] !== n) return a = c[s], !1; if (!e.isPlainObject(c[o]) || r == i) return c[o] !== n ? (a = c[o], !1) : (b.error(R.method, t), !1); c = c[o]; } })), e.isFunction(a) ? u = a.apply(s, r) : a !== n && (u = a), e.isArray(o) ? o.push(u) : o !== n ? o = [o, u] : u !== n && (o = u), a; },
            }, d ? (w === n && b.initialize(), b.invoke(c)) : (w !== n && w.invoke('destroy'), b.initialize());
        }), o !== n ? o : this;
    }, e.api.settings = {
        name: 'API',
        namespace: 'api',
        debug: !1,
        verbose: !1,
        performance: !0,
        api: {},
        cache: !0,
        interruptRequests: !0,
        on: 'auto',
        stateContext: !1,
        loadingDuration: 0,
        hideError: 'auto',
        errorDuration: 2e3,
        encodeParameters: !0,
        action: !1,
        url: !1,
        base: '',
        urlData: {},
        defaultData: !0,
        serializeForm: !1,
        throttle: 0,
        throttleFirstRequest: !0,
        method: 'get',
        data: {},
        dataType: 'json',
        mockResponse: !1,
        mockResponseAsync: !1,
        response: !1,
        responseAsync: !1,
        beforeSend(e) { return e; },
        beforeXHR(e) {},
        onRequest(e, t) {},
        onResponse: !1,
        onSuccess(e, t) {},
        onComplete(e, t) {},
        onFailure(e, t) {},
        onError(e, t) {},
        onAbort(e, t) {},
        successTest: !1,
        error: {
            beforeSend: 'The before send function has aborted the request', error: 'There was an error with your request', exitConditions: 'API Request Aborted. Exit conditions met', JSONParse: 'JSON could not be parsed during error handling', legacyParameters: 'You are using legacy API success callback names', method: 'The method you called is not defined', missingAction: 'API action used but no url was defined', missingSerialize: 'jquery-serialize-object is required to add form data to an existing data object', missingURL: 'No URL specified for api event', noReturnedValue: 'The beforeSend callback must return a settings object, beforeSend ignored.', noStorage: 'Caching responses locally requires session storage', parseError: 'There was an error parsing your request', requiredParameter: 'Missing a required URL parameter: ', statusMessage: 'Server gave an error: ', timeout: 'Your request timed out',
        },
        regExp: { required: /\{\$*[A-z0-9]+\}/g, optional: /\{\/\$*[A-z0-9]+\}/g },
        className: { loading: 'loading', error: 'error' },
        selector: { disabled: '.disabled', form: 'form' },
        metadata: { action: 'action', url: 'url' },
    };
}(jQuery, window, document));
