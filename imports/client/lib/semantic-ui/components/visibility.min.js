!(function(e, o, n, t) {
    o = void 0 !== o && o.Math == Math ? o : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.visibility = function(i) {
        let s; const c = e(this); const r = c.selector || ''; let a = (new Date()).getTime(); let l = []; const d = arguments[0]; const u = typeof d === 'string'; const f = [].slice.call(arguments, 1); const b = c.length; let g = 0; return c.each(function() {
            let c; let m; let p; let v; const h = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.visibility.settings, i) : e.extend({}, e.fn.visibility.settings); const P = h.className; const x = h.namespace; const C = h.error; const y = h.metadata; const S = `.${x}`; const R = `module-${x}`; const V = e(o); const k = e(this); const T = e(h.context); let O = (k.selector, k.data(R)); const z = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; const A = this; let w = !1; v = {
                initialize() { v.debug('Initializing', h), v.setup.cache(), v.should.trackChanges() && (h.type == 'image' && v.setup.image(), h.type == 'fixed' && v.setup.fixed(), h.observeChanges && v.observeChanges(), v.bind.events()), v.save.position(), v.is.visible() || v.error(C.visible, k), h.initialCheck && v.checkVisibility(), v.instantiate(); },
                instantiate() { v.debug('Storing instance', v), k.data(R, v), O = v; },
                destroy() { v.verbose('Destroying previous module'), p && p.disconnect(), m && m.disconnect(), V.off(`load${S}`, v.event.load).off(`resize${S}`, v.event.resize), T.off(`scroll${S}`, v.event.scroll).off(`scrollchange${S}`, v.event.scrollchange), h.type == 'fixed' && (v.resetFixed(), v.remove.placeholder()), k.off(S).removeData(R); },
                observeChanges() { 'MutationObserver' in o && (m = new MutationObserver(v.event.contextChanged), p = new MutationObserver(v.event.changed), m.observe(n, { childList: !0, subtree: !0 }), p.observe(A, { childList: !0, subtree: !0 }), v.debug('Setting up mutation observer', p)); },
                bind: { events() { v.verbose('Binding visibility events to scroll and resize'), h.refreshOnLoad && V.on(`load${S}`, v.event.load), V.on(`resize${S}`, v.event.resize), T.off(`scroll${S}`).on(`scroll${S}`, v.event.scroll).on(`scrollchange${S}`, v.event.scrollchange); } },
                event: {
                    changed(e) { v.verbose('DOM tree modified, updating visibility calculations'), v.timer = setTimeout(function() { v.verbose('DOM tree modified, updating sticky menu'), v.refresh(); }, 100); }, contextChanged(o) { [].forEach.call(o, function(o) { o.removedNodes && [].forEach.call(o.removedNodes, function(o) { (o == A || e(o).find(A).length > 0) && (v.debug('Element removed from DOM, tearing down events'), v.destroy()); }); }); }, resize() { v.debug('Window resized'), h.refreshOnResize && z(v.refresh); }, load() { v.debug('Page finished loading'), z(v.refresh); }, scroll() { h.throttle ? (clearTimeout(v.timer), v.timer = setTimeout(function() { T.triggerHandler(`scrollchange${S}`, [T.scrollTop()]); }, h.throttle)) : z(function() { T.triggerHandler(`scrollchange${S}`, [T.scrollTop()]); }); }, scrollchange(e, o) { v.checkVisibility(o); },
                },
                precache(o, t) { o instanceof Array || (o = [o]); for (var i = o.length, s = 0, c = [], r = n.createElement('img'), a = function() { ++s >= o.length && e.isFunction(t) && t(); }; i--;)(r = n.createElement('img')).onload = a, r.onerror = a, r.src = o[i], c.push(r); },
                enableCallbacks() { v.debug('Allowing callbacks to occur'), w = !1; },
                disableCallbacks() { v.debug('Disabling all callbacks temporarily'), w = !0; },
                should: { trackChanges() { return u ? (v.debug('One time query, no need to bind events'), !1) : (v.debug('Callbacks being attached'), !0); } },
                setup: { cache() { v.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = k.data(y.src); e && (v.verbose('Lazy loading image', e), h.once = !0, h.observeChanges = !1, h.onOnScreen = function() { v.debug('Image on screen', A), v.precache(e, function() { v.set.image(e, function() { ++g == b && h.onAllLoaded.call(this), h.onLoad.call(this); }); }); }); }, fixed() { v.debug('Setting up fixed'), h.once = !1, h.observeChanges = !1, h.initialCheck = !0, h.refreshOnLoad = !0, i.transition || (h.transition = !1), v.create.placeholder(), v.debug('Added placeholder', c), h.onTopPassed = function() { v.debug('Element passed, adding fixed position', k), v.show.placeholder(), v.set.fixed(), h.transition && e.fn.transition !== t && k.transition(h.transition, h.duration); }, h.onTopPassedReverse = function() { v.debug('Element returned to position, removing fixed', k), v.hide.placeholder(), v.remove.fixed(); }; } },
                create: { placeholder() { v.verbose('Creating fixed position placeholder'), c = k.clone(!1).css('display', 'none').addClass(P.placeholder).insertAfter(k); } },
                show: { placeholder() { v.verbose('Showing placeholder'), c.css('display', 'block').css('visibility', 'hidden'); } },
                hide: { placeholder() { v.verbose('Hiding placeholder'), c.css('display', 'none').css('visibility', ''); } },
                set: {
                    fixed() {
                        v.verbose('Setting element to fixed position'), k.addClass(P.fixed).css({
                            position: 'fixed', top: `${h.offset}px`, left: 'auto', zIndex: h.zIndex,
                        }), h.onFixed.call(A);
                    },
                    image(o, n) { if (k.attr('src', o), h.transition) if (e.fn.transition !== t) { if (k.hasClass(P.visible)) return void v.debug('Transition already occurred on this image, skipping animation'); k.transition(h.transition, h.duration, n); } else k.fadeIn(h.duration, n); else k.show(); },
                },
                is: {
                    onScreen() { return v.get.elementCalculations().onScreen; }, offScreen() { return v.get.elementCalculations().offScreen; }, visible() { return !(!v.cache || !v.cache.element) && !(v.cache.element.width === 0 && v.cache.element.offset.top === 0); }, verticallyScrollableContext() { const e = T.get(0) !== o && T.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = T.get(0) !== o && T.css('overflow-x'); return e == 'auto' || e == 'scroll'; },
                },
                refresh() { v.debug('Refreshing constants (width/height)'), h.type == 'fixed' && v.resetFixed(), v.reset(), v.save.position(), h.checkOnRefresh && v.checkVisibility(), h.onRefresh.call(A); },
                resetFixed() { v.remove.fixed(), v.remove.occurred(); },
                reset() { v.verbose('Resetting all cached values'), e.isPlainObject(v.cache) && (v.cache.screen = {}, v.cache.element = {}); },
                checkVisibility(e) { v.verbose('Checking visibility of element', v.cache.element), !w && v.is.visible() && (v.save.scroll(e), v.save.calculations(), v.passed(), v.passingReverse(), v.topVisibleReverse(), v.bottomVisibleReverse(), v.topPassedReverse(), v.bottomPassedReverse(), v.onScreen(), v.offScreen(), v.passing(), v.topVisible(), v.bottomVisible(), v.topPassed(), v.bottomPassed(), h.onUpdate && h.onUpdate.call(A, v.get.elementCalculations())); },
                passed(o, n) { const i = v.get.elementCalculations(); if (o && n)h.onPassed[o] = n; else { if (o !== t) return v.get.pixelsPassed(o) > i.pixelsPassed; i.passing && e.each(h.onPassed, function(e, o) { i.bottomVisible || i.pixelsPassed > v.get.pixelsPassed(e) ? v.execute(o, e) : h.once || v.remove.occurred(o); }); } },
                onScreen(e) { const o = v.get.elementCalculations(); const n = e || h.onOnScreen; const i = 'onScreen'; if (e && (v.debug('Adding callback for onScreen', e), h.onOnScreen = e), o.onScreen ? v.execute(n, i) : h.once || v.remove.occurred(i), e !== t) return o.onOnScreen; },
                offScreen(e) { const o = v.get.elementCalculations(); const n = e || h.onOffScreen; const i = 'offScreen'; if (e && (v.debug('Adding callback for offScreen', e), h.onOffScreen = e), o.offScreen ? v.execute(n, i) : h.once || v.remove.occurred(i), e !== t) return o.onOffScreen; },
                passing(e) { const o = v.get.elementCalculations(); const n = e || h.onPassing; const i = 'passing'; if (e && (v.debug('Adding callback for passing', e), h.onPassing = e), o.passing ? v.execute(n, i) : h.once || v.remove.occurred(i), e !== t) return o.passing; },
                topVisible(e) { const o = v.get.elementCalculations(); const n = e || h.onTopVisible; const i = 'topVisible'; if (e && (v.debug('Adding callback for top visible', e), h.onTopVisible = e), o.topVisible ? v.execute(n, i) : h.once || v.remove.occurred(i), e === t) return o.topVisible; },
                bottomVisible(e) { const o = v.get.elementCalculations(); const n = e || h.onBottomVisible; const i = 'bottomVisible'; if (e && (v.debug('Adding callback for bottom visible', e), h.onBottomVisible = e), o.bottomVisible ? v.execute(n, i) : h.once || v.remove.occurred(i), e === t) return o.bottomVisible; },
                topPassed(e) { const o = v.get.elementCalculations(); const n = e || h.onTopPassed; const i = 'topPassed'; if (e && (v.debug('Adding callback for top passed', e), h.onTopPassed = e), o.topPassed ? v.execute(n, i) : h.once || v.remove.occurred(i), e === t) return o.topPassed; },
                bottomPassed(e) { const o = v.get.elementCalculations(); const n = e || h.onBottomPassed; const i = 'bottomPassed'; if (e && (v.debug('Adding callback for bottom passed', e), h.onBottomPassed = e), o.bottomPassed ? v.execute(n, i) : h.once || v.remove.occurred(i), e === t) return o.bottomPassed; },
                passingReverse(e) { const o = v.get.elementCalculations(); const n = e || h.onPassingReverse; const i = 'passingReverse'; if (e && (v.debug('Adding callback for passing reverse', e), h.onPassingReverse = e), o.passing ? h.once || v.remove.occurred(i) : v.get.occurred('passing') && v.execute(n, i), e !== t) return !o.passing; },
                topVisibleReverse(e) { const o = v.get.elementCalculations(); const n = e || h.onTopVisibleReverse; const i = 'topVisibleReverse'; if (e && (v.debug('Adding callback for top visible reverse', e), h.onTopVisibleReverse = e), o.topVisible ? h.once || v.remove.occurred(i) : v.get.occurred('topVisible') && v.execute(n, i), e === t) return !o.topVisible; },
                bottomVisibleReverse(e) { const o = v.get.elementCalculations(); const n = e || h.onBottomVisibleReverse; const i = 'bottomVisibleReverse'; if (e && (v.debug('Adding callback for bottom visible reverse', e), h.onBottomVisibleReverse = e), o.bottomVisible ? h.once || v.remove.occurred(i) : v.get.occurred('bottomVisible') && v.execute(n, i), e === t) return !o.bottomVisible; },
                topPassedReverse(e) { const o = v.get.elementCalculations(); const n = e || h.onTopPassedReverse; const i = 'topPassedReverse'; if (e && (v.debug('Adding callback for top passed reverse', e), h.onTopPassedReverse = e), o.topPassed ? h.once || v.remove.occurred(i) : v.get.occurred('topPassed') && v.execute(n, i), e === t) return !o.onTopPassed; },
                bottomPassedReverse(e) { const o = v.get.elementCalculations(); const n = e || h.onBottomPassedReverse; const i = 'bottomPassedReverse'; if (e && (v.debug('Adding callback for bottom passed reverse', e), h.onBottomPassedReverse = e), o.bottomPassed ? h.once || v.remove.occurred(i) : v.get.occurred('bottomPassed') && v.execute(n, i), e === t) return !o.bottomPassed; },
                execute(e, o) { const n = v.get.elementCalculations(); const t = v.get.screenCalculations(); (e = e || !1) && (h.continuous ? (v.debug('Callback being called continuously', o, n), e.call(A, n, t)) : v.get.occurred(o) || (v.debug('Conditions met', o, n), e.call(A, n, t))), v.save.occurred(o); },
                remove: {
                    fixed() {
                        v.debug('Removing fixed position'), k.removeClass(P.fixed).css({
                            position: '', top: '', left: '', zIndex: '',
                        }), h.onUnfixed.call(A);
                    },
                    placeholder() { v.debug('Removing placeholder content'), c && c.remove(); },
                    occurred(e) { if (e) { const o = v.cache.occurred; o[e] !== t && !0 === o[e] && (v.debug('Callback can now be called again', e), v.cache.occurred[e] = !1); } else v.cache.occurred = {}; },
                },
                save: {
                    calculations() { v.verbose('Saving all calculations necessary to determine positioning'), v.save.direction(), v.save.screenCalculations(), v.save.elementCalculations(); }, occurred(e) { e && (v.cache.occurred[e] !== t && !0 === v.cache.occurred[e] || (v.verbose('Saving callback occurred', e), v.cache.occurred[e] = !0)); }, scroll(e) { e = e + h.offset || T.scrollTop() + h.offset, v.cache.scroll = e; }, direction() { let e; const o = v.get.scroll(); const n = v.get.lastScroll(); return e = o > n && n ? 'down' : o < n && n ? 'up' : 'static', v.cache.direction = e, v.cache.direction; }, elementPosition() { const e = v.cache.element; const o = v.get.screenSize(); return v.verbose('Saving element position'), e.fits = e.height < o.height, e.offset = k.offset(), e.width = k.outerWidth(), e.height = k.outerHeight(), v.is.verticallyScrollableContext() && (e.offset.top += T.scrollTop() - T.offset().top), v.is.horizontallyScrollableContext() && (e.offset.left += T.scrollLeft - T.offset().left), v.cache.element = e, e; }, elementCalculations() { const e = v.get.screenCalculations(); const o = v.get.elementPosition(); return h.includeMargin ? (o.margin = {}, o.margin.top = parseInt(k.css('margin-top'), 10), o.margin.bottom = parseInt(k.css('margin-bottom'), 10), o.top = o.offset.top - o.margin.top, o.bottom = o.offset.top + o.height + o.margin.bottom) : (o.top = o.offset.top, o.bottom = o.offset.top + o.height), o.topPassed = e.top >= o.top, o.bottomPassed = e.top >= o.bottom, o.topVisible = e.bottom >= o.top && !o.topPassed, o.bottomVisible = e.bottom >= o.bottom && !o.bottomPassed, o.pixelsPassed = 0, o.percentagePassed = 0, o.onScreen = o.topVisible && !o.bottomPassed, o.passing = o.topPassed && !o.bottomPassed, o.offScreen = !o.onScreen, o.passing && (o.pixelsPassed = e.top - o.top, o.percentagePassed = (e.top - o.top) / o.height), v.cache.element = o, v.verbose('Updated element calculations', o), o; }, screenCalculations() { const e = v.get.scroll(); return v.save.direction(), v.cache.screen.top = e, v.cache.screen.bottom = e + v.cache.screen.height, v.cache.screen; }, screenSize() { v.verbose('Saving window position'), v.cache.screen = { height: T.height() }; }, position() { v.save.screenSize(), v.save.elementPosition(); },
                },
                get: {
                    pixelsPassed(e) { const o = v.get.elementCalculations(); return e.search('%') > -1 ? o.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return v.cache.occurred !== t && v.cache.occurred[e] || !1; }, direction() { return v.cache.direction === t && v.save.direction(), v.cache.direction; }, elementPosition() { return v.cache.element === t && v.save.elementPosition(), v.cache.element; }, elementCalculations() { return v.cache.element === t && v.save.elementCalculations(), v.cache.element; }, screenCalculations() { return v.cache.screen === t && v.save.screenCalculations(), v.cache.screen; }, screenSize() { return v.cache.screen === t && v.save.screenSize(), v.cache.screen; }, scroll() { return v.cache.scroll === t && v.save.scroll(), v.cache.scroll; }, lastScroll() { return v.cache.screen === t ? (v.debug('First scroll event, no last scroll could be found'), !1) : v.cache.screen.top; },
                },
                setting(o, n) { if (e.isPlainObject(o))e.extend(!0, h, o); else { if (n === t) return h[o]; h[o] = n; } },
                internal(o, n) { if (e.isPlainObject(o))e.extend(!0, v, o); else { if (n === t) return v[o]; v[o] = n; } },
                debug() { !h.silent && h.debug && (h.performance ? v.performance.log(arguments) : (v.debug = Function.prototype.bind.call(console.info, console, `${h.name}:`), v.debug.apply(console, arguments))); },
                verbose() { !h.silent && h.verbose && h.debug && (h.performance ? v.performance.log(arguments) : (v.verbose = Function.prototype.bind.call(console.info, console, `${h.name}:`), v.verbose.apply(console, arguments))); },
                error() { h.silent || (v.error = Function.prototype.bind.call(console.error, console, `${h.name}:`), v.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let o; let n; h.performance && (n = (o = (new Date()).getTime()) - (a || o), a = o, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: A, 'Execution Time': n,
                        })), clearTimeout(v.performance.timer), v.performance.timer = setTimeout(v.performance.display, 500);
                    },
                    display() { let o = `${h.name}:`; let n = 0; a = !1, clearTimeout(v.performance.timer), e.each(l, function(e, o) { n += o['Execution Time']; }), o += ` ${n}ms`, r && (o += ` '${r}'`), (console.group !== t || console.table !== t) && l.length > 0 && (console.groupCollapsed(o), console.table ? console.table(l) : e.each(l, function(e, o) { console.log(`${o.Name}: ${o['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(o, n, i) { let c; let r; let a; let l = O; return n = n || f, i = A || i, typeof o === 'string' && l !== t && (o = o.split(/[\. ]/), c = o.length - 1, e.each(o, function(n, i) { const s = n != c ? i + o[n + 1].charAt(0).toUpperCase() + o[n + 1].slice(1) : o; if (e.isPlainObject(l[s]) && n != c)l = l[s]; else { if (l[s] !== t) return r = l[s], !1; if (!e.isPlainObject(l[i]) || n == c) return l[i] !== t ? (r = l[i], !1) : (v.error(C.method, o), !1); l = l[i]; } })), e.isFunction(r) ? a = r.apply(i, n) : r !== t && (a = r), e.isArray(s) ? s.push(a) : s !== t ? s = [s, a] : a !== t && (s = a), r; },
            }, u ? (O === t && v.initialize(), O.save.scroll(), O.save.calculations(), v.invoke(d)) : (O !== t && O.invoke('destroy'), v.initialize());
        }), s !== t ? s : this;
    }, e.fn.visibility.settings = {
        name: 'Visibility', namespace: 'visibility', debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: o, throttle: !1, type: !1, zIndex: '10', transition: 'fade in', duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onLoad() {}, onAllLoaded() {}, onFixed() {}, onUnfixed() {}, onUpdate: !1, onRefresh() {}, metadata: { src: 'src' }, className: { fixed: 'fixed', placeholder: 'placeholder', visible: 'visible' }, error: { method: 'The method you called is not defined.', visible: 'Element is hidden, you must call refresh after element becomes visible' },
    };
}(jQuery, window, document));
