!(function(t, e, o, n) {
    e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), t.fn.popup = function(i) {
        let r; const a = t(this); const s = t(o); const p = t(e); const l = t('body'); const u = a.selector || ''; let c = (new Date()).getTime(); let d = []; const f = arguments[0]; const g = typeof f === 'string'; const h = [].slice.call(arguments, 1); return a.each(function() {
            let a; let m; let v; let b; let w; let y; const P = t.isPlainObject(i) ? t.extend(!0, {}, t.fn.popup.settings, i) : t.extend({}, t.fn.popup.settings); const C = P.selector; const T = P.className; const x = P.error; const k = P.metadata; const E = P.namespace; const S = `.${P.namespace}`; const A = `module-${E}`; const F = t(this); const O = t(P.context); const D = t(P.scrollContext); const j = t(P.boundary); const H = P.target ? t(P.target) : F; let R = 0; let N = !1; let V = !1; const W = this; let M = F.data(A); y = {
                initialize() { y.debug('Initializing', F), y.createID(), y.bind.events(), !y.exists() && P.preserve && y.create(), P.observeChanges && y.observeChanges(), y.instantiate(); },
                instantiate() { y.verbose('Storing instance', y), M = y, F.data(A, M); },
                observeChanges() { 'MutationObserver' in e && ((v = new MutationObserver(y.event.documentChanged)).observe(o, { childList: !0, subtree: !0 }), y.debug('Setting up mutation observer', v)); },
                refresh() { P.popup ? a = t(P.popup).eq(0) : P.inline && (a = H.nextAll(C.popup).eq(0), P.popup = a), P.popup ? (a.addClass(T.loading), m = y.get.offsetParent(), a.removeClass(T.loading), P.movePopup && y.has.popup() && y.get.offsetParent(a)[0] !== m[0] && (y.debug('Moving popup to the same offset parent as target'), a.detach().appendTo(m))) : m = P.inline ? y.get.offsetParent(H) : y.has.popup() ? y.get.offsetParent(a) : l, m.is('html') && m[0] !== l[0] && (y.debug('Setting page as offset parent'), m = l), y.get.variation() && y.set.variation(); },
                reposition() { y.refresh(), y.set.position(); },
                destroy() { y.debug('Destroying previous module'), v && v.disconnect(), a && !P.preserve && y.removePopup(), clearTimeout(y.hideTimer), clearTimeout(y.showTimer), y.unbind.close(), y.unbind.events(), F.removeData(A); },
                event: {
                    start(e) { const o = t.isPlainObject(P.delay) ? P.delay.show : P.delay; clearTimeout(y.hideTimer), V || (y.showTimer = setTimeout(y.show, o)); }, end() { const e = t.isPlainObject(P.delay) ? P.delay.hide : P.delay; clearTimeout(y.showTimer), y.hideTimer = setTimeout(y.hide, e); }, touchstart(t) { V = !0, y.show(); }, resize() { y.is.visible() && y.set.position(); }, documentChanged(e) { [].forEach.call(e, function(e) { e.removedNodes && [].forEach.call(e.removedNodes, function(e) { (e == W || t(e).find(W).length > 0) && (y.debug('Element removed from DOM, tearing down events'), y.destroy()); }); }); }, hideGracefully(e) { const n = t(e.target); const i = t.contains(o.documentElement, e.target); const r = n.closest(C.popup).length > 0; e && !r && i ? (y.debug('Click occurred outside popup hiding popup'), y.hide()) : y.debug('Click was inside popup, keeping popup open'); },
                },
                create() { let e = y.get.html(); const o = y.get.title(); const n = y.get.content(); e || n || o ? (y.debug('Creating pop-up html'), e || (e = P.templates.popup({ title: o, content: n })), a = t('<div/>').addClass(T.popup).data(k.activator, F).html(e), P.inline ? (y.verbose('Inserting popup element inline', a), a.insertAfter(F)) : (y.verbose('Appending popup element to body', a), a.appendTo(O)), y.refresh(), y.set.variation(), P.hoverable && y.bind.popup(), P.onCreate.call(a, W)) : H.next(C.popup).length !== 0 ? (y.verbose('Pre-existing popup found'), P.inline = !0, P.popup = H.next(C.popup).data(k.activator, F), y.refresh(), P.hoverable && y.bind.popup()) : P.popup ? (t(P.popup).data(k.activator, F), y.verbose('Used popup specified in settings'), y.refresh(), P.hoverable && y.bind.popup()) : y.debug('No content specified skipping display', W); },
                createID() { w = (`${Math.random().toString(16)}000000000`).substr(2, 8), b = `.${w}`, y.verbose('Creating unique id for element', w); },
                toggle() { y.debug('Toggling pop-up'), y.is.hidden() ? (y.debug('Popup is hidden, showing pop-up'), y.unbind.close(), y.show()) : (y.debug('Popup is visible, hiding pop-up'), y.hide()); },
                show(t) { if (t = t || function() {}, y.debug('Showing pop-up', P.transition), y.is.hidden() && (!y.is.active() || !y.is.dropdown())) { if (y.exists() || y.create(), !1 === P.onShow.call(a, W)) return void y.debug('onShow callback returned false, cancelling popup animation'); P.preserve || P.popup || y.refresh(), a && y.set.position() && (y.save.conditions(), P.exclusive && y.hideAll(), y.animate.show(t)); } },
                hide(t) { if (t = t || function() {}, y.is.visible() || y.is.animating()) { if (!1 === P.onHide.call(a, W)) return void y.debug('onHide callback returned false, cancelling popup animation'); y.remove.visible(), y.unbind.close(), y.restore.conditions(), y.animate.hide(t); } },
                hideAll() { t(C.popup).filter(`.${T.popupVisible}`).each(function() { t(this).data(k.activator).popup('hide'); }); },
                exists() { return !!a && (P.inline || P.popup ? y.has.popup() : a.closest(O).length >= 1); },
                removePopup() { y.has.popup() && !P.popup && (y.debug('Removing popup', a), a.remove(), a = n, P.onRemove.call(a, W)); },
                save: { conditions() { y.cache = { title: F.attr('title') }, y.cache.title && F.removeAttr('title'), y.verbose('Saving original attributes', y.cache.title); } },
                restore: { conditions() { return y.cache && y.cache.title && (F.attr('title', y.cache.title), y.verbose('Restoring original attributes', y.cache.title)), !0; } },
                supports: { svg() { return typeof SVGGraphicsElement === 'undefined'; } },
                animate: {
                    show(e) {
                        e = t.isFunction(e) ? e : function() {}, P.transition && t.fn.transition !== n && F.transition('is supported') ? (y.set.visible(), a.transition({
                            animation: `${P.transition} in`, queue: !1, debug: P.debug, verbose: P.verbose, duration: P.duration, onComplete() { y.bind.close(), e.call(a, W), P.onVisible.call(a, W); },
                        })) : y.error(x.noTransition);
                    },
                    hide(e) {
                        e = t.isFunction(e) ? e : function() {}, y.debug('Hiding pop-up'), !1 !== P.onHide.call(a, W) ? P.transition && t.fn.transition !== n && F.transition('is supported') ? a.transition({
                            animation: `${P.transition} out`, queue: !1, duration: P.duration, debug: P.debug, verbose: P.verbose, onComplete() { y.reset(), e.call(a, W), P.onHidden.call(a, W); },
                        }) : y.error(x.noTransition) : y.debug('onHide callback returned false, cancelling popup animation');
                    },
                },
                change: { content(t) { a.html(t); } },
                get: {
                    html() { return F.removeData(k.html), F.data(k.html) || P.html; },
                    title() { return F.removeData(k.title), F.data(k.title) || P.title; },
                    content() { return F.removeData(k.content), F.data(k.content) || P.content || F.attr('title'); },
                    variation() { return F.removeData(k.variation), F.data(k.variation) || P.variation; },
                    popup() { return a; },
                    popupOffset() { return a.offset(); },
                    calculations() {
                        let t; const o = y.get.offsetParent(a); const n = H[0]; const i = j[0] == e; const r = P.inline || P.popup && P.movePopup ? H.position() : H.offset(); const s = i ? { top: 0, left: 0 } : j.offset(); let l = {}; const u = i ? { top: p.scrollTop(), left: p.scrollLeft() } : { top: 0, left: 0 }; if (l = {
                            target: {
                                element: H[0], width: H.outerWidth(), height: H.outerHeight(), top: r.top, left: r.left, margin: {},
                            },
                            popup: { width: a.outerWidth(), height: a.outerHeight() },
                            parent: { width: m.outerWidth(), height: m.outerHeight() },
                            screen: {
                                top: s.top, left: s.left, scroll: { top: u.top, left: u.left }, width: j.width(), height: j.height(),
                            },
                        }, o.get(0) !== m.get(0)) { const c = o.offset(); l.target.top -= c.top, l.target.left -= c.left, l.parent.width = o.outerWidth(), l.parent.height = o.outerHeight(); } return P.setFluidWidth && y.is.fluid() && (l.container = { width: a.parent().outerWidth() }, l.popup.width = l.container.width), l.target.margin.top = P.inline ? parseInt(e.getComputedStyle(n).getPropertyValue('margin-top'), 10) : 0, l.target.margin.left = P.inline ? y.is.rtl() ? parseInt(e.getComputedStyle(n).getPropertyValue('margin-right'), 10) : parseInt(e.getComputedStyle(n).getPropertyValue('margin-left'), 10) : 0, t = l.screen, l.boundary = {
                            top: t.top + t.scroll.top, bottom: t.top + t.scroll.top + t.height, left: t.left + t.scroll.left, right: t.left + t.scroll.left + t.width,
                        }, l;
                    },
                    id() { return w; },
                    startEvent() { return P.on == 'hover' ? 'mouseenter' : P.on == 'focus' && 'focus'; },
                    scrollEvent() { return 'scroll'; },
                    endEvent() { return P.on == 'hover' ? 'mouseleave' : P.on == 'focus' && 'blur'; },
                    distanceFromBoundary(t, e) {
                        let o; let n; let i = {}; return o = (e = e || y.get.calculations()).popup, n = e.boundary, t && (i = {
                            top: t.top - n.top, left: t.left - n.left, right: n.right - (t.left + o.width), bottom: n.bottom - (t.top + o.height),
                        }, y.verbose('Distance from boundaries determined', t, i)), i;
                    },
                    offsetParent(e) { let o = (e !== n ? e[0] : H[0]).parentNode; let i = t(o); if (o) for (let r = i.css('transform') === 'none', a = i.css('position') === 'static', s = i.is('body'); o && !s && a && r;)o = o.parentNode, r = (i = t(o)).css('transform') === 'none', a = i.css('position') === 'static', s = i.is('body'); return i && i.length > 0 ? i : t(); },
                    positions() {
                        return {
                            'top left': !1, 'top center': !1, 'top right': !1, 'bottom left': !1, 'bottom center': !1, 'bottom right': !1, 'left center': !1, 'right center': !1,
                        };
                    },
                    nextPosition(t) {
                        const e = t.split(' '); const o = e[0]; const n = e[1]; const i = o == 'top' || o == 'bottom'; let r = !1; let a = !1; let s = !1; return N || (y.verbose('All available positions available'), N = y.get.positions()), y.debug('Recording last position tried', t), N[t] = !0, P.prefer === 'opposite' && (s = (s = [{
                            top: 'bottom', bottom: 'top', left: 'right', right: 'left',
                        }[o], n]).join(' '), r = !0 === N[s], y.debug('Trying opposite strategy', s)), P.prefer === 'adjacent' && i && (s = (s = [o, { left: 'center', center: 'right', right: 'left' }[n]]).join(' '), a = !0 === N[s], y.debug('Trying adjacent strategy', s)), (a || r) && (y.debug('Using backup position', s), s = {
                            'top left': 'top center', 'top center': 'top right', 'top right': 'right center', 'right center': 'bottom right', 'bottom right': 'bottom center', 'bottom center': 'bottom left', 'bottom left': 'left center', 'left center': 'top left',
                        }[t]), s;
                    },
                },
                set: {
                    position(t, e) {
                        if (H.length !== 0 && a.length !== 0) {
                            let o; let i; let r; let s; let p; let l; let u; let c; if (e = e || y.get.calculations(), t = t || F.data(k.position) || P.position, o = F.data(k.offset) || P.offset, i = P.distanceAway, r = e.target, s = e.popup, p = e.parent, y.should.centerArrow(e) && (y.verbose('Adjusting offset to center arrow on small target element'), t != 'top left' && t != 'bottom left' || (o += r.width / 2, o -= P.arrowPixelsFromEdge), t != 'top right' && t != 'bottom right' || (o -= r.width / 2, o += P.arrowPixelsFromEdge)), r.width === 0 && r.height === 0 && !y.is.svg(r.element)) return y.debug('Popup target is hidden, no action taken'), !1; switch (P.inline && (y.debug('Adding margin to calculation', r.margin), t == 'left center' || t == 'right center' ? (o += r.margin.top, i += -r.margin.left) : t == 'top left' || t == 'top center' || t == 'top right' ? (o += r.margin.left, i -= r.margin.top) : (o += r.margin.left, i += r.margin.top)), y.debug('Determining popup position from calculations', t, e), y.is.rtl() && (t = t.replace(/left|right/g, function(t) { return t == 'left' ? 'right' : 'left'; }), y.debug('RTL: Popup position updated', t)), R == P.maxSearchDepth && typeof P.lastResort === 'string' && (t = P.lastResort), t) {
                            case 'top left':l = {
                                top: 'auto', bottom: p.height - r.top + i, left: r.left + o, right: 'auto',
                            }; break; case 'top center':l = {
                                bottom: p.height - r.top + i, left: r.left + r.width / 2 - s.width / 2 + o, top: 'auto', right: 'auto',
                            }; break; case 'top right':l = {
                                bottom: p.height - r.top + i, right: p.width - r.left - r.width - o, top: 'auto', left: 'auto',
                            }; break; case 'left center':l = {
                                top: r.top + r.height / 2 - s.height / 2 + o, right: p.width - r.left + i, left: 'auto', bottom: 'auto',
                            }; break; case 'right center':l = {
                                top: r.top + r.height / 2 - s.height / 2 + o, left: r.left + r.width + i, bottom: 'auto', right: 'auto',
                            }; break; case 'bottom left':l = {
                                top: r.top + r.height + i, left: r.left + o, bottom: 'auto', right: 'auto',
                            }; break; case 'bottom center':l = {
                                top: r.top + r.height + i, left: r.left + r.width / 2 - s.width / 2 + o, bottom: 'auto', right: 'auto',
                            }; break; case 'bottom right':l = {
                                top: r.top + r.height + i, right: p.width - r.left - r.width - o, left: 'auto', bottom: 'auto',
                            };
                            } if (l === n && y.error(x.invalidPosition, t), y.debug('Calculated popup positioning values', l), a.css(l).removeClass(T.position).addClass(t).addClass(T.loading), u = y.get.popupOffset(), c = y.get.distanceFromBoundary(u, e), y.is.offstage(c, t)) { if (y.debug('Position is outside viewport', t), R < P.maxSearchDepth) return R++, t = y.get.nextPosition(t), y.debug('Trying new position', t), !!a && y.set.position(t, e); if (!P.lastResort) return y.debug('Popup could not find a position to display', a), y.error(x.cannotPlace, W), y.remove.attempts(), y.remove.loading(), y.reset(), P.onUnplaceable.call(a, W), !1; y.debug('No position found, showing with last position'); } return y.debug('Position is on stage', t), y.remove.attempts(), y.remove.loading(), P.setFluidWidth && y.is.fluid() && y.set.fluidWidth(e), !0;
                        }y.error(x.notFound);
                    },
                    fluidWidth(t) { t = t || y.get.calculations(), y.debug('Automatically setting element width to parent width', t.parent.width), a.css('width', t.container.width); },
                    variation(t) { (t = t || y.get.variation()) && y.has.popup() && (y.verbose('Adding variation to popup', t), a.addClass(t)); },
                    visible() { F.addClass(T.visible); },
                },
                remove: {
                    loading() { a.removeClass(T.loading); }, variation(t) { (t = t || y.get.variation()) && (y.verbose('Removing variation', t), a.removeClass(t)); }, visible() { F.removeClass(T.visible); }, attempts() { y.verbose('Resetting all searched positions'), R = 0, N = !1; },
                },
                bind: {
                    events() { y.debug('Binding popup events to module'), P.on == 'click' && F.on(`click${S}`, y.toggle), P.on == 'hover' && F.on(`touchstart${S}`, y.event.touchstart), y.get.startEvent() && F.on(y.get.startEvent() + S, y.event.start).on(y.get.endEvent() + S, y.event.end), P.target && y.debug('Target set to element', H), p.on(`resize${b}`, y.event.resize); }, popup() { y.verbose('Allowing hover events on popup to prevent closing'), a && y.has.popup() && a.on(`mouseenter${S}`, y.event.start).on(`mouseleave${S}`, y.event.end); }, close() { (!0 === P.hideOnScroll || P.hideOnScroll == 'auto' && P.on != 'click') && y.bind.closeOnScroll(), P.on == 'hover' && V && y.bind.touchClose(), P.on == 'click' && P.closable && y.bind.clickaway(); }, closeOnScroll() { y.verbose('Binding scroll close event to document'), D.one(y.get.scrollEvent() + b, y.event.hideGracefully); }, touchClose() { y.verbose('Binding popup touchclose event to document'), s.on(`touchstart${b}`, function(t) { y.verbose('Touched away from popup'), y.event.hideGracefully.call(W, t); }); }, clickaway() { y.verbose('Binding popup close event to document'), s.on(`click${b}`, function(t) { y.verbose('Clicked away from popup'), y.event.hideGracefully.call(W, t); }); },
                },
                unbind: { events() { p.off(b), F.off(S); }, close() { s.off(b), D.off(b); } },
                has: { popup() { return a && a.length > 0; } },
                should: { centerArrow(t) { return !y.is.basic() && t.target.width <= 2 * P.arrowPixelsFromEdge; } },
                is: {
                    offstage(e, o) { const n = []; return t.each(e, function(t, e) { e < -P.jitter && (y.debug('Position exceeds allowable distance from edge', t, e, o), n.push(t)); }), n.length > 0; }, svg(t) { return y.supports.svg() && t instanceof SVGGraphicsElement; }, basic() { return F.hasClass(T.basic); }, active() { return F.hasClass(T.active); }, animating() { return a !== n && a.hasClass(T.animating); }, fluid() { return a !== n && a.hasClass(T.fluid); }, visible() { return a !== n && a.hasClass(T.popupVisible); }, dropdown() { return F.hasClass(T.dropdown); }, hidden() { return !y.is.visible(); }, rtl() { return F.css('direction') == 'rtl'; },
                },
                reset() { y.remove.visible(), P.preserve ? t.fn.transition !== n && a.transition('remove transition') : y.removePopup(); },
                setting(e, o) { if (t.isPlainObject(e))t.extend(!0, P, e); else { if (o === n) return P[e]; P[e] = o; } },
                internal(e, o) { if (t.isPlainObject(e))t.extend(!0, y, e); else { if (o === n) return y[e]; y[e] = o; } },
                debug() { !P.silent && P.debug && (P.performance ? y.performance.log(arguments) : (y.debug = Function.prototype.bind.call(console.info, console, `${P.name}:`), y.debug.apply(console, arguments))); },
                verbose() { !P.silent && P.verbose && P.debug && (P.performance ? y.performance.log(arguments) : (y.verbose = Function.prototype.bind.call(console.info, console, `${P.name}:`), y.verbose.apply(console, arguments))); },
                error() { P.silent || (y.error = Function.prototype.bind.call(console.error, console, `${P.name}:`), y.error.apply(console, arguments)); },
                performance: {
                    log(t) {
                        let e; let o; P.performance && (o = (e = (new Date()).getTime()) - (c || e), c = e, d.push({
                            Name: t[0], Arguments: [].slice.call(t, 1) || '', Element: W, 'Execution Time': o,
                        })), clearTimeout(y.performance.timer), y.performance.timer = setTimeout(y.performance.display, 500);
                    },
                    display() { let e = `${P.name}:`; let o = 0; c = !1, clearTimeout(y.performance.timer), t.each(d, function(t, e) { o += e['Execution Time']; }), e += ` ${o}ms`, u && (e += ` '${u}'`), (console.group !== n || console.table !== n) && d.length > 0 && (console.groupCollapsed(e), console.table ? console.table(d) : t.each(d, function(t, e) { console.log(`${e.Name}: ${e['Execution Time']}ms`); }), console.groupEnd()), d = []; },
                },
                invoke(e, o, i) { let a; let s; let p; let l = M; return o = o || h, i = W || i, typeof e === 'string' && l !== n && (e = e.split(/[\. ]/), a = e.length - 1, t.each(e, function(o, i) { const r = o != a ? i + e[o + 1].charAt(0).toUpperCase() + e[o + 1].slice(1) : e; if (t.isPlainObject(l[r]) && o != a)l = l[r]; else { if (l[r] !== n) return s = l[r], !1; if (!t.isPlainObject(l[i]) || o == a) return l[i] !== n && (s = l[i], !1); l = l[i]; } })), t.isFunction(s) ? p = s.apply(i, o) : s !== n && (p = s), t.isArray(r) ? r.push(p) : r !== n ? r = [r, p] : p !== n && (r = p), s; },
            }, g ? (M === n && y.initialize(), y.invoke(f)) : (M !== n && M.invoke('destroy'), y.initialize());
        }), r !== n ? r : this;
    }, t.fn.popup.settings = {
        name: 'Popup',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        namespace: 'popup',
        observeChanges: !0,
        onCreate() {},
        onRemove() {},
        onShow() {},
        onVisible() {},
        onHide() {},
        onUnplaceable() {},
        onHidden() {},
        on: 'hover',
        boundary: e,
        addTouchEvents: !0,
        position: 'top left',
        variation: '',
        movePopup: !0,
        target: !1,
        popup: !1,
        inline: !1,
        preserve: !1,
        hoverable: !1,
        content: !1,
        html: !1,
        title: !1,
        closable: !0,
        hideOnScroll: 'auto',
        exclusive: !1,
        context: 'body',
        scrollContext: e,
        prefer: 'opposite',
        lastResort: !1,
        arrowPixelsFromEdge: 20,
        delay: { show: 50, hide: 70 },
        setFluidWidth: !0,
        duration: 200,
        transition: 'scale',
        distanceAway: 0,
        jitter: 2,
        offset: 0,
        maxSearchDepth: 15,
        error: {
            invalidPosition: 'The position you specified is not a valid position', cannotPlace: 'Popup does not fit within the boundaries of the viewport', method: 'The method you called is not defined.', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>', notFound: 'The target or popup you specified does not exist on the page',
        },
        metadata: {
            activator: 'activator', content: 'content', html: 'html', offset: 'offset', position: 'position', title: 'title', variation: 'variation',
        },
        className: {
            active: 'active', basic: 'basic', animating: 'animating', dropdown: 'dropdown', fluid: 'fluid', loading: 'loading', popup: 'ui popup', position: 'top left center bottom right', visible: 'visible', popupVisible: 'visible',
        },
        selector: { popup: '.ui.popup' },
        templates: {
            escape(t) {
                const e = {
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
                }; return /[&<>"'`]/.test(t) ? t.replace(/[&<>"'`]/g, function(t) { return e[t]; }) : t;
            },
            popup(e) { let o = ''; const i = t.fn.popup.settings.templates.escape; return typeof e !== n && (typeof e.title !== n && e.title && (e.title = i(e.title), o += `<div class="header">${e.title}</div>`), typeof e.content !== n && e.content && (e.content = i(e.content), o += `<div class="content">${e.content}</div>`)), o; },
        },
    };
}(jQuery, window, document));
