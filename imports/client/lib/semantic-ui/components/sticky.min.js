!(function(e, t, o, n) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.sticky = function(i) {
        let s; const r = e(this); const c = r.selector || ''; let l = (new Date()).getTime(); let a = []; const f = arguments[0]; const m = typeof f === 'string'; const u = [].slice.call(arguments, 1); return r.each(function() {
            let r; let d; let h; let g; let p; const b = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.sticky.settings, i) : e.extend({}, e.fn.sticky.settings); const v = b.className; const x = b.namespace; const C = b.error; const S = `.${x}`; const y = `module-${x}`; const k = e(this); const z = e(t); const T = e(b.scrollContext); let w = (k.selector, k.data(y)); const B = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; const P = this; p = {
                initialize() { p.determineContainer(), p.determineContext(), p.verbose('Initializing sticky', b, r), p.save.positions(), p.checkErrors(), p.bind.events(), b.observeChanges && p.observeChanges(), p.instantiate(); },
                instantiate() { p.verbose('Storing instance of module', p), w = p, k.data(y, p); },
                destroy() { p.verbose('Destroying previous instance'), p.reset(), h && h.disconnect(), g && g.disconnect(), z.off(`load${S}`, p.event.load).off(`resize${S}`, p.event.resize), T.off(`scrollchange${S}`, p.event.scrollchange), k.removeData(y); },
                observeChanges() { 'MutationObserver' in t && (h = new MutationObserver(p.event.documentChanged), g = new MutationObserver(p.event.changed), h.observe(o, { childList: !0, subtree: !0 }), g.observe(P, { childList: !0, subtree: !0 }), g.observe(d[0], { childList: !0, subtree: !0 }), p.debug('Setting up mutation observer', g)); },
                determineContainer() { r = b.container ? e(b.container) : k.offsetParent(); },
                determineContext() { (d = b.context ? e(b.context) : r).length !== 0 || p.error(C.invalidContext, b.context, k); },
                checkErrors() { if (p.is.hidden() && p.error(C.visible, k), p.cache.element.height > p.cache.context.height) return p.reset(), void p.error(C.elementSize, k); },
                bind: { events() { z.on(`load${S}`, p.event.load).on(`resize${S}`, p.event.resize), T.off(`scroll${S}`).on(`scroll${S}`, p.event.scroll).on(`scrollchange${S}`, p.event.scrollchange); } },
                event: {
                    changed(e) { clearTimeout(p.timer), p.timer = setTimeout(function() { p.verbose('DOM tree modified, updating sticky menu', e), p.refresh(); }, 100); }, documentChanged(t) { [].forEach.call(t, function(t) { t.removedNodes && [].forEach.call(t.removedNodes, function(t) { (t == P || e(t).find(P).length > 0) && (p.debug('Element removed from DOM, tearing down events'), p.destroy()); }); }); }, load() { p.verbose('Page contents finished loading'), B(p.refresh); }, resize() { p.verbose('Window resized'), B(p.refresh); }, scroll() { B(function() { T.triggerHandler(`scrollchange${S}`, T.scrollTop()); }); }, scrollchange(e, t) { p.stick(t), b.onScroll.call(P); },
                },
                refresh(e) { p.reset(), b.context || p.determineContext(), e && p.determineContainer(), p.save.positions(), p.stick(), b.onReposition.call(P); },
                supports: { sticky() { const t = e('<div/>'); t[0]; return t.addClass(v.supported), t.css('position').match('sticky'); } },
                save: {
                    lastScroll(e) { p.lastScroll = e; },
                    elementScroll(e) { p.elementScroll = e; },
                    positions() {
                        const e = { height: T.height() }; const t = {
                            margin: { top: parseInt(k.css('margin-top'), 10), bottom: parseInt(k.css('margin-bottom'), 10) }, offset: k.offset(), width: k.outerWidth(), height: k.outerHeight(),
                        }; const o = { offset: d.offset(), height: d.outerHeight() }; r.outerHeight(); p.is.standardScroll() || (p.debug('Non-standard scroll. Removing scroll offset from element offset'), e.top = T.scrollTop(), e.left = T.scrollLeft(), t.offset.top += e.top, o.offset.top += e.top, t.offset.left += e.left, o.offset.left += e.left), p.cache = {
                            fits: t.height + b.offset <= e.height,
                            sameHeight: t.height == o.height,
                            scrollContext: { height: e.height },
                            element: {
                                margin: t.margin, top: t.offset.top - t.margin.top, left: t.offset.left, width: t.width, height: t.height, bottom: t.offset.top + t.height,
                            },
                            context: { top: o.offset.top, height: o.height, bottom: o.offset.top + o.height },
                        }, p.set.containerSize(), p.stick(), p.debug('Caching element positions', p.cache);
                    },
                },
                get: {
                    direction(e) { let t = 'down'; return e = e || T.scrollTop(), p.lastScroll !== n && (p.lastScroll < e ? t = 'down' : p.lastScroll > e && (t = 'up')), t; }, scrollChange(e) { return e = e || T.scrollTop(), p.lastScroll ? e - p.lastScroll : 0; }, currentElementScroll() { return p.elementScroll ? p.elementScroll : p.is.top() ? Math.abs(parseInt(k.css('top'), 10)) || 0 : Math.abs(parseInt(k.css('bottom'), 10)) || 0; }, elementScroll(e) { e = e || T.scrollTop(); const t = p.cache.element; const o = p.cache.scrollContext; const n = p.get.scrollChange(e); const i = t.height - o.height + b.offset; let s = p.get.currentElementScroll(); const r = s + n; return s = p.cache.fits || r < 0 ? 0 : r > i ? i : r; },
                },
                remove: {
                    lastScroll() { delete p.lastScroll; }, elementScroll(e) { delete p.elementScroll; }, minimumSize() { r.css('min-height', ''); }, offset() { k.css('margin-top', ''); },
                },
                set: {
                    offset() { p.verbose('Setting offset on element', b.offset), k.css('margin-top', b.offset); }, containerSize() { const e = r.get(0).tagName; e === 'HTML' || e == 'body' ? p.determineContainer() : Math.abs(r.outerHeight() - p.cache.context.height) > b.jitter && (p.debug('Context has padding, specifying exact height for container', p.cache.context.height), r.css({ height: p.cache.context.height })); }, minimumSize() { const e = p.cache.element; r.css('min-height', e.height); }, scroll(e) { p.debug('Setting scroll on element', e), p.elementScroll != e && (p.is.top() && k.css('bottom', '').css('top', -e), p.is.bottom() && k.css('top', '').css('bottom', e)); }, size() { p.cache.element.height !== 0 && p.cache.element.width !== 0 && (P.style.setProperty('width', `${p.cache.element.width}px`, 'important'), P.style.setProperty('height', `${p.cache.element.height}px`, 'important')); },
                },
                is: {
                    standardScroll() { return T[0] == t; }, top() { return k.hasClass(v.top); }, bottom() { return k.hasClass(v.bottom); }, initialPosition() { return !p.is.fixed() && !p.is.bound(); }, hidden() { return !k.is(':visible'); }, bound() { return k.hasClass(v.bound); }, fixed() { return k.hasClass(v.fixed); },
                },
                stick(e) { const t = e || T.scrollTop(); const o = p.cache; const n = o.fits; const i = o.sameHeight; const s = o.element; const r = o.scrollContext; const c = o.context; const l = p.is.bottom() && b.pushing ? b.bottomOffset : b.offset; const a = (e = { top: t + l, bottom: t + l + r.height }, p.get.direction(e.top), n ? 0 : p.get.elementScroll(e.top)); const f = !n; s.height !== 0 && !i && (p.is.initialPosition() ? e.top >= c.bottom ? (p.debug('Initial element position is bottom of container'), p.bindBottom()) : e.top > s.top && (s.height + e.top - a >= c.bottom ? (p.debug('Initial element position is bottom of container'), p.bindBottom()) : (p.debug('Initial element position is fixed'), p.fixTop())) : p.is.fixed() ? p.is.top() ? e.top <= s.top ? (p.debug('Fixed element reached top of container'), p.setInitialPosition()) : s.height + e.top - a >= c.bottom ? (p.debug('Fixed element reached bottom of container'), p.bindBottom()) : f && (p.set.scroll(a), p.save.lastScroll(e.top), p.save.elementScroll(a)) : p.is.bottom() && (e.bottom - s.height <= s.top ? (p.debug('Bottom fixed rail has reached top of container'), p.setInitialPosition()) : e.bottom >= c.bottom ? (p.debug('Bottom fixed rail has reached bottom of container'), p.bindBottom()) : f && (p.set.scroll(a), p.save.lastScroll(e.top), p.save.elementScroll(a))) : p.is.bottom() && (e.top <= s.top ? (p.debug('Jumped from bottom fixed to top fixed, most likely used home/end button'), p.setInitialPosition()) : b.pushing ? p.is.bound() && e.bottom <= c.bottom && (p.debug('Fixing bottom attached element to bottom of browser.'), p.fixBottom()) : p.is.bound() && e.top <= c.bottom - s.height && (p.debug('Fixing bottom attached element to top of browser.'), p.fixTop()))); },
                bindTop() {
                    p.debug('Binding element to top of parent container'), p.remove.offset(), k.css({ left: '', top: '', marginBottom: '' }).removeClass(v.fixed).removeClass(v.bottom).addClass(v.bound)
                        .addClass(v.top), b.onTop.call(P), b.onUnstick.call(P);
                },
                bindBottom() {
                    p.debug('Binding element to bottom of parent container'), p.remove.offset(), k.css({ left: '', top: '' }).removeClass(v.fixed).removeClass(v.top).addClass(v.bound)
                        .addClass(v.bottom), b.onBottom.call(P), b.onUnstick.call(P);
                },
                setInitialPosition() { p.debug('Returning to initial position'), p.unfix(), p.unbind(); },
                fixTop() {
                    p.debug('Fixing element to top of page'), b.setSize && p.set.size(), p.set.minimumSize(), p.set.offset(), k.css({ left: p.cache.element.left, bottom: '', marginBottom: '' }).removeClass(v.bound).removeClass(v.bottom).addClass(v.fixed)
                        .addClass(v.top), b.onStick.call(P);
                },
                fixBottom() {
                    p.debug('Sticking element to bottom of page'), b.setSize && p.set.size(), p.set.minimumSize(), p.set.offset(), k.css({ left: p.cache.element.left, bottom: '', marginBottom: '' }).removeClass(v.bound).removeClass(v.top).addClass(v.fixed)
                        .addClass(v.bottom), b.onStick.call(P);
                },
                unbind() { p.is.bound() && (p.debug('Removing container bound position on element'), p.remove.offset(), k.removeClass(v.bound).removeClass(v.top).removeClass(v.bottom)); },
                unfix() { p.is.fixed() && (p.debug('Removing fixed position on element'), p.remove.minimumSize(), p.remove.offset(), k.removeClass(v.fixed).removeClass(v.top).removeClass(v.bottom), b.onUnstick.call(P)); },
                reset() { p.debug('Resetting elements position'), p.unbind(), p.unfix(), p.resetCSS(), p.remove.offset(), p.remove.lastScroll(); },
                resetCSS() { k.css({ width: '', height: '' }), r.css({ height: '' }); },
                setting(t, o) { if (e.isPlainObject(t))e.extend(!0, b, t); else { if (o === n) return b[t]; b[t] = o; } },
                internal(t, o) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (o === n) return p[t]; p[t] = o; } },
                debug() { !b.silent && b.debug && (b.performance ? p.performance.log(arguments) : (p.debug = Function.prototype.bind.call(console.info, console, `${b.name}:`), p.debug.apply(console, arguments))); },
                verbose() { !b.silent && b.verbose && b.debug && (b.performance ? p.performance.log(arguments) : (p.verbose = Function.prototype.bind.call(console.info, console, `${b.name}:`), p.verbose.apply(console, arguments))); },
                error() { b.silent || (p.error = Function.prototype.bind.call(console.error, console, `${b.name}:`), p.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let o; b.performance && (o = (t = (new Date()).getTime()) - (l || t), l = t, a.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: P, 'Execution Time': o,
                        })), clearTimeout(p.performance.timer), p.performance.timer = setTimeout(p.performance.display, 0);
                    },
                    display() { let t = `${b.name}:`; let o = 0; l = !1, clearTimeout(p.performance.timer), e.each(a, function(e, t) { o += t['Execution Time']; }), t += ` ${o}ms`, c && (t += ` '${c}'`), (console.group !== n || console.table !== n) && a.length > 0 && (console.groupCollapsed(t), console.table ? console.table(a) : e.each(a, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), a = []; },
                },
                invoke(t, o, i) { let r; let c; let l; let a = w; return o = o || u, i = P || i, typeof t === 'string' && a !== n && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, function(o, i) { const s = o != r ? i + t[o + 1].charAt(0).toUpperCase() + t[o + 1].slice(1) : t; if (e.isPlainObject(a[s]) && o != r)a = a[s]; else { if (a[s] !== n) return c = a[s], !1; if (!e.isPlainObject(a[i]) || o == r) return a[i] !== n && (c = a[i], !1); a = a[i]; } })), e.isFunction(c) ? l = c.apply(i, o) : c !== n && (l = c), e.isArray(s) ? s.push(l) : s !== n ? s = [s, l] : l !== n && (s = l), c; },
            }, m ? (w === n && p.initialize(), p.invoke(f)) : (w !== n && w.invoke('destroy'), p.initialize());
        }), s !== n ? s : this;
    }, e.fn.sticky.settings = {
        name: 'Sticky',
        namespace: 'sticky',
        silent: !1,
        debug: !1,
        verbose: !0,
        performance: !0,
        pushing: !1,
        context: !1,
        container: !1,
        scrollContext: t,
        offset: 0,
        bottomOffset: 0,
        jitter: 5,
        setSize: !0,
        observeChanges: !1,
        onReposition() {},
        onScroll() {},
        onStick() {},
        onUnstick() {},
        onTop() {},
        onBottom() {},
        error: {
            container: 'Sticky element must be inside a relative container', visible: 'Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.', method: 'The method you called is not defined.', invalidContext: 'Context specified does not exist', elementSize: 'Sticky element is larger than its container, cannot create sticky.',
        },
        className: {
            bound: 'bound', fixed: 'fixed', supported: 'native', top: 'top', bottom: 'bottom',
        },
    };
}(jQuery, window, document));
