!(function(e, t, i, n) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.shape = function(a) {
        let o; const s = e(this); let r = (e('body'), (new Date()).getTime()); let l = []; const d = arguments[0]; const u = typeof d === 'string'; const c = [].slice.call(arguments, 1); const g = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; return s.each(function() {
            let t; let f; let m; const h = s.selector || ''; const p = e.isPlainObject(a) ? e.extend(!0, {}, e.fn.shape.settings, a) : e.extend({}, e.fn.shape.settings); const v = p.namespace; const b = p.selector; const x = p.error; const y = p.className; const S = `.${v}`; const w = `module-${v}`; let C = e(this); let W = C.find(b.sides); let F = C.find(b.side); let H = !1; const T = this; let Z = C.data(w); m = {
                initialize() { m.verbose('Initializing module for', T), m.set.defaultSide(), m.instantiate(); },
                instantiate() { m.verbose('Storing instance of module', m), Z = m, C.data(w, Z); },
                destroy() { m.verbose('Destroying previous module for', T), C.removeData(w).off(S); },
                refresh() { m.verbose('Refreshing selector cache for', T), C = e(T), W = e(this).find(b.shape), F = e(this).find(b.side); },
                repaint() { m.verbose('Forcing repaint event'); (W[0] || i.createElement('div')).offsetWidth; },
                animate(e, i) { m.verbose('Animating box with properties', e), i = i || function(e) { m.verbose('Executing animation callback'), e !== n && e.stopPropagation(), m.reset(), m.set.active(); }, p.beforeChange.call(f[0]), m.get.transitionEvent() ? (m.verbose('Starting CSS animation'), C.addClass(y.animating), W.css(e).one(m.get.transitionEvent(), i), m.set.duration(p.duration), g(function() { C.addClass(y.animating), t.addClass(y.hidden); })) : i(); },
                queue(e) { m.debug('Queueing animation of', e), W.one(m.get.transitionEvent(), function() { m.debug('Executing queued animation'), setTimeout(function() { C.shape(e); }, 0); }); },
                reset() { m.verbose('Animating states reset'), C.removeClass(y.animating).attr('style', '').removeAttr('style'), W.attr('style', '').removeAttr('style'), F.attr('style', '').removeAttr('style').removeClass(y.hidden), f.removeClass(y.animating).attr('style', '').removeAttr('style'); },
                is: { complete() { return F.filter(`.${y.active}`)[0] == f[0]; }, animating() { return C.hasClass(y.animating); } },
                set: {
                    defaultSide() { t = C.find(`.${p.className.active}`), f = t.next(b.side).length > 0 ? t.next(b.side) : C.find(b.side).first(), H = !1, m.verbose('Active side set to', t), m.verbose('Next side set to', f); },
                    duration(e) {
                        e = typeof (e = e || p.duration) === 'number' ? `${e}ms` : e, m.verbose('Setting animation duration', e), (p.duration || p.duration === 0) && W.add(F).css({
                            '-webkit-transition-duration': e, '-moz-transition-duration': e, '-ms-transition-duration': e, '-o-transition-duration': e, 'transition-duration': e,
                        });
                    },
                    currentStageSize() { const e = C.find(`.${p.className.active}`); const t = e.outerWidth(!0); const i = e.outerHeight(!0); C.css({ width: t, height: i }); },
                    stageSize() { const e = C.clone().addClass(y.loading); const t = e.find(`.${p.className.active}`); const i = H ? e.find(b.side).eq(H) : t.next(b.side).length > 0 ? t.next(b.side) : e.find(b.side).first(); const n = p.width == 'next' ? i.outerWidth(!0) : p.width == 'initial' ? C.width() : p.width; const a = p.height == 'next' ? i.outerHeight(!0) : p.height == 'initial' ? C.height() : p.height; t.removeClass(y.active), i.addClass(y.active), e.insertAfter(C), e.remove(), p.width != 'auto' && (C.css('width', n + p.jitter), m.verbose('Specifying width during animation', n)), p.height != 'auto' && (C.css('height', a + p.jitter), m.verbose('Specifying height during animation', a)); },
                    nextSide(e) { H = e, f = F.filter(e), H = F.index(f), f.length === 0 && (m.set.defaultSide(), m.error(x.side)), m.verbose('Next side manually set to', f); },
                    active() { m.verbose('Setting new side to active', f), F.removeClass(y.active), f.addClass(y.active), p.onChange.call(f[0]), m.set.defaultSide(); },
                },
                flip: {
                    up() { if (!m.is.complete() || m.is.animating() || p.allowRepeats) if (m.is.animating())m.queue('flip up'); else { m.debug('Flipping up', f); const e = m.get.transform.up(); m.set.stageSize(), m.stage.above(), m.animate(e); } else m.debug('Side already visible', f); }, down() { if (!m.is.complete() || m.is.animating() || p.allowRepeats) if (m.is.animating())m.queue('flip down'); else { m.debug('Flipping down', f); const e = m.get.transform.down(); m.set.stageSize(), m.stage.below(), m.animate(e); } else m.debug('Side already visible', f); }, left() { if (!m.is.complete() || m.is.animating() || p.allowRepeats) if (m.is.animating())m.queue('flip left'); else { m.debug('Flipping left', f); const e = m.get.transform.left(); m.set.stageSize(), m.stage.left(), m.animate(e); } else m.debug('Side already visible', f); }, right() { if (!m.is.complete() || m.is.animating() || p.allowRepeats) if (m.is.animating())m.queue('flip right'); else { m.debug('Flipping right', f); const e = m.get.transform.right(); m.set.stageSize(), m.stage.right(), m.animate(e); } else m.debug('Side already visible', f); }, over() { !m.is.complete() || m.is.animating() || p.allowRepeats ? m.is.animating() ? m.queue('flip over') : (m.debug('Flipping over', f), m.set.stageSize(), m.stage.behind(), m.animate(m.get.transform.over())) : m.debug('Side already visible', f); }, back() { !m.is.complete() || m.is.animating() || p.allowRepeats ? m.is.animating() ? m.queue('flip back') : (m.debug('Flipping back', f), m.set.stageSize(), m.stage.behind(), m.animate(m.get.transform.back())) : m.debug('Side already visible', f); },
                },
                get: {
                    transform: {
                        up() { return { transform: `translateY(${-(t.outerHeight(!0) - f.outerHeight(!0)) / 2}px) translateZ(${-t.outerHeight(!0) / 2}px) rotateX(-90deg)` }; }, down() { return { transform: `translateY(${-(t.outerHeight(!0) - f.outerHeight(!0)) / 2}px) translateZ(${-t.outerHeight(!0) / 2}px) rotateX(90deg)` }; }, left() { return { transform: `translateX(${-(t.outerWidth(!0) - f.outerWidth(!0)) / 2}px) translateZ(${-t.outerWidth(!0) / 2}px) rotateY(90deg)` }; }, right() { return { transform: `translateX(${-(t.outerWidth(!0) - f.outerWidth(!0)) / 2}px) translateZ(${-t.outerWidth(!0) / 2}px) rotateY(-90deg)` }; }, over() { return { transform: `translateX(${-(t.outerWidth(!0) - f.outerWidth(!0)) / 2}px) rotateY(180deg)` }; }, back() { return { transform: `translateX(${-(t.outerWidth(!0) - f.outerWidth(!0)) / 2}px) rotateY(-180deg)` }; },
                    },
                    transitionEvent() {
                        let e; const t = i.createElement('element'); const a = {
                            transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
                        }; for (e in a) if (t.style[e] !== n) return a[e];
                    },
                    nextSide() { return t.next(b.side).length > 0 ? t.next(b.side) : C.find(b.side).first(); },
                },
                stage: {
                    above() { const e = { origin: (t.outerHeight(!0) - f.outerHeight(!0)) / 2, depth: { active: f.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; m.verbose('Setting the initial animation position as above', f, e), W.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), f.addClass(y.animating).css({ top: `${e.origin}px`, transform: `rotateX(90deg) translateZ(${e.depth.next}px)` }); }, below() { const e = { origin: (t.outerHeight(!0) - f.outerHeight(!0)) / 2, depth: { active: f.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; m.verbose('Setting the initial animation position as below', f, e), W.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), f.addClass(y.animating).css({ top: `${e.origin}px`, transform: `rotateX(-90deg) translateZ(${e.depth.next}px)` }); }, left() { const e = t.outerWidth(!0); const i = f.outerWidth(!0); const n = { origin: (e - i) / 2, depth: { active: i / 2, next: e / 2 } }; m.verbose('Setting the initial animation position as left', f, n), W.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: `rotateY(-90deg) translateZ(${n.depth.next}px)` }); }, right() { const e = t.outerWidth(!0); const i = f.outerWidth(!0); const n = { origin: (e - i) / 2, depth: { active: i / 2, next: e / 2 } }; m.verbose('Setting the initial animation position as left', f, n), W.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: `rotateY(90deg) translateZ(${n.depth.next}px)` }); }, behind() { const e = t.outerWidth(!0); const i = f.outerWidth(!0); const n = { origin: (e - i) / 2, depth: { active: i / 2, next: e / 2 } }; m.verbose('Setting the initial animation position as behind', f, n), t.css({ transform: 'rotateY(0deg)' }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: 'rotateY(-180deg)' }); },
                },
                setting(t, i) { if (m.debug('Changing setting', t, i), e.isPlainObject(t))e.extend(!0, p, t); else { if (i === n) return p[t]; e.isPlainObject(p[t]) ? e.extend(!0, p[t], i) : p[t] = i; } },
                internal(t, i) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (i === n) return m[t]; m[t] = i; } },
                debug() { !p.silent && p.debug && (p.performance ? m.performance.log(arguments) : (m.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), m.debug.apply(console, arguments))); },
                verbose() { !p.silent && p.verbose && p.debug && (p.performance ? m.performance.log(arguments) : (m.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), m.verbose.apply(console, arguments))); },
                error() { p.silent || (m.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), m.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let i; p.performance && (i = (t = (new Date()).getTime()) - (r || t), r = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: T, 'Execution Time': i,
                        })), clearTimeout(m.performance.timer), m.performance.timer = setTimeout(m.performance.display, 500);
                    },
                    display() { let t = `${p.name}:`; let i = 0; r = !1, clearTimeout(m.performance.timer), e.each(l, function(e, t) { i += t['Execution Time']; }), t += ` ${i}ms`, h && (t += ` '${h}'`), s.length > 1 && (t += ` (${s.length})`), (console.group !== n || console.table !== n) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, i, a) { let s; let r; let l; let d = Z; return i = i || c, a = T || a, typeof t === 'string' && d !== n && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, function(i, a) { const o = i != s ? a + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(d[o]) && i != s)d = d[o]; else { if (d[o] !== n) return r = d[o], !1; if (!e.isPlainObject(d[a]) || i == s) return d[a] !== n && (r = d[a], !1); d = d[a]; } })), e.isFunction(r) ? l = r.apply(a, i) : r !== n && (l = r), e.isArray(o) ? o.push(l) : o !== n ? o = [o, l] : l !== n && (o = l), r; },
            }, u ? (Z === n && m.initialize(), m.invoke(d)) : (Z !== n && Z.invoke('destroy'), m.initialize());
        }), o !== n ? o : this;
    }, e.fn.shape.settings = {
        name: 'Shape',
        silent: !1,
        debug: !1,
        verbose: !1,
        jitter: 0,
        performance: !0,
        namespace: 'shape',
        width: 'initial',
        height: 'initial',
        beforeChange() {},
        onChange() {},
        allowRepeats: !1,
        duration: !1,
        error: { side: 'You tried to switch to a side that does not exist.', method: 'The method you called is not defined' },
        className: {
            animating: 'animating', hidden: 'hidden', loading: 'loading', active: 'active',
        },
        selector: { sides: '.sides', side: '.side' },
    };
}(jQuery, window, document));
