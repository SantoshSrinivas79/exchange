!(function(n, e, i, t) {
    e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), n.fn.transition = function() {
        let a; const o = n(this); const r = o.selector || ''; let s = (new Date()).getTime(); let l = []; const u = arguments; const d = u[0]; const c = [].slice.call(arguments, 1); let m = typeof d === 'string'; e.requestAnimationFrame || e.mozRequestAnimationFrame || e.webkitRequestAnimationFrame || e.msRequestAnimationFrame; return o.each(function(e) {
            let f; let p; let g; let v; let b; let y; let h; let w; let C; const A = n(this); const S = this; (C = {
                initialize() { f = C.get.settings.apply(S, u), v = f.className, g = f.error, b = f.metadata, w = `.${f.namespace}`, h = `module-${f.namespace}`, p = A.data(h) || C, y = C.get.animationEndEvent(), m && (m = C.invoke(d)), !1 === m && (C.verbose('Converted arguments into settings object', f), f.interval ? C.delay(f.animate) : C.animate(), C.instantiate()); },
                instantiate() { C.verbose('Storing instance of module', C), p = C, A.data(h, p); },
                destroy() { C.verbose('Destroying previous module for', S), A.removeData(h); },
                refresh() { C.verbose('Refreshing display type on next animation'), delete C.displayType; },
                forceRepaint() { C.verbose('Forcing element repaint'); const n = A.parent(); const e = A.next(); e.length === 0 ? A.detach().appendTo(n) : A.detach().insertBefore(e); },
                repaint() { C.verbose('Repainting element'); S.offsetWidth; },
                delay(n) { let i; let a = C.get.animationDirection(); a || (a = C.can.transition() ? C.get.direction() : 'static'), n = n !== t ? n : f.interval, i = f.reverse == 'auto' && a == v.outward || f.reverse == 1 ? (o.length - e) * f.interval : e * f.interval, C.debug('Delaying animation by', i), setTimeout(C.animate, i); },
                animate(n) { if (f = n || f, !C.is.supported()) return C.error(g.support), !1; if (C.debug('Preparing animation', f.animation), C.is.animating()) { if (f.queue) return !f.allowRepeats && C.has.direction() && C.is.occurring() && !0 !== C.queuing ? C.debug('Animation is currently occurring, preventing queueing same animation', f.animation) : C.queue(f.animation), !1; if (!f.allowRepeats && C.is.occurring()) return C.debug('Animation is already occurring, will not execute repeated animation', f.animation), !1; C.debug('New animation started, completing previous early', f.animation), p.complete(); }C.can.animate() ? C.set.animating(f.animation) : C.error(g.noAnimation, f.animation, S); },
                reset() { C.debug('Resetting animation to beginning conditions'), C.remove.animationCallbacks(), C.restore.conditions(), C.remove.animating(); },
                queue(n) { C.debug('Queueing animation of', n), C.queuing = !0, A.one(`${y}.queue${w}`, function() { C.queuing = !1, C.repaint(), C.animate.apply(this, f); }); },
                complete(n) { C.debug('Animation complete', f.animation), C.remove.completeCallback(), C.remove.failSafe(), C.is.looping() || (C.is.outward() ? (C.verbose('Animation is outward, hiding element'), C.restore.conditions(), C.hide()) : C.is.inward() ? (C.verbose('Animation is outward, showing element'), C.restore.conditions(), C.show()) : (C.verbose('Static animation completed'), C.restore.conditions(), f.onComplete.call(S))); },
                force: { visible() { const n = A.attr('style'); const e = C.get.userStyle(); const i = C.get.displayType(); const a = `${e}display: ${i} !important;`; const o = A.css('display'); const r = n === t || n === ''; o !== i ? (C.verbose('Overriding default display to show element', i), A.attr('style', a)) : r && A.removeAttr('style'); }, hidden() { const n = A.attr('style'); const e = A.css('display'); const i = n === t || n === ''; e === 'none' || C.is.hidden() ? i && A.removeAttr('style') : (C.verbose('Overriding default display to hide element'), A.css('display', 'none')); } },
                has: { direction(e) { let i = !1; return typeof (e = e || f.animation) === 'string' && (e = e.split(' '), n.each(e, function(n, e) { e !== v.inward && e !== v.outward || (i = !0); })), i; }, inlineDisplay() { const e = A.attr('style') || ''; return n.isArray(e.match(/display.*?;/, '')); } },
                set: {
                    animating(n) { let e; C.remove.completeCallback(), n = n || f.animation, e = C.get.animationClass(n), C.save.animation(e), C.force.visible(), C.remove.hidden(), C.remove.direction(), C.start.animation(e); }, duration(n, e) { ((e = typeof (e = e || f.duration) === 'number' ? `${e}ms` : e) || e === 0) && (C.verbose('Setting animation duration', e), A.css({ 'animation-duration': e })); }, direction(n) { (n = n || C.get.direction()) == v.inward ? C.set.inward() : C.set.outward(); }, looping() { C.debug('Transition set to loop'), A.addClass(v.looping); }, hidden() { A.addClass(v.transition).addClass(v.hidden); }, inward() { C.debug('Setting direction to inward'), A.removeClass(v.outward).addClass(v.inward); }, outward() { C.debug('Setting direction to outward'), A.removeClass(v.inward).addClass(v.outward); }, visible() { A.addClass(v.transition).addClass(v.visible); },
                },
                start: { animation(n) { n = n || C.get.animationClass(), C.debug('Starting tween', n), A.addClass(n).one(`${y}.complete${w}`, C.complete), f.useFailSafe && C.add.failSafe(), C.set.duration(f.duration), f.onStart.call(S); } },
                save: { animation(n) { C.cache || (C.cache = {}), C.cache.animation = n; }, displayType(n) { n !== 'none' && A.data(b.displayType, n); }, transitionExists(e, i) { n.fn.transition.exists[e] = i, C.verbose('Saving existence of transition', e, i); } },
                restore: { conditions() { const n = C.get.currentAnimation(); n && (A.removeClass(n), C.verbose('Removing animation class', C.cache)), C.remove.duration(); } },
                add: { failSafe() { const n = C.get.duration(); C.timer = setTimeout(function() { A.triggerHandler(y); }, n + f.failSafeDelay), C.verbose('Adding fail safe timer', C.timer); } },
                remove: {
                    animating() { A.removeClass(v.animating); }, animationCallbacks() { C.remove.queueCallback(), C.remove.completeCallback(); }, queueCallback() { A.off(`.queue${w}`); }, completeCallback() { A.off(`.complete${w}`); }, display() { A.css('display', ''); }, direction() { A.removeClass(v.inward).removeClass(v.outward); }, duration() { A.css('animation-duration', ''); }, failSafe() { C.verbose('Removing fail safe timer', C.timer), C.timer && clearTimeout(C.timer); }, hidden() { A.removeClass(v.hidden); }, visible() { A.removeClass(v.visible); }, looping() { C.debug('Transitions are no longer looping'), C.is.looping() && (C.reset(), A.removeClass(v.looping)); }, transition() { A.removeClass(v.visible).removeClass(v.hidden); },
                },
                get: {
                    settings(e, i, t) { return typeof e === 'object' ? n.extend(!0, {}, n.fn.transition.settings, e) : typeof t === 'function' ? n.extend({}, n.fn.transition.settings, { animation: e, onComplete: t, duration: i }) : typeof i === 'string' || typeof i === 'number' ? n.extend({}, n.fn.transition.settings, { animation: e, duration: i }) : typeof i === 'object' ? n.extend({}, n.fn.transition.settings, i, { animation: e }) : typeof i === 'function' ? n.extend({}, n.fn.transition.settings, { animation: e, onComplete: i }) : n.extend({}, n.fn.transition.settings, { animation: e }); },
                    animationClass(n) { const e = n || f.animation; const i = C.can.transition() && !C.has.direction() ? `${C.get.direction()} ` : ''; return `${v.animating} ${v.transition} ${i}${e}`; },
                    currentAnimation() { return !(!C.cache || C.cache.animation === t) && C.cache.animation; },
                    currentDirection() { return C.is.inward() ? v.inward : v.outward; },
                    direction() { return C.is.hidden() || !C.is.visible() ? v.inward : v.outward; },
                    animationDirection(e) { let i; return typeof (e = e || f.animation) === 'string' && (e = e.split(' '), n.each(e, function(n, e) { e === v.inward ? i = v.inward : e === v.outward && (i = v.outward); })), i || !1; },
                    duration(n) { return !1 === (n = n || f.duration) && (n = A.css('animation-duration') || 0), typeof n === 'string' ? n.indexOf('ms') > -1 ? parseFloat(n) : 1e3 * parseFloat(n) : n; },
                    displayType(n) { return n = n === t || n, f.displayType ? f.displayType : (n && A.data(b.displayType) === t && C.can.transition(!0), A.data(b.displayType)); },
                    userStyle(n) { return (n = n || A.attr('style') || '').replace(/display.*?;/, ''); },
                    transitionExists(e) { return n.fn.transition.exists[e]; },
                    animationStartEvent() {
                        let n; const e = i.createElement('div'); const a = {
                            animation: 'animationstart', OAnimation: 'oAnimationStart', MozAnimation: 'mozAnimationStart', WebkitAnimation: 'webkitAnimationStart',
                        }; for (n in a) if (e.style[n] !== t) return a[n]; return !1;
                    },
                    animationEndEvent() {
                        let n; const e = i.createElement('div'); const a = {
                            animation: 'animationend', OAnimation: 'oAnimationEnd', MozAnimation: 'mozAnimationEnd', WebkitAnimation: 'webkitAnimationEnd',
                        }; for (n in a) if (e.style[n] !== t) return a[n]; return !1;
                    },
                },
                can: {
                    transition(e) {
                        let i; let a; let o; let r; let s; let l; const u = f.animation; const d = C.get.transitionExists(u); let c = C.get.displayType(!1); if (d === t || e) {
                            if (C.verbose('Determining whether animation exists'), i = A.attr('class'), a = A.prop('tagName'), r = (o = n(`<${a} />`).addClass(i).insertAfter(A)).addClass(u).removeClass(v.inward).removeClass(v.outward).addClass(v.animating)
                                .addClass(v.transition)
                                .css('animationName'), s = o.addClass(v.inward).css('animationName'), c || (c = o.attr('class', i).removeAttr('style').removeClass(v.hidden).removeClass(v.visible)
                                .show()
                                .css('display'), C.verbose('Determining final display state', c), C.save.displayType(c)), o.remove(), r != s)C.debug('Direction exists for animation', u), l = !0; else { if (r == 'none' || !r) return void C.debug('No animation defined in css', u); C.debug('Static animation found', u, c), l = !1; }C.save.transitionExists(u, l);
                        } return d !== t ? d : l;
                    },
                    animate() { return C.can.transition() !== t; },
                },
                is: {
                    animating() { return A.hasClass(v.animating); }, inward() { return A.hasClass(v.inward); }, outward() { return A.hasClass(v.outward); }, looping() { return A.hasClass(v.looping); }, occurring(n) { return n = `.${(n = n || f.animation).replace(' ', '.')}`, A.filter(n).length > 0; }, visible() { return A.is(':visible'); }, hidden() { return A.css('visibility') === 'hidden'; }, supported() { return !1 !== y; },
                },
                hide() { C.verbose('Hiding element'), C.is.animating() && C.reset(), S.blur(), C.remove.display(), C.remove.visible(), C.set.hidden(), C.force.hidden(), f.onHide.call(S), f.onComplete.call(S); },
                show(n) { C.verbose('Showing element', n), C.remove.hidden(), C.set.visible(), C.force.visible(), f.onShow.call(S), f.onComplete.call(S); },
                toggle() { C.is.visible() ? C.hide() : C.show(); },
                stop() { C.debug('Stopping current animation'), A.triggerHandler(y); },
                stopAll() { C.debug('Stopping all animation'), C.remove.queueCallback(), A.triggerHandler(y); },
                clear: { queue() { C.debug('Clearing animation queue'), C.remove.queueCallback(); } },
                enable() { C.verbose('Starting animation'), A.removeClass(v.disabled); },
                disable() { C.debug('Stopping animation'), A.addClass(v.disabled); },
                setting(e, i) { if (C.debug('Changing setting', e, i), n.isPlainObject(e))n.extend(!0, f, e); else { if (i === t) return f[e]; n.isPlainObject(f[e]) ? n.extend(!0, f[e], i) : f[e] = i; } },
                internal(e, i) { if (n.isPlainObject(e))n.extend(!0, C, e); else { if (i === t) return C[e]; C[e] = i; } },
                debug() { !f.silent && f.debug && (f.performance ? C.performance.log(arguments) : (C.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), C.debug.apply(console, arguments))); },
                verbose() { !f.silent && f.verbose && f.debug && (f.performance ? C.performance.log(arguments) : (C.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), C.verbose.apply(console, arguments))); },
                error() { f.silent || (C.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), C.error.apply(console, arguments)); },
                performance: {
                    log(n) {
                        let e; let i; f.performance && (i = (e = (new Date()).getTime()) - (s || e), s = e, l.push({
                            Name: n[0], Arguments: [].slice.call(n, 1) || '', Element: S, 'Execution Time': i,
                        })), clearTimeout(C.performance.timer), C.performance.timer = setTimeout(C.performance.display, 500);
                    },
                    display() { let e = `${f.name}:`; let i = 0; s = !1, clearTimeout(C.performance.timer), n.each(l, function(n, e) { i += e['Execution Time']; }), e += ` ${i}ms`, r && (e += ` '${r}'`), o.length > 1 && (e += ` (${o.length})`), (console.group !== t || console.table !== t) && l.length > 0 && (console.groupCollapsed(e), console.table ? console.table(l) : n.each(l, function(n, e) { console.log(`${e.Name}: ${e['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(e, i, o) { let r; let s; let l; let u = p; return i = i || c, o = S || o, typeof e === 'string' && u !== t && (e = e.split(/[\. ]/), r = e.length - 1, n.each(e, function(i, a) { const o = i != r ? a + e[i + 1].charAt(0).toUpperCase() + e[i + 1].slice(1) : e; if (n.isPlainObject(u[o]) && i != r)u = u[o]; else { if (u[o] !== t) return s = u[o], !1; if (!n.isPlainObject(u[a]) || i == r) return u[a] !== t && (s = u[a], !1); u = u[a]; } })), n.isFunction(s) ? l = s.apply(o, i) : s !== t && (l = s), n.isArray(a) ? a.push(l) : a !== t ? a = [a, l] : l !== t && (a = l), s !== t && s; },
            }).initialize();
        }), a !== t ? a : this;
    }, n.fn.transition.exists = {}, n.fn.transition.settings = {
        name: 'Transition',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        namespace: 'transition',
        interval: 0,
        reverse: 'auto',
        onStart() {},
        onComplete() {},
        onShow() {},
        onHide() {},
        useFailSafe: !0,
        failSafeDelay: 100,
        allowRepeats: !1,
        displayType: !1,
        animation: 'fade',
        duration: !1,
        queue: !0,
        metadata: { displayType: 'display' },
        className: {
            animating: 'animating', disabled: 'disabled', hidden: 'hidden', inward: 'in', loading: 'loading', looping: 'looping', outward: 'out', transition: 'transition', visible: 'visible',
        },
        error: {
            noAnimation: 'Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.', repeated: 'That animation is already occurring, cancelling repeated animation', method: 'The method you called is not defined', support: 'This browser does not support CSS animations',
        },
    };
}(jQuery, window, document));
