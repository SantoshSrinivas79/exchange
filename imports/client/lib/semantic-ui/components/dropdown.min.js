!(function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.dropdown = function(a) {
        let o; let s = e(this); const r = e(n); const l = s.selector || ''; const c = 'ontouchstart' in n.documentElement; let u = (new Date()).getTime(); let d = []; const v = arguments[0]; const f = typeof v === 'string'; const m = [].slice.call(arguments, 1); return s.each(function(h) {
            let g; let p; let b; let w; let x; let C; let S; let y; const A = e.isPlainObject(a) ? e.extend(!0, {}, e.fn.dropdown.settings, a) : e.extend({}, e.fn.dropdown.settings); const T = A.className; const k = A.message; const L = A.fields; const I = A.keys; const D = A.metadata; const q = A.namespace; const R = A.regExp; const O = A.selector; const V = A.error; const E = A.templates; const M = `.${q}`; const F = `module-${q}`; let z = e(this); const P = e(A.context); let H = z.find(O.text); let j = z.find(O.search); let N = z.find(O.sizer); let U = z.find(O.input); let K = z.find(O.icon); let W = z.prev().find(O.text).length > 0 ? z.prev().find(O.text) : z.prev(); let B = z.children(O.menu); let $ = B.find(O.item); let Q = !1; let X = !1; let Y = !1; let G = this; let J = z.data(F); y = {
                initialize() { y.debug('Initializing dropdown', A), y.is.alreadySetup() ? y.setup.reference() : (y.setup.layout(), A.values && y.change.values(A.values), y.refreshData(), y.save.defaults(), y.restore.selected(), y.create.id(), y.bind.events(), y.observeChanges(), y.instantiate()); },
                instantiate() { y.verbose('Storing instance of dropdown', y), J = y, z.data(F, y); },
                destroy() { y.verbose('Destroying previous dropdown', z), y.remove.tabbable(), z.off(M).removeData(F), B.off(M), r.off(w), y.disconnect.menuObserver(), y.disconnect.selectObserver(); },
                observeChanges() { 'MutationObserver' in t && (C = new MutationObserver(y.event.select.mutation), S = new MutationObserver(y.event.menu.mutation), y.debug('Setting up mutation observer', C, S), y.observe.select(), y.observe.menu()); },
                disconnect: { menuObserver() { S && S.disconnect(); }, selectObserver() { C && C.disconnect(); } },
                observe: { select() { y.has.input() && C.observe(z[0], { childList: !0, subtree: !0 }); }, menu() { y.has.menu() && S.observe(B[0], { childList: !0, subtree: !0 }); } },
                create: {
                    id() { x = (`${Math.random().toString(16)}000000000`).substr(2, 8), w = `.${x}`, y.verbose('Creating unique id for element', x); },
                    userChoice(t) {
                        let n; let a; let o; return !!(t = t || y.get.userValues()) && (t = e.isArray(t) ? t : [t], e.each(t, function(t, s) {
                            !1 === y.get.item(s) && (o = A.templates.addition(y.add.variables(k.addResult, s)), a = e('<div />').html(o).attr(`data-${D.value}`, s).attr(`data-${D.text}`, s)
                                .addClass(T.addition)
                                .addClass(T.item), A.hideAdditions && a.addClass(T.hidden), n = n === i ? a : n.add(a), y.verbose('Creating user choices for value', s, a));
                        }), n);
                    },
                    userLabels(t) { const n = y.get.userValues(); n && (y.debug('Adding user labels', n), e.each(n, function(e, t) { y.verbose('Adding custom user value'), y.add.label(t, t); })); },
                    menu() { B = e('<div />').addClass(T.menu).appendTo(z); },
                    sizer() { N = e('<span />').addClass(T.sizer).insertAfter(j); },
                },
                search(e) { e = e !== i ? e : y.get.query(), y.verbose('Searching for query', e), y.has.minCharacters(e) ? y.filter(e) : y.hide(); },
                select: { firstUnfiltered() { y.verbose('Selecting first non-filtered element'), y.remove.selectedItem(), $.not(O.unselectable).not(O.addition + O.hidden).eq(0).addClass(T.selected); }, nextAvailable(e) { const t = (e = e.eq(0)).nextAll(O.item).not(O.unselectable).eq(0); const n = e.prevAll(O.item).not(O.unselectable).eq(0); t.length > 0 ? (y.verbose('Moving selection to', t), t.addClass(T.selected)) : (y.verbose('Moving selection to', n), n.addClass(T.selected)); } },
                setup: {
                    api() { const e = { debug: A.debug, urlData: { value: y.get.value(), query: y.get.query() }, on: !1 }; y.verbose('First request, initializing API'), z.api(e); },
                    layout() { z.is('select') && (y.setup.select(), y.setup.returnedObject()), y.has.menu() || y.create.menu(), y.is.search() && !y.has.search() && (y.verbose('Adding search input'), j = e('<input />').addClass(T.search).prop('autocomplete', 'off').insertBefore(H)), y.is.multiple() && y.is.searchSelection() && !y.has.sizer() && y.create.sizer(), A.allowTab && y.set.tabbable(); },
                    select() {
                        const t = y.get.selectValues(); y.debug('Dropdown initialized on a select', t), z.is('select') && (U = z), U.parent(O.dropdown).length > 0 ? (y.debug('UI dropdown already exists. Creating dropdown menu only'), z = U.closest(O.dropdown), y.has.menu() || y.create.menu(), B = z.children(O.menu), y.setup.menu(t)) : (y.debug('Creating entire dropdown from select'), z = e('<div />').attr('class', U.attr('class')).addClass(T.selection).addClass(T.dropdown)
                            .html(E.dropdown(t))
                            .insertBefore(U), U.hasClass(T.multiple) && !1 === U.prop('multiple') && (y.error(V.missingMultiple), U.prop('multiple', !0)), U.is('[multiple]') && y.set.multiple(), U.prop('disabled') && (y.debug('Disabling dropdown'), z.addClass(T.disabled)), U.removeAttr('class').detach().prependTo(z)), y.refresh();
                    },
                    menu(e) { B.html(E.menu(e, L)), $ = B.find(O.item); },
                    reference() { y.debug('Dropdown behavior was called on select, replacing with closest dropdown'), z = z.parent(O.dropdown), J = z.data(F), G = z.get(0), y.refresh(), y.setup.returnedObject(); },
                    returnedObject() { const e = s.slice(0, h); const t = s.slice(h + 1); s = e.add(z).add(t); },
                },
                refresh() { y.refreshSelectors(), y.refreshData(); },
                refreshItems() { $ = B.find(O.item); },
                refreshSelectors() { y.verbose('Refreshing selector cache'), H = z.find(O.text), j = z.find(O.search), U = z.find(O.input), K = z.find(O.icon), W = z.prev().find(O.text).length > 0 ? z.prev().find(O.text) : z.prev(), B = z.children(O.menu), $ = B.find(O.item); },
                refreshData() { y.verbose('Refreshing cached metadata'), $.removeData(D.text).removeData(D.value); },
                clearData() { y.verbose('Clearing metadata'), $.removeData(D.text).removeData(D.value), z.removeData(D.defaultText).removeData(D.defaultValue).removeData(D.placeholderText); },
                toggle() { y.verbose('Toggling menu visibility'), y.is.active() ? y.hide() : y.show(); },
                show(t) { if (t = e.isFunction(t) ? t : function() {}, !y.can.show() && y.is.remote() && (y.debug('No API results retrieved, searching before show'), y.queryRemote(y.get.query(), y.show)), y.can.show() && !y.is.active()) { if (y.debug('Showing dropdown'), !y.has.message() || y.has.maxSelections() || y.has.allResultsFiltered() || y.remove.message(), y.is.allFiltered()) return !0; !1 !== A.onShow.call(G) && y.animate.show(function() { y.can.click() && y.bind.intent(), y.has.menuSearch() && y.focusSearch(), y.set.visible(), t.call(G); }); } },
                hide(t) { t = e.isFunction(t) ? t : function() {}, y.is.active() && !y.is.animatingOutward() && (y.debug('Hiding dropdown'), !1 !== A.onHide.call(G) && y.animate.hide(function() { y.remove.visible(), t.call(G); })); },
                hideOthers() { y.verbose('Finding other dropdowns to hide'), s.not(z).has(`${O.menu}.${T.visible}`).dropdown('hide'); },
                hideMenu() { y.verbose('Hiding menu  instantaneously'), y.remove.active(), y.remove.visible(), B.transition('hide'); },
                hideSubMenus() { const e = B.children(O.item).find(O.menu); y.verbose('Hiding sub menus', e), e.transition('hide'); },
                bind: {
                    events() { c && y.bind.touchEvents(), y.bind.keyboardEvents(), y.bind.inputEvents(), y.bind.mouseEvents(); },
                    touchEvents() { y.debug('Touch device detected binding additional touch events'), y.is.searchSelection() || y.is.single() && z.on(`touchstart${M}`, y.event.test.toggle), B.on(`touchstart${M}`, O.item, y.event.item.mouseenter); },
                    keyboardEvents() { y.verbose('Binding keyboard events'), z.on(`keydown${M}`, y.event.keydown), y.has.search() && z.on(y.get.inputEvent() + M, O.search, y.event.input), y.is.multiple() && r.on(`keydown${w}`, y.event.document.keydown); },
                    inputEvents() { y.verbose('Binding input change events'), z.on(`change${M}`, O.input, y.event.change); },
                    mouseEvents() {
                        y.verbose('Binding mouse events'), y.is.multiple() && z.on(`click${M}`, O.label, y.event.label.click).on(`click${M}`, O.remove, y.event.remove.click), y.is.searchSelection() ? (z.on(`mousedown${M}`, y.event.mousedown).on(`mouseup${M}`, y.event.mouseup).on(`mousedown${M}`, O.menu, y.event.menu.mousedown).on(`mouseup${M}`, O.menu, y.event.menu.mouseup)
                            .on(`click${M}`, O.icon, y.event.icon.click)
                            .on(`focus${M}`, O.search, y.event.search.focus)
                            .on(`click${M}`, O.search, y.event.search.focus)
                            .on(`blur${M}`, O.search, y.event.search.blur)
                            .on(`click${M}`, O.text, y.event.text.focus), y.is.multiple() && z.on(`click${M}`, y.event.click)) : (A.on == 'click' ? z.on(`click${M}`, O.icon, y.event.icon.click).on(`click${M}`, y.event.test.toggle) : A.on == 'hover' ? z.on(`mouseenter${M}`, y.delay.show).on(`mouseleave${M}`, y.delay.hide) : z.on(A.on + M, y.toggle), z.on(`mousedown${M}`, y.event.mousedown).on(`mouseup${M}`, y.event.mouseup).on(`focus${M}`, y.event.focus), y.has.menuSearch() ? z.on(`blur${M}`, O.search, y.event.search.blur) : z.on(`blur${M}`, y.event.blur)), B.on(`mouseenter${M}`, O.item, y.event.item.mouseenter).on(`mouseleave${M}`, O.item, y.event.item.mouseleave).on(`click${M}`, O.item, y.event.item.click);
                    },
                    intent() { y.verbose('Binding hide intent event to document'), c && r.on(`touchstart${w}`, y.event.test.touch).on(`touchmove${w}`, y.event.test.touch), r.on(`click${w}`, y.event.test.hide); },
                },
                unbind: { intent() { y.verbose('Removing hide intent event from document'), c && r.off(`touchstart${w}`).off(`touchmove${w}`), r.off(`click${w}`); } },
                filter(e) { const t = e !== i ? e : y.get.query(); const n = function() { y.is.multiple() && y.filterActive(), (e || !e && y.get.activeItem().length == 0) && y.select.firstUnfiltered(), y.has.allResultsFiltered() ? A.onNoResults.call(G, t) ? A.allowAdditions ? A.hideAdditions && (y.verbose('User addition with no menu, setting empty style'), y.set.empty(), y.hideMenu()) : (y.verbose('All items filtered, showing message', t), y.add.message(k.noResults)) : (y.verbose('All items filtered, hiding dropdown', t), y.hideMenu()) : (y.remove.empty(), y.remove.message()), A.allowAdditions && y.add.userSuggestion(e), y.is.searchSelection() && y.can.show() && y.is.focusedOnSearch() && y.show(); }; A.useLabels && y.has.maxSelections() || (A.apiSettings ? y.can.useAPI() ? y.queryRemote(t, function() { A.filterRemoteData && y.filterItems(t), n(); }) : y.error(V.noAPI) : (y.filterItems(t), n())); },
                queryRemote(t, n) {
                    let i = {
                        errorDuration: !1, cache: 'local', throttle: A.throttle, urlData: { query: t }, onError() { y.add.message(k.serverError), n(); }, onFailure() { y.add.message(k.serverError), n(); }, onSuccess(e) { y.remove.message(), y.setup.menu({ values: e[L.remoteValues] }), n(); },
                    }; z.api('get request') || y.setup.api(), i = e.extend(!0, {}, i, A.apiSettings), z.api('setting', i).api('query');
                },
                filterItems(t) { const n = t !== i ? t : y.get.query(); let a = null; const o = y.escape.string(n); const s = new RegExp(`^${o}`, 'igm'); y.has.query() && (a = [], y.verbose('Searching for matching values', n), $.each(function() { let t; let i; const o = e(this); if (A.match == 'both' || A.match == 'text') { if ((t = String(y.get.choiceText(o, !1))).search(s) !== -1) return a.push(this), !0; if (A.fullTextSearch === 'exact' && y.exactSearch(n, t)) return a.push(this), !0; if (!0 === A.fullTextSearch && y.fuzzySearch(n, t)) return a.push(this), !0; } if (A.match == 'both' || A.match == 'value') { if ((i = String(y.get.choiceValue(o, t))).search(s) !== -1) return a.push(this), !0; if (A.fullTextSearch === 'exact' && y.exactSearch(n, i)) return a.push(this), !0; if (!0 === A.fullTextSearch && y.fuzzySearch(n, i)) return a.push(this), !0; } })), y.debug('Showing only matched items', n), y.remove.filteredItem(), a && $.not(a).addClass(T.filtered); },
                fuzzySearch(e, t) { const n = t.length; const i = e.length; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let a = 0, o = 0; a < i; a++) { for (let s = e.charCodeAt(a); o < n;) if (t.charCodeAt(o++) === s) continue e; return !1; } return !0; },
                exactSearch(e, t) { return e = e.toLowerCase(), (t = t.toLowerCase()).indexOf(e) > -1; },
                filterActive() { A.useLabels && $.filter(`.${T.active}`).addClass(T.filtered); },
                focusSearch(e) { y.has.search() && !y.is.focusedOnSearch() && (e ? (z.off(`focus${M}`, O.search), j.focus(), z.on(`focus${M}`, O.search, y.event.search.focus)) : j.focus()); },
                forceSelection() { const e = $.not(T.filtered).filter(`.${T.selected}`).eq(0); const t = $.not(T.filtered).filter(`.${T.active}`).eq(0); const n = e.length > 0 ? e : t; if (n.length > 0 && !y.is.multiple()) return y.debug('Forcing partial selection to selected item', n), void y.event.item.click.call(n, {}, !0); A.allowAdditions ? (y.set.selected(y.get.query()), y.remove.searchTerm()) : y.remove.searchTerm(); },
                change: { values(t) { A.allowAdditions || y.clear(), y.debug('Creating dropdown with specified values', t), y.setup.menu({ values: t }), e.each(t, function(e, t) { if (t.selected == 1) return y.debug('Setting initial selection to', t.value), y.set.selected(t.value), !0; }); } },
                event: {
                    change() { Y || (y.debug('Input changed, updating selection'), y.set.selected()); }, focus() { A.showOnFocus && !Q && y.is.hidden() && !p && y.show(); }, blur(e) { p = n.activeElement === this, Q || p || (y.remove.activeLabel(), y.hide()); }, mousedown() { y.is.searchSelection() ? b = !0 : Q = !0; }, mouseup() { y.is.searchSelection() ? b = !1 : Q = !1; }, click(t) { e(t.target).is(z) && (y.is.focusedOnSearch() ? y.show() : y.focusSearch()); }, search: { focus() { Q = !0, y.is.multiple() && y.remove.activeLabel(), A.showOnFocus && y.search(); }, blur(e) { p = n.activeElement === this, y.is.searchSelection() && !b && (X || p || (A.forceSelection && y.forceSelection(), y.hide())), b = !1; } }, icon: { click(e) { y.toggle(); } }, text: { focus(e) { Q = !0, y.focusSearch(); } }, input(e) { (y.is.multiple() || y.is.searchSelection()) && y.set.filtered(), clearTimeout(y.timer), y.timer = setTimeout(y.search, A.delay.search); }, label: { click(t) { const n = e(this); const i = z.find(O.label); const a = i.filter(`.${T.active}`); const o = n.nextAll(`.${T.active}`); const s = n.prevAll(`.${T.active}`); const r = o.length > 0 ? n.nextUntil(o).add(a).add(n) : n.prevUntil(s).add(a).add(n); t.shiftKey ? (a.removeClass(T.active), r.addClass(T.active)) : t.ctrlKey ? n.toggleClass(T.active) : (a.removeClass(T.active), n.addClass(T.active)), A.onLabelSelect.apply(this, i.filter(`.${T.active}`)); } }, remove: { click() { const t = e(this).parent(); t.hasClass(T.active) ? y.remove.activeLabels() : y.remove.activeLabels(t); } }, test: { toggle(e) { const t = y.is.multiple() ? y.show : y.toggle; y.is.bubbledLabelClick(e) || y.is.bubbledIconClick(e) || y.determine.eventOnElement(e, t) && e.preventDefault(); }, touch(e) { y.determine.eventOnElement(e, function() { e.type == 'touchstart' ? y.timer = setTimeout(function() { y.hide(); }, A.delay.touch) : e.type == 'touchmove' && clearTimeout(y.timer); }), e.stopPropagation(); }, hide(e) { y.determine.eventInModule(e, y.hide); } }, select: { mutation(t) { y.debug('<select> modified, recreating menu'); let n = !1; e.each(t, function(t, i) { if (e(i.target).is('select') || e(i.addedNodes).is('select')) return n = !0, !0; }), n && (y.disconnect.selectObserver(), y.refresh(), y.setup.select(), y.set.selected(), y.observe.select()); } }, menu: { mutation(t) { const n = t[0]; const i = n.addedNodes ? e(n.addedNodes[0]) : e(!1); const a = n.removedNodes ? e(n.removedNodes[0]) : e(!1); const o = i.add(a); const s = o.is(O.addition) || o.closest(O.addition).length > 0; const r = o.is(O.message) || o.closest(O.message).length > 0; s || r ? (y.debug('Updating item selector cache'), y.refreshItems()) : (y.debug('Menu modified, updating selector cache'), y.refresh()); }, mousedown() { X = !0; }, mouseup() { X = !1; } }, item: { mouseenter(t) { const n = e(t.target); const i = e(this); const a = i.children(O.menu); const o = i.siblings(O.item).children(O.menu); const s = a.length > 0; !(a.find(n).length > 0) && s && (clearTimeout(y.itemTimer), y.itemTimer = setTimeout(function() { y.verbose('Showing sub-menu', a), e.each(o, function() { y.animate.hide(!1, e(this)); }), y.animate.show(!1, a); }, A.delay.show), t.preventDefault()); }, mouseleave(t) { const n = e(this).children(O.menu); n.length > 0 && (clearTimeout(y.itemTimer), y.itemTimer = setTimeout(function() { y.verbose('Hiding sub-menu', n), y.animate.hide(!1, n); }, A.delay.hide)); }, click(t, i) { const a = e(this); const o = e(t ? t.target : ''); const s = a.find(O.menu); const r = y.get.choiceText(a); const l = y.get.choiceValue(a, r); const c = s.length > 0; const u = s.find(o).length > 0; y.has.menuSearch() && e(n.activeElement).blur(), u || c && !A.allowCategorySelection || (y.is.searchSelection() && (A.allowAdditions && y.remove.userAddition(), y.remove.searchTerm(), y.is.focusedOnSearch() || i == 1 || y.focusSearch(!0)), A.useLabels || (y.remove.filteredItem(), y.set.scrollPosition(a)), y.determine.selectAction.call(this, r, l)); } }, document: { keydown(e) { const t = e.which; if (y.is.inObject(t, I)) { const n = z.find(O.label); let i = n.filter(`.${T.active}`); const a = (i.data(D.value), n.index(i)); const o = n.length; const s = i.length > 0; const r = i.length > 1; const l = a === 0; const c = a + 1 == o; const u = y.is.searchSelection(); const d = y.is.focusedOnSearch(); const v = y.is.focused(); const f = d && y.get.caretPosition() === 0; if (u && !s && !d) return; t == I.leftArrow ? !v && !f || s ? s && (e.shiftKey ? y.verbose('Adding previous label to selection') : (y.verbose('Selecting previous label'), n.removeClass(T.active)), l && !r ? i.addClass(T.active) : i.prev(O.siblingLabel).addClass(T.active).end(), e.preventDefault()) : (y.verbose('Selecting previous label'), n.last().addClass(T.active)) : t == I.rightArrow ? (v && !s && n.first().addClass(T.active), s && (e.shiftKey ? y.verbose('Adding next label to selection') : (y.verbose('Selecting next label'), n.removeClass(T.active)), c ? u ? d ? n.removeClass(T.active) : y.focusSearch() : r ? i.next(O.siblingLabel).addClass(T.active) : i.addClass(T.active) : i.next(O.siblingLabel).addClass(T.active), e.preventDefault())) : t == I.deleteKey || t == I.backspace ? s ? (y.verbose('Removing active labels'), c && u && !d && y.focusSearch(), i.last().next(O.siblingLabel).addClass(T.active), y.remove.activeLabels(i), e.preventDefault()) : f && !s && t == I.backspace && (y.verbose('Removing last label on input backspace'), i = n.last().addClass(T.active), y.remove.activeLabels(i)) : i.removeClass(T.active); } } }, keydown(e) { let t = e.which; if (y.is.inObject(t, I)) { let n; const i = $.not(O.unselectable).filter(`.${T.selected}`).eq(0); const a = B.children(`.${T.active}`).eq(0); const o = i.length > 0 ? i : a; const s = o.length > 0 ? o.siblings(`:not(.${T.filtered})`).addBack() : B.children(`:not(.${T.filtered})`); const r = o.children(O.menu); const l = o.closest(O.menu); const c = l.hasClass(T.visible) || l.hasClass(T.animating) || l.parent(O.menu).length > 0; const u = r.length > 0; const d = o.length > 0; const v = o.not(O.unselectable).length > 0; const f = t == I.delimiter && A.allowAdditions && y.is.multiple(); if (A.allowAdditions && A.hideAdditions && (t == I.enter || f) && v && (y.verbose('Selecting item from keyboard shortcut', o), y.event.item.click.call(o, e), y.is.searchSelection() && y.remove.searchTerm()), y.is.visible()) { if ((t == I.enter || f) && (t == I.enter && d && u && !A.allowCategorySelection ? (y.verbose('Pressed enter on unselectable category, opening sub menu'), t = I.rightArrow) : v && (y.verbose('Selecting item from keyboard shortcut', o), y.event.item.click.call(o, e), y.is.searchSelection() && y.remove.searchTerm()), e.preventDefault()), d && (t == I.leftArrow && l[0] !== B[0] && (y.verbose('Left key pressed, closing sub-menu'), y.animate.hide(!1, l), o.removeClass(T.selected), l.closest(O.item).addClass(T.selected), e.preventDefault()), t == I.rightArrow && u && (y.verbose('Right key pressed, opening sub-menu'), y.animate.show(!1, r), o.removeClass(T.selected), r.find(O.item).eq(0).addClass(T.selected), e.preventDefault())), t == I.upArrow) { if (n = d && c ? o.prevAll(`${O.item}:not(${O.unselectable})`).eq(0) : $.eq(0), s.index(n) < 0) return y.verbose('Up key pressed but reached top of current menu'), void e.preventDefault(); y.verbose('Up key pressed, changing active item'), o.removeClass(T.selected), n.addClass(T.selected), y.set.scrollPosition(n), A.selectOnKeydown && y.is.single() && y.set.selectedItem(n), e.preventDefault(); } if (t == I.downArrow) { if ((n = d && c ? n = o.nextAll(`${O.item}:not(${O.unselectable})`).eq(0) : $.eq(0)).length === 0) return y.verbose('Down key pressed but reached bottom of current menu'), void e.preventDefault(); y.verbose('Down key pressed, changing active item'), $.removeClass(T.selected), n.addClass(T.selected), y.set.scrollPosition(n), A.selectOnKeydown && y.is.single() && y.set.selectedItem(n), e.preventDefault(); }t == I.pageUp && (y.scrollPage('up'), e.preventDefault()), t == I.pageDown && (y.scrollPage('down'), e.preventDefault()), t == I.escape && (y.verbose('Escape key pressed, closing dropdown'), y.hide()); } else f && e.preventDefault(), t != I.downArrow || y.is.visible() || (y.verbose('Down key pressed, showing dropdown'), y.show(), e.preventDefault()); } else y.has.search() || y.set.selectedLetter(String.fromCharCode(t)); },
                },
                trigger: { change() { const e = n.createEvent('HTMLEvents'); const t = U[0]; t && (y.verbose('Triggering native change event'), e.initEvent('change', !0, !1), t.dispatchEvent(e)); } },
                determine: { selectAction(t, n) { y.verbose('Determining action', A.action), e.isFunction(y.action[A.action]) ? (y.verbose('Triggering preset action', A.action, t, n), y.action[A.action].call(G, t, n, this)) : e.isFunction(A.action) ? (y.verbose('Triggering user action', A.action, t, n), A.action.call(G, t, n, this)) : y.error(V.action, A.action); }, eventInModule(t, i) { const a = e(t.target); const o = a.closest(n.documentElement).length > 0; const s = a.closest(z).length > 0; return i = e.isFunction(i) ? i : function() {}, o && !s ? (y.verbose('Triggering event', i), i(), !0) : (y.verbose('Event occurred in dropdown, canceling callback'), !1); }, eventOnElement(t, i) { const a = e(t.target); const o = a.closest(O.siblingLabel); const s = n.body.contains(t.target); const r = z.find(o).length === 0; const l = a.closest(B).length === 0; return i = e.isFunction(i) ? i : function() {}, s && r && l ? (y.verbose('Triggering event', i), i(), !0) : (y.verbose('Event occurred in dropdown menu, canceling callback'), !1); } },
                action: {
                    nothing() {}, activate(t, n, a) { if (n = n !== i ? n : t, y.can.activate(e(a))) { if (y.set.selected(n, e(a)), y.is.multiple() && !y.is.allFiltered()) return; y.hideAndClear(); } }, select(t, n, a) { if (n = n !== i ? n : t, y.can.activate(e(a))) { if (y.set.value(n, e(a)), y.is.multiple() && !y.is.allFiltered()) return; y.hideAndClear(); } }, combo(t, n, a) { n = n !== i ? n : t, y.set.selected(n, e(a)), y.hideAndClear(); }, hide(e, t, n) { y.set.value(t, e), y.hideAndClear(); },
                },
                get: {
                    id() { return x; }, defaultText() { return z.data(D.defaultText); }, defaultValue() { return z.data(D.defaultValue); }, placeholderText() { return A.placeholder != 'auto' && typeof A.placeholder === 'string' ? A.placeholder : z.data(D.placeholderText) || ''; }, text() { return H.text(); }, query() { return e.trim(j.val()); }, searchWidth(e) { return e = e !== i ? e : j.val(), N.text(e), Math.ceil(N.width() + 1); }, selectionCount() { const t = y.get.values(); return y.is.multiple() ? e.isArray(t) ? t.length : 0 : y.get.value() !== '' ? 1 : 0; }, transition(e) { return A.transition == 'auto' ? y.is.upward(e) ? 'slide up' : 'slide down' : A.transition; }, userValues() { let t = y.get.values(); return !!t && (t = e.isArray(t) ? t : [t], e.grep(t, function(e) { return !1 === y.get.item(e); })); }, uniqueArray(t) { return e.grep(t, function(n, i) { return e.inArray(n, t) === i; }); }, caretPosition() { let e; let t; const i = j.get(0); return 'selectionStart' in i ? i.selectionStart : n.selection ? (i.focus(), t = (e = n.selection.createRange()).text.length, e.moveStart('character', -i.value.length), e.text.length - t) : void 0; }, value() { const t = U.length > 0 ? U.val() : z.data(D.value); const n = e.isArray(t) && t.length === 1 && t[0] === ''; return t === i || n ? '' : t; }, values() { const e = y.get.value(); return e === '' ? '' : !y.has.selectInput() && y.is.multiple() ? typeof e === 'string' ? e.split(A.delimiter) : '' : e; }, remoteValues() { let t = y.get.values(); let n = !1; return t && (typeof t === 'string' && (t = [t]), e.each(t, function(e, t) { const i = y.read.remoteData(t); y.verbose('Restoring value from session data', i, t), i && (n || (n = {}), n[t] = i); })), n; }, choiceText(t, n) { if (n = n !== i ? n : A.preserveHTML, t) return t.find(O.menu).length > 0 && (y.verbose('Retrieving text of element with sub-menu'), (t = t.clone()).find(O.menu).remove(), t.find(O.menuIcon).remove()), t.data(D.text) !== i ? t.data(D.text) : n ? e.trim(t.html()) : e.trim(t.text()); }, choiceValue(t, n) { return n = n || y.get.choiceText(t), !!t && (t.data(D.value) !== i ? String(t.data(D.value)) : typeof n === 'string' ? e.trim(n.toLowerCase()) : String(n)); }, inputEvent() { const e = j[0]; return !!e && (e.oninput !== i ? 'input' : e.onpropertychange !== i ? 'propertychange' : 'keyup'); }, selectValues() { const t = { values: [] }; return z.find('option').each(function() { const n = e(this); const a = n.html(); const o = n.attr('disabled'); const s = n.attr('value') !== i ? n.attr('value') : a; A.placeholder === 'auto' && s === '' ? t.placeholder = a : t.values.push({ name: a, value: s, disabled: o }); }), A.placeholder && A.placeholder !== 'auto' && (y.debug('Setting placeholder value to', A.placeholder), t.placeholder = A.placeholder), A.sortSelect ? (t.values.sort(function(e, t) { return e.name > t.name ? 1 : -1; }), y.debug('Retrieved and sorted values from select', t)) : y.debug('Retrieved values from select', t), t; }, activeItem() { return $.filter(`.${T.active}`); }, selectedItem() { const e = $.not(O.unselectable).filter(`.${T.selected}`); return e.length > 0 ? e : $.eq(0); }, itemWithAdditions(e) { let t = y.get.item(e); const n = y.create.userChoice(e); return n && n.length > 0 && (t = t.length > 0 ? t.add(n) : n), t; }, item(t, n) { let a; let o; let s = !1; return t = t !== i ? t : y.get.values() !== i ? y.get.values() : y.get.text(), a = o ? t.length > 0 : t !== i && t !== null, o = y.is.multiple() && e.isArray(t), n = t === '' || t === 0 || (n || !1), a && $.each(function() { const a = e(this); const r = y.get.choiceText(a); const l = y.get.choiceValue(a, r); if (l !== null && l !== i) if (o)e.inArray(String(l), t) === -1 && e.inArray(r, t) === -1 || (s = s ? s.add(a) : a); else if (n) { if (y.verbose('Ambiguous dropdown value using strict type check', a, t), l === t || r === t) return s = a, !0; } else if (String(l) == String(t) || r == t) return y.verbose('Found select item by value', l, t), s = a, !0; }), s; },
                },
                check: { maxSelections(e) { return !A.maxSelections || ((e = e !== i ? e : y.get.selectionCount()) >= A.maxSelections ? (y.debug('Maximum selection count reached'), A.useLabels && ($.addClass(T.filtered), y.add.message(k.maxSelections)), !0) : (y.verbose('No longer at maximum selection count'), y.remove.message(), y.remove.filteredItem(), y.is.searchSelection() && y.filterItems(), !1)); } },
                restore: {
                    defaults() { y.clear(), y.restore.defaultText(), y.restore.defaultValue(); }, defaultText() { const e = y.get.defaultText(); e === y.get.placeholderText ? (y.debug('Restoring default placeholder text', e), y.set.placeholderText(e)) : (y.debug('Restoring default text', e), y.set.text(e)); }, placeholderText() { y.set.placeholderText(); }, defaultValue() { const e = y.get.defaultValue(); e !== i && (y.debug('Restoring default value', e), e !== '' ? (y.set.value(e), y.set.selected()) : (y.remove.activeItem(), y.remove.selectedItem())); }, labels() { A.allowAdditions && (A.useLabels || (y.error(V.labels), A.useLabels = !0), y.debug('Restoring selected values'), y.create.userLabels()), y.check.maxSelections(); }, selected() { y.restore.values(), y.is.multiple() ? (y.debug('Restoring previously selected values and labels'), y.restore.labels()) : y.debug('Restoring previously selected values'); }, values() { y.set.initialLoad(), A.apiSettings && A.saveRemoteData && y.get.remoteValues() ? y.restore.remoteValues() : y.set.selected(), y.remove.initialLoad(); }, remoteValues() { const t = y.get.remoteValues(); y.debug('Recreating selected from session data', t), t && (y.is.single() ? e.each(t, function(e, t) { y.set.text(t); }) : e.each(t, function(e, t) { y.add.label(e, t); })); },
                },
                read: { remoteData(e) { let n; if (t.Storage !== i) return (n = sessionStorage.getItem(e)) !== i && n; y.error(V.noStorage); } },
                save: {
                    defaults() { y.save.defaultText(), y.save.placeholderText(), y.save.defaultValue(); }, defaultValue() { const e = y.get.value(); y.verbose('Saving default value as', e), z.data(D.defaultValue, e); }, defaultText() { const e = y.get.text(); y.verbose('Saving default text as', e), z.data(D.defaultText, e); }, placeholderText() { let e; !1 !== A.placeholder && H.hasClass(T.placeholder) && (e = y.get.text(), y.verbose('Saving placeholder text as', e), z.data(D.placeholderText, e)); }, remoteData(e, n) { t.Storage !== i ? (y.verbose('Saving remote data to session storage', n, e), sessionStorage.setItem(n, e)) : y.error(V.noStorage); },
                },
                clear() { y.is.multiple() && A.useLabels ? y.remove.labels() : (y.remove.activeItem(), y.remove.selectedItem()), y.set.placeholderText(), y.clearValue(); },
                clearValue() { y.set.value(''); },
                scrollPage(e, t) { let n; let i; const a = t || y.get.selectedItem(); const o = a.closest(O.menu); const s = o.outerHeight(); const r = o.scrollTop(); const l = $.eq(0).outerHeight(); const c = Math.floor(s / l); const u = (o.prop('scrollHeight'), e == 'up' ? r - l * c : r + l * c); const d = $.not(O.unselectable); i = e == 'up' ? d.index(a) - c : d.index(a) + c, (n = (e == 'up' ? i >= 0 : i < d.length) ? d.eq(i) : e == 'up' ? d.first() : d.last()).length > 0 && (y.debug('Scrolling page', e, n), a.removeClass(T.selected), n.addClass(T.selected), A.selectOnKeydown && y.is.single() && y.set.selectedItem(n), o.scrollTop(u)); },
                set: {
                    filtered() { const e = y.is.multiple(); const t = y.is.searchSelection(); const n = e && t; const i = t ? y.get.query() : ''; const a = typeof i === 'string' && i.length > 0; const o = y.get.searchWidth(); const s = i !== ''; e && a && (y.verbose('Adjusting input width', o, A.glyphWidth), j.css('width', o)), a || n && s ? (y.verbose('Hiding placeholder text'), H.addClass(T.filtered)) : (!e || n && !s) && (y.verbose('Showing placeholder text'), H.removeClass(T.filtered)); }, empty() { z.addClass(T.empty); }, loading() { z.addClass(T.loading); }, placeholderText(e) { e = e || y.get.placeholderText(), y.debug('Setting placeholder text', e), y.set.text(e), H.addClass(T.placeholder); }, tabbable() { y.is.searchSelection() ? (y.debug('Added tabindex to searchable dropdown'), j.val('').attr('tabindex', 0), B.attr('tabindex', -1)) : (y.debug('Added tabindex to dropdown'), z.attr('tabindex') === i && (z.attr('tabindex', 0), B.attr('tabindex', -1))); }, initialLoad() { y.verbose('Setting initial load'), g = !0; }, activeItem(e) { A.allowAdditions && e.filter(O.addition).length > 0 ? e.addClass(T.filtered) : e.addClass(T.active); }, partialSearch(e) { const t = y.get.query().length; j.val(e.substr(0, t)); }, scrollPosition(e, t) { let n; let a; let o; let s; let r; let l; n = (e = e || y.get.selectedItem()).closest(O.menu), a = e && e.length > 0, t = t !== i && t, e && n.length > 0 && a && (e.position().top, n.addClass(T.loading), o = (s = n.scrollTop()) - n.offset().top + e.offset().top, t || (l = s + n.height() < o + 5, r = o - 5 < s), y.debug('Scrolling to active item', o), (t || r || l) && n.scrollTop(o), n.removeClass(T.loading)); }, text(e) { A.action !== 'select' && (A.action == 'combo' ? (y.debug('Changing combo button text', e, W), A.preserveHTML ? W.html(e) : W.text(e)) : (e !== y.get.placeholderText() && H.removeClass(T.placeholder), y.debug('Changing text', e, H), H.removeClass(T.filtered), A.preserveHTML ? H.html(e) : H.text(e))); }, selectedItem(e) { const t = y.get.choiceValue(e); const n = y.get.choiceText(e, !1); const i = y.get.choiceText(e, !0); y.debug('Setting user selection to item', e), y.remove.activeItem(), y.set.partialSearch(n), y.set.activeItem(e), y.set.selected(t, e), y.set.text(i); }, selectedLetter(t) { let n; const i = $.filter(`.${T.selected}`); let a = !1; i.length > 0 && y.has.firstLetter(i, t) && (n = i.nextAll($).eq(0), y.has.firstLetter(n, t) && (a = n)), a || $.each(function() { if (y.has.firstLetter(e(this), t)) return a = e(this), !1; }), a && (y.verbose('Scrolling to next value with letter', t), y.set.scrollPosition(a), i.removeClass(T.selected), a.addClass(T.selected), A.selectOnKeydown && y.is.single() && y.set.selectedItem(a)); }, direction(e) { A.direction == 'auto' ? (y.remove.upward(), y.can.openDownward(e) ? y.remove.upward(e) : y.set.upward(e), y.is.leftward(e) || y.can.openRightward(e) || y.set.leftward(e)) : A.direction == 'upward' && y.set.upward(e); }, upward(e) { (e || z).addClass(T.upward); }, leftward(e) { (e || B).addClass(T.leftward); }, value(e, t, n) { const a = y.escape.value(e); const o = U.length > 0; const s = y.get.values(); const r = e !== i ? String(e) : e; if (o) { if (!A.allowReselection && r == s && (y.verbose('Skipping value update already same value', e, s), !y.is.initialLoad())) return; y.is.single() && y.has.selectInput() && y.can.extendSelect() && (y.debug('Adding user option', e), y.add.optionValue(e)), y.debug('Updating input value', a, s), Y = !0, U.val(a), !1 === A.fireOnInit && y.is.initialLoad() ? y.debug('Input native change event ignored on initial load') : y.trigger.change(), Y = !1; } else y.verbose('Storing value in metadata', a, U), a !== s && z.data(D.value, r); !1 === A.fireOnInit && y.is.initialLoad() ? y.verbose('No callback on initial load', A.onChange) : A.onChange.call(G, e, t, n); }, active() { z.addClass(T.active); }, multiple() { z.addClass(T.multiple); }, visible() { z.addClass(T.visible); }, exactly(e, t) { y.debug('Setting selected to exact values'), y.clear(), y.set.selected(e, t); }, selected(t, n) { const i = y.is.multiple(); (n = A.allowAdditions ? n || y.get.itemWithAdditions(t) : n || y.get.item(t)) && (y.debug('Setting selected menu item to', n), y.is.multiple() && y.remove.searchWidth(), y.is.single() ? (y.remove.activeItem(), y.remove.selectedItem()) : A.useLabels && y.remove.selectedItem(), n.each(function() { const t = e(this); const a = y.get.choiceText(t); const o = y.get.choiceValue(t, a); const s = t.hasClass(T.filtered); const r = t.hasClass(T.active); const l = t.hasClass(T.addition); const c = i && n.length == 1; i ? !r || l ? (A.apiSettings && A.saveRemoteData && y.save.remoteData(a, o), A.useLabels ? (y.add.label(o, a, c), y.add.value(o, a, t), y.set.activeItem(t), y.filterActive(), y.select.nextAvailable(n)) : (y.add.value(o, a, t), y.set.text(y.add.variables(k.count)), y.set.activeItem(t))) : s || (y.debug('Selected active value, removing label'), y.remove.selected(o)) : (A.apiSettings && A.saveRemoteData && y.save.remoteData(a, o), y.set.text(a), y.set.value(o, a, t), t.addClass(T.active).addClass(T.selected)); })); },
                },
                add: {
                    label(t, n, i) { let a; const o = y.is.searchSelection() ? j : H; const s = y.escape.value(t); a = e('<a />').addClass(T.label).attr(`data-${D.value}`, s).html(E.label(s, n)), a = A.onLabelCreate.call(a, s, n), y.has.value(t) ? y.debug('User selection already exists, skipping', s) : (A.label.variation && a.addClass(A.label.variation), !0 === i ? (y.debug('Animating in label', a), a.addClass(T.hidden).insertBefore(o).transition(A.label.transition, A.label.duration)) : (y.debug('Adding selection label', a), a.insertBefore(o))); },
                    message(t) { let n = B.children(O.message); const i = A.templates.message(y.add.variables(t)); n.length > 0 ? n.html(i) : n = e('<div/>').html(i).addClass(T.message).appendTo(B); },
                    optionValue(t) {
                        const n = y.escape.value(t); U.find(`option[value="${y.escape.string(n)}"]`).length > 0 || (y.disconnect.selectObserver(), y.is.single() && (y.verbose('Removing previous user addition'), U.find(`option.${T.addition}`).remove()), e('<option/>').prop('value', n).addClass(T.addition).html(t)
                            .appendTo(U), y.verbose('Adding user addition as an <option>', t), y.observe.select());
                    },
                    userSuggestion(e) {
                        let t; let n = B.children(O.addition); const i = y.get.item(e); const a = i && i.not(O.addition).length; const o = n.length > 0; A.useLabels && y.has.maxSelections() || (e === '' || a ? n.remove() : (o ? (n.data(D.value, e).data(D.text, e).attr(`data-${D.value}`, e).attr(`data-${D.text}`, e)
                            .removeClass(T.filtered), A.hideAdditions || (t = A.templates.addition(y.add.variables(k.addResult, e)), n.html(t)), y.verbose('Replacing user suggestion with new value', n)) : ((n = y.create.userChoice(e)).prependTo(B), y.verbose('Adding item choice to menu corresponding with user choice addition', n)), A.hideAdditions && !y.is.allFiltered() || n.addClass(T.selected).siblings().removeClass(T.selected), y.refreshItems()));
                    },
                    variables(e, t) { let n; let i; const a = e.search('{count}') !== -1; const o = e.search('{maxCount}') !== -1; const s = e.search('{term}') !== -1; return y.verbose('Adding templated variables to message', e), a && (n = y.get.selectionCount(), e = e.replace('{count}', n)), o && (n = y.get.selectionCount(), e = e.replace('{maxCount}', A.maxSelections)), s && (i = t || y.get.query(), e = e.replace('{term}', i)), e; },
                    value(t, n, i) { let a; const o = y.get.values(); y.has.value(t) ? y.debug('Value already selected') : t !== '' ? (e.isArray(o) ? (a = o.concat([t]), a = y.get.uniqueArray(a)) : a = [t], y.has.selectInput() ? y.can.extendSelect() && (y.debug('Adding value to select', t, a, U), y.add.optionValue(t)) : (a = a.join(A.delimiter), y.debug('Setting hidden input to delimited value', a, U)), !1 === A.fireOnInit && y.is.initialLoad() ? y.verbose('Skipping onadd callback on initial load', A.onAdd) : A.onAdd.call(G, t, n, i), y.set.value(a, t, n, i), y.check.maxSelections()) : y.debug('Cannot select blank values from multiselect'); },
                },
                remove: {
                    active() { z.removeClass(T.active); }, activeLabel() { z.find(O.label).removeClass(T.active); }, empty() { z.removeClass(T.empty); }, loading() { z.removeClass(T.loading); }, initialLoad() { g = !1; }, upward(e) { (e || z).removeClass(T.upward); }, leftward(e) { (e || B).removeClass(T.leftward); }, visible() { z.removeClass(T.visible); }, activeItem() { $.removeClass(T.active); }, filteredItem() { A.useLabels && y.has.maxSelections() || (A.useLabels && y.is.multiple() ? $.not(`.${T.active}`).removeClass(T.filtered) : $.removeClass(T.filtered), y.remove.empty()); }, optionValue(e) { const t = y.escape.value(e); const n = U.find(`option[value="${y.escape.string(t)}"]`); n.length > 0 && n.hasClass(T.addition) && (C && (C.disconnect(), y.verbose('Temporarily disconnecting mutation observer')), n.remove(), y.verbose('Removing user addition as an <option>', t), C && C.observe(U[0], { childList: !0, subtree: !0 })); }, message() { B.children(O.message).remove(); }, searchWidth() { j.css('width', ''); }, searchTerm() { y.verbose('Cleared search term'), j.val(''), y.set.filtered(); }, userAddition() { $.filter(O.addition).remove(); }, selected(t, n) { if (!(n = A.allowAdditions ? n || y.get.itemWithAdditions(t) : n || y.get.item(t))) return !1; n.each(function() { const t = e(this); const n = y.get.choiceText(t); const i = y.get.choiceValue(t, n); y.is.multiple() ? A.useLabels ? (y.remove.value(i, n, t), y.remove.label(i)) : (y.remove.value(i, n, t), y.get.selectionCount() === 0 ? y.set.placeholderText() : y.set.text(y.add.variables(k.count))) : y.remove.value(i, n, t), t.removeClass(T.filtered).removeClass(T.active), A.useLabels && t.removeClass(T.selected); }); }, selectedItem() { $.removeClass(T.selected); }, value(e, t, n) { let i; const a = y.get.values(); y.has.selectInput() ? (y.verbose('Input is <select> removing selected option', e), i = y.remove.arrayValue(e, a), y.remove.optionValue(e)) : (y.verbose('Removing from delimited values', e), i = (i = y.remove.arrayValue(e, a)).join(A.delimiter)), !1 === A.fireOnInit && y.is.initialLoad() ? y.verbose('No callback on initial load', A.onRemove) : A.onRemove.call(G, e, t, n), y.set.value(i, t, n), y.check.maxSelections(); }, arrayValue(t, n) { return e.isArray(n) || (n = [n]), n = e.grep(n, function(e) { return t != e; }), y.verbose('Removed value from delimited string', t, n), n; }, label(e, t) { const n = z.find(O.label).filter(`[data-${D.value}="${y.escape.string(e)}"]`); y.verbose('Removing label', n), n.remove(); }, activeLabels(e) { e = e || z.find(O.label).filter(`.${T.active}`), y.verbose('Removing active label selections', e), y.remove.labels(e); }, labels(t) { t = t || z.find(O.label), y.verbose('Removing labels', t), t.each(function() { const t = e(this); const n = t.data(D.value); const a = n !== i ? String(n) : n; const o = y.is.userValue(a); !1 !== A.onLabelRemove.call(t, n) ? (y.remove.message(), o ? (y.remove.value(a), y.remove.label(a)) : y.remove.selected(a)) : y.debug('Label remove callback cancelled removal'); }); }, tabbable() { y.is.searchSelection() ? (y.debug('Searchable dropdown initialized'), j.removeAttr('tabindex'), B.removeAttr('tabindex')) : (y.debug('Simple selection dropdown initialized'), z.removeAttr('tabindex'), B.removeAttr('tabindex')); },
                },
                has: {
                    menuSearch() { return y.has.search() && j.closest(B).length > 0; }, search() { return j.length > 0; }, sizer() { return N.length > 0; }, selectInput() { return U.is('select'); }, minCharacters(e) { return !A.minCharacters || (e = e !== i ? String(e) : String(y.get.query())).length >= A.minCharacters; }, firstLetter(e, t) { let n; return !(!e || e.length === 0 || typeof t !== 'string') && (n = y.get.choiceText(e, !1), (t = t.toLowerCase()) == String(n).charAt(0).toLowerCase()); }, input() { return U.length > 0; }, items() { return $.length > 0; }, menu() { return B.length > 0; }, message() { return B.children(O.message).length !== 0; }, label(e) { const t = y.escape.value(e); return z.find(O.label).filter(`[data-${D.value}="${y.escape.string(t)}"]`).length > 0; }, maxSelections() { return A.maxSelections && y.get.selectionCount() >= A.maxSelections; }, allResultsFiltered() { const e = $.not(O.addition); return e.filter(O.unselectable).length === e.length; }, userSuggestion() { return B.children(O.addition).length > 0; }, query() { return y.get.query() !== ''; }, value(e) { return A.ignoreCase ? y.has.valueIgnoringCase(e) : y.has.valueMatchingCase(e); }, valueMatchingCase(t) { const n = y.get.values(); return !!(e.isArray(n) ? n && e.inArray(t, n) !== -1 : n == t); }, valueIgnoringCase(t) { let n = y.get.values(); let i = !1; return e.isArray(n) || (n = [n]), e.each(n, function(e, n) { if (String(t).toLowerCase() == String(n).toLowerCase()) return i = !0, !1; }), i; },
                },
                is: {
                    active() { return z.hasClass(T.active); }, animatingInward() { return B.transition('is inward'); }, animatingOutward() { return B.transition('is outward'); }, bubbledLabelClick(t) { return e(t.target).is('select, input') && z.closest('label').length > 0; }, bubbledIconClick(t) { return e(t.target).closest(K).length > 0; }, alreadySetup() { return z.is('select') && z.parent(O.dropdown).data(F) !== i && z.prev().length === 0; }, animating(e) { return e ? e.transition && e.transition('is animating') : B.transition && B.transition('is animating'); }, leftward(e) { return (e || B).hasClass(T.leftward); }, disabled() { return z.hasClass(T.disabled); }, focused() { return n.activeElement === z[0]; }, focusedOnSearch() { return n.activeElement === j[0]; }, allFiltered() { return (y.is.multiple() || y.has.search()) && !(A.hideAdditions == 0 && y.has.userSuggestion()) && !y.has.message() && y.has.allResultsFiltered(); }, hidden(e) { return !y.is.visible(e); }, initialLoad() { return g; }, inObject(t, n) { let i = !1; return e.each(n, function(e, n) { if (n == t) return i = !0, !0; }), i; }, multiple() { return z.hasClass(T.multiple); }, remote() { return A.apiSettings && y.can.useAPI(); }, single() { return !y.is.multiple(); }, selectMutation(t) { let n = !1; return e.each(t, function(t, i) { if (i.target && e(i.target).is('select')) return n = !0, !0; }), n; }, search() { return z.hasClass(T.search); }, searchSelection() { return y.has.search() && j.parent(O.dropdown).length === 1; }, selection() { return z.hasClass(T.selection); }, userValue(t) { return e.inArray(t, y.get.userValues()) !== -1; }, upward(e) { return (e || z).hasClass(T.upward); }, visible(e) { return e ? e.hasClass(T.visible) : B.hasClass(T.visible); }, verticallyScrollableContext() { const e = P.get(0) !== t && P.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = P.get(0) !== t && P.css('overflow-X'); return e == 'auto' || e == 'scroll'; },
                },
                can: {
                    activate(e) { return !!A.useLabels || (!y.has.maxSelections() || !(!y.has.maxSelections() || !e.hasClass(T.active))); }, openDownward(e) { let n; let i; const a = e || B; let o = !0; return a.addClass(T.loading), i = { context: { offset: P.get(0) === t ? { top: 0, left: 0 } : P.offset(), scrollTop: P.scrollTop(), height: P.outerHeight() }, menu: { offset: a.offset(), height: a.outerHeight() } }, y.is.verticallyScrollableContext() && (i.menu.offset.top += i.context.scrollTop), (n = { above: i.context.scrollTop <= i.menu.offset.top - i.context.offset.top - i.menu.height, below: i.context.scrollTop + i.context.height >= i.menu.offset.top - i.context.offset.top + i.menu.height }).below ? (y.verbose('Dropdown can fit in context downward', n), o = !0) : n.below || n.above ? (y.verbose('Dropdown cannot fit below, opening upward', n), o = !1) : (y.verbose('Dropdown cannot fit in either direction, favoring downward', n), o = !0), a.removeClass(T.loading), o; }, openRightward(e) { let n; let i; const a = e || B; let o = !0; return a.addClass(T.loading), i = { context: { offset: P.get(0) === t ? { top: 0, left: 0 } : P.offset(), scrollLeft: P.scrollLeft(), width: P.outerWidth() }, menu: { offset: a.offset(), width: a.outerWidth() } }, y.is.horizontallyScrollableContext() && (i.menu.offset.left += i.context.scrollLeft), (n = i.menu.offset.left - i.context.offset.left + i.menu.width >= i.context.scrollLeft + i.context.width) && (y.verbose('Dropdown cannot fit in context rightward', n), o = !1), a.removeClass(T.loading), o; }, click() { return c || A.on == 'click'; }, extendSelect() { return A.allowAdditions || A.apiSettings; }, show() { return !y.is.disabled() && (y.has.items() || y.has.message()); }, useAPI() { return e.fn.api !== i; },
                },
                animate: {
                    show(t, n) {
                        let a; const o = n || B; const s = n ? function() {} : function() { y.hideSubMenus(), y.hideOthers(), y.set.active(); }; t = e.isFunction(t) ? t : function() {}, y.verbose('Doing menu show animation', o), y.set.direction(n), a = y.get.transition(n), y.is.selection() && y.set.scrollPosition(y.get.selectedItem(), !0), (y.is.hidden(o) || y.is.animating(o)) && (a == 'none' ? (s(), o.transition('show'), t.call(G)) : e.fn.transition !== i && z.transition('is supported') ? o.transition({
                            animation: `${a} in`, debug: A.debug, verbose: A.verbose, duration: A.duration, queue: !0, onStart: s, onComplete() { t.call(G); },
                        }) : y.error(V.noTransition, a));
                    },
                    hide(t, n) {
                        const a = n || B; const o = (n ? A.duration : A.duration, n ? function() {} : function() { y.can.click() && y.unbind.intent(), y.remove.active(); }); const s = y.get.transition(n); t = e.isFunction(t) ? t : function() {}, (y.is.visible(a) || y.is.animating(a)) && (y.verbose('Doing menu hide animation', a), s == 'none' ? (o(), a.transition('hide'), t.call(G)) : e.fn.transition !== i && z.transition('is supported') ? a.transition({
                            animation: `${s} out`, duration: A.duration, debug: A.debug, verbose: A.verbose, queue: !1, onStart: o, onComplete() { t.call(G); },
                        }) : y.error(V.transition));
                    },
                },
                hideAndClear() { y.remove.searchTerm(), y.has.maxSelections() || (y.has.search() ? y.hide(function() { y.remove.filteredItem(); }) : y.hide()); },
                delay: { show() { y.verbose('Delaying show event to ensure user intent'), clearTimeout(y.timer), y.timer = setTimeout(y.show, A.delay.show); }, hide() { y.verbose('Delaying hide event to ensure user intent'), clearTimeout(y.timer), y.timer = setTimeout(y.hide, A.delay.hide); } },
                escape: { value(t) { const n = e.isArray(t); const i = typeof t === 'string'; const a = !i && !n; const o = i && t.search(R.quote) !== -1; const s = []; return a || !o ? t : (y.debug('Encoding quote values for use in select', t), n ? (e.each(t, function(e, t) { s.push(t.replace(R.quote, '&quot;')); }), s) : t.replace(R.quote, '&quot;')); }, string(e) { return (e = String(e)).replace(R.escape, '\\$&'); } },
                setting(t, n) { if (y.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, A, t); else { if (n === i) return A[t]; e.isPlainObject(A[t]) ? e.extend(!0, A[t], n) : A[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, y, t); else { if (n === i) return y[t]; y[t] = n; } },
                debug() { !A.silent && A.debug && (A.performance ? y.performance.log(arguments) : (y.debug = Function.prototype.bind.call(console.info, console, `${A.name}:`), y.debug.apply(console, arguments))); },
                verbose() { !A.silent && A.verbose && A.debug && (A.performance ? y.performance.log(arguments) : (y.verbose = Function.prototype.bind.call(console.info, console, `${A.name}:`), y.verbose.apply(console, arguments))); },
                error() { A.silent || (y.error = Function.prototype.bind.call(console.error, console, `${A.name}:`), y.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; A.performance && (n = (t = (new Date()).getTime()) - (u || t), u = t, d.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: G, 'Execution Time': n,
                        })), clearTimeout(y.performance.timer), y.performance.timer = setTimeout(y.performance.display, 500);
                    },
                    display() { let t = `${A.name}:`; let n = 0; u = !1, clearTimeout(y.performance.timer), e.each(d, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, l && (t += ` '${l}'`), (console.group !== i || console.table !== i) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), d = []; },
                },
                invoke(t, n, a) { let s; let r; let l; let c = J; return n = n || m, a = G || a, typeof t === 'string' && c !== i && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, function(n, a) { const o = n != s ? a + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(c[o]) && n != s)c = c[o]; else { if (c[o] !== i) return r = c[o], !1; if (!e.isPlainObject(c[a]) || n == s) return c[a] !== i ? (r = c[a], !1) : (y.error(V.method, t), !1); c = c[a]; } })), e.isFunction(r) ? l = r.apply(a, n) : r !== i && (l = r), e.isArray(o) ? o.push(l) : o !== i ? o = [o, l] : l !== i && (o = l), r; },
            }, f ? (J === i && y.initialize(), y.invoke(v)) : (J !== i && J.invoke('destroy'), y.initialize());
        }), o !== i ? o : s;
    }, e.fn.dropdown.settings = {
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        on: 'click',
        action: 'activate',
        values: !1,
        apiSettings: !1,
        selectOnKeydown: !0,
        minCharacters: 0,
        filterRemoteData: !1,
        saveRemoteData: !0,
        throttle: 200,
        context: t,
        direction: 'auto',
        keepOnScreen: !0,
        match: 'both',
        fullTextSearch: !1,
        placeholder: 'auto',
        preserveHTML: !0,
        sortSelect: !1,
        forceSelection: !0,
        allowAdditions: !1,
        ignoreCase: !1,
        hideAdditions: !0,
        maxSelections: !1,
        useLabels: !0,
        delimiter: ',',
        showOnFocus: !0,
        allowReselection: !1,
        allowTab: !0,
        allowCategorySelection: !1,
        fireOnInit: !1,
        transition: 'auto',
        duration: 200,
        glyphWidth: 1.037,
        label: { transition: 'scale', duration: 200, variation: !1 },
        delay: {
            hide: 300, show: 200, search: 20, touch: 50,
        },
        onChange(e, t, n) {},
        onAdd(e, t, n) {},
        onRemove(e, t, n) {},
        onLabelSelect(e) {},
        onLabelCreate(t, n) { return e(this); },
        onLabelRemove(e) { return !0; },
        onNoResults(e) { return !0; },
        onShow() {},
        onHide() {},
        name: 'Dropdown',
        namespace: 'dropdown',
        message: {
            addResult: 'Add <b>{term}</b>', count: '{count} selected', maxSelections: 'Max {maxCount} selections', noResults: 'No results found.', serverError: 'There was an error contacting the server',
        },
        error: {
            action: 'You called a dropdown action that was not defined', alreadySetup: 'Once a select has been initialized behaviors must be called on the created ui dropdown', labels: 'Allowing user additions currently requires the use of labels.', missingMultiple: '<select> requires multiple property to be set to correctly preserve multiple values', method: 'The method you called is not defined.', noAPI: 'The API module is required to load resources remotely', noStorage: 'Saving remote data requires session storage', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
        },
        regExp: { escape: /[-[\]{}()*+?.,\\^$|#\s]/g, quote: /"/g },
        metadata: {
            defaultText: 'defaultText', defaultValue: 'defaultValue', placeholderText: 'placeholder', text: 'text', value: 'value',
        },
        fields: {
            remoteValues: 'results', values: 'values', disabled: 'disabled', name: 'name', value: 'value', text: 'text',
        },
        keys: {
            backspace: 8, delimiter: 188, deleteKey: 46, enter: 13, escape: 27, pageUp: 33, pageDown: 34, leftArrow: 37, upArrow: 38, rightArrow: 39, downArrow: 40,
        },
        selector: {
            addition: '.addition', dropdown: '.ui.dropdown', hidden: '.hidden', icon: '> .dropdown.icon', input: '> input[type="hidden"], > select', item: '.item', label: '> .label', remove: '> .label > .delete.icon', siblingLabel: '.label', menu: '.menu', message: '.message', menuIcon: '.dropdown.icon', search: 'input.search, .menu > .search > input, .menu input.search', sizer: '> input.sizer', text: '> .text:not(.icon)', unselectable: '.disabled, .filtered',
        },
        className: {
            active: 'active', addition: 'addition', animating: 'animating', disabled: 'disabled', empty: 'empty', dropdown: 'ui dropdown', filtered: 'filtered', hidden: 'hidden transition', item: 'item', label: 'ui label', loading: 'loading', menu: 'menu', message: 'message', multiple: 'multiple', placeholder: 'default', sizer: 'sizer', search: 'search', selected: 'selected', selection: 'selection', upward: 'upward', leftward: 'left', visible: 'visible',
        },
    }, e.fn.dropdown.settings.templates = {
        dropdown(t) { const n = t.placeholder || !1; let i = (t.values, ''); return i += '<i class="dropdown icon"></i>', t.placeholder ? i += `<div class="default text">${n}</div>` : i += '<div class="text"></div>', i += '<div class="menu">', e.each(t.values, function(e, t) { i += t.disabled ? `<div class="disabled item" data-value="${t.value}">${t.name}</div>` : `<div class="item" data-value="${t.value}">${t.name}</div>`; }), i += '</div>'; },
        menu(t, n) {
            const i = t[n.values] || {}; let a = ''; return e.each(i, function(e, t) {
                const i = t[n.text] ? `data-text="${t[n.text]}"` : '';
                const o = t[n.disabled] ? 'disabled ' : ''; a += `<div class="${o}item" data-value="${t[n.value]}"${i}>`, a += t[n.name], a += '</div>';
            }), a;
        },
        label(e, t) { return `${t}<i class="delete icon"></i>`; },
        message(e) { return e; },
        addition(e) { return e; },
    };
}(jQuery, window, document));
