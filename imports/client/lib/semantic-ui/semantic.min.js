/*
 * # Semantic UI - 2.2.12
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function(e, t, n, i) {
    e.site = e.fn.site = function(i) {
        let o; let a; let r = (new Date()).getTime(); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); const d = e.isPlainObject(i) ? e.extend(!0, {}, e.site.settings, i) : e.extend({}, e.site.settings); const f = d.namespace; const m = d.error; const g = `module-${f}`; const v = e(n); const p = v; const h = this; let b = p.data(g); return o = {
            initialize() { o.instantiate(); },
            instantiate() { o.verbose('Storing instance of site', o), b = o, p.data(g, o); },
            normalize() { o.fix.console(), o.fix.requestAnimationFrame(); },
            fix: { console() { o.debug('Normalizing window.console'), void 0 !== console && void 0 !== console.log || (o.verbose('Console not available, normalizing events'), o.disable.console()), void 0 !== console.group && void 0 !== console.groupEnd && void 0 !== console.groupCollapsed || (o.verbose('Console group not available, normalizing events'), t.console.group = function() {}, t.console.groupEnd = function() {}, t.console.groupCollapsed = function() {}), void 0 === console.markTimeline && (o.verbose('Mark timeline not available, normalizing events'), t.console.markTimeline = function() {}); }, consoleClear() { o.debug('Disabling programmatic console clearing'), t.console.clear = function() {}; }, requestAnimationFrame() { o.debug('Normalizing requestAnimationFrame'), void 0 === t.requestAnimationFrame && (o.debug('RequestAnimationFrame not available, normalizing event'), t.requestAnimationFrame = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }); } },
            moduleExists(t) { return void 0 !== e.fn[t] && void 0 !== e.fn[t].settings; },
            enabled: { modules(t) { const n = []; return t = t || d.modules, e.each(t, function(e, t) { o.moduleExists(t) && n.push(t); }), n; } },
            disabled: { modules(t) { const n = []; return t = t || d.modules, e.each(t, function(e, t) { o.moduleExists(t) || n.push(t); }), n; } },
            change: { setting(t, n, i, a) { i = typeof i === 'string' ? i === 'all' ? d.modules : [i] : i || d.modules, a = void 0 === a || a, e.each(i, function(i, r) { let s; const l = !o.moduleExists(r) || (e.fn[r].settings.namespace || !1); o.moduleExists(r) && (o.verbose('Changing default setting', t, n, r), e.fn[r].settings[t] = n, a && l && (s = e(`:data(module-${l})`), s.length > 0 && (o.verbose('Modifying existing settings', s), s[r]('setting', t, n)))); }); }, settings(t, n, i) { n = typeof n === 'string' ? [n] : n || d.modules, i = void 0 === i || i, e.each(n, function(n, a) { let r; o.moduleExists(a) && (o.verbose('Changing default setting', t, a), e.extend(!0, e.fn[a].settings, t), i && f && (r = e(`:data(module-${f})`), r.length > 0 && (o.verbose('Modifying existing settings', r), r[a]('setting', t)))); }); } },
            enable: { console() { o.console(!0); }, debug(e, t) { e = e || d.modules, o.debug('Enabling debug for modules', e), o.change.setting('debug', !0, e, t); }, verbose(e, t) { e = e || d.modules, o.debug('Enabling verbose debug for modules', e), o.change.setting('verbose', !0, e, t); } },
            disable: { console() { o.console(!1); }, debug(e, t) { e = e || d.modules, o.debug('Disabling debug for modules', e), o.change.setting('debug', !1, e, t); }, verbose(e, t) { e = e || d.modules, o.debug('Disabling verbose debug for modules', e), o.change.setting('verbose', !1, e, t); } },
            console(e) {
                if (e) { if (void 0 === b.cache.console) return void o.error(m.console); o.debug('Restoring console function'), t.console = b.cache.console; } else {
                    o.debug('Disabling console function'), b.cache.console = t.console, t.console = {
                        clear() {}, error() {}, group() {}, groupCollapsed() {}, groupEnd() {}, info() {}, log() {}, markTimeline() {}, warn() {},
                    };
                }
            },
            destroy() { o.verbose('Destroying previous site for', p), p.removeData(g); },
            cache: {},
            setting(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
            internal(t, n) { if (e.isPlainObject(t))e.extend(!0, o, t); else { if (void 0 === n) return o[t]; o[t] = n; } },
            debug() { d.debug && (d.performance ? o.performance.log(arguments) : (o.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.debug.apply(console, arguments))); },
            verbose() { d.verbose && d.debug && (d.performance ? o.performance.log(arguments) : (o.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.verbose.apply(console, arguments))); },
            error() { o.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), o.error.apply(console, arguments); },
            performance: {
                log(e) {
                    let t; let n; let i; d.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                        Element: h, Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': n,
                    })), clearTimeout(o.performance.timer), o.performance.timer = setTimeout(o.performance.display, 500);
                },
                display() { let t = `${d.name}:`; let n = 0; r = !1, clearTimeout(o.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
            },
            invoke(t, n, i) { let r; let s; let l; let c = b; return n = n || u, i = h || i, typeof t === 'string' && void 0 !== c && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, function(n, i) { const a = n != r ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(c[a]) && n != r)c = c[a]; else { if (void 0 !== c[a]) return s = c[a], !1; if (!e.isPlainObject(c[i]) || n == r) return void 0 !== c[i] ? (s = c[i], !1) : (o.error(m.method, t), !1); c = c[i]; } })), e.isFunction(s) ? l = s.apply(i, n) : void 0 !== s && (l = s), e.isArray(a) ? a.push(l) : void 0 !== a ? a = [a, l] : void 0 !== l && (a = l), s; },
        }, c ? (void 0 === b && o.initialize(), o.invoke(l)) : (void 0 !== b && o.destroy(), o.initialize()), void 0 !== a ? a : this;
    }, e.site.settings = {
        name: 'Site',
        namespace: 'site',
        error: { console: 'Console cannot be restored, most likely it was overwritten outside of module', method: 'The method you called is not defined.' },
        debug: !1,
        verbose: !1,
        performance: !0,
        modules: ['accordion', 'api', 'checkbox', 'dimmer', 'dropdown', 'embed', 'form', 'modal', 'nag', 'popup', 'rating', 'shape', 'sidebar', 'state', 'sticky', 'tab', 'transition', 'visit', 'visibility'],
        siteNamespace: 'site',
        namespaceStub: {
            cache: {}, config: {}, sections: {}, section: {}, utilities: {},
        },
    }, e.extend(e.expr[':'], { data: e.expr.createPseudo ? e.expr.createPseudo(function(t) { return function(n) { return !!e.data(n, t); }; }) : function(t, n, i) { return !!e.data(t, i[3]); } });
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.form = function(t) {
        let i; const o = e(this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const l = arguments[0]; const c = arguments[1]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return o.each(function() {
            let f; let m; let g; let v; let p; let h; let b; let y; let x; let C; let w; let k; let S; let T; let A; let R; let P; let E; let F; const O = e(this); const D = this; let q = []; let j = !1; F = {
                initialize() { F.get.settings(), u ? (void 0 === E && F.instantiate(), F.invoke(l)) : (void 0 !== E && E.invoke('destroy'), F.verbose('Initializing form validation', O, y), F.bindEvents(), F.set.defaults(), F.instantiate()); },
                instantiate() { F.verbose('Storing instance of module', F), E = F, O.data(R, F); },
                destroy() { F.verbose('Destroying previous module', E), F.removeEvents(), O.removeData(R); },
                refresh() { F.verbose('Refreshing selector cache'), f = O.find(w.field), m = O.find(w.group), g = O.find(w.message), v = O.find(w.prompt), p = O.find(w.submit), h = O.find(w.clear), b = O.find(w.reset); },
                submit() { F.verbose('Submitting form', O), O.submit(); },
                attachEvents(t, n) { n = n || 'submit', e(t).on(`click${P}`, function(e) { F[n](), e.preventDefault(); }); },
                bindEvents() {
                    F.verbose('Attaching form events'), O.on(`submit${P}`, F.validate.form).on(`blur${P}`, w.field, F.event.field.blur).on(`click${P}`, w.submit, F.submit).on(`click${P}`, w.reset, F.reset)
                        .on(`click${P}`, w.clear, F.clear), y.keyboardShortcuts && O.on(`keydown${P}`, w.field, F.event.field.keydown), f.each(function() { const t = e(this); const n = t.prop('type'); const i = F.get.changeEvent(n, t); e(this).on(i + P, F.event.field.change); });
                },
                clear() { f.each(function() { const t = e(this); const n = t.parent(); const i = t.closest(m); const o = i.find(w.prompt); const a = t.data(C.defaultValue) || ''; const r = n.is(w.uiCheckbox); const s = n.is(w.uiDropdown); i.hasClass(k.error) && (F.verbose('Resetting error on field', i), i.removeClass(k.error), o.remove()), s ? (F.verbose('Resetting dropdown value', n, a), n.dropdown('clear')) : r ? t.prop('checked', !1) : (F.verbose('Resetting field value', t, a), t.val('')); }); },
                reset() { f.each(function() { const t = e(this); const n = t.parent(); const i = t.closest(m); const o = i.find(w.prompt); const a = t.data(C.defaultValue); const r = n.is(w.uiCheckbox); const s = n.is(w.uiDropdown); const l = i.hasClass(k.error); void 0 !== a && (l && (F.verbose('Resetting error on field', i), i.removeClass(k.error), o.remove()), s ? (F.verbose('Resetting dropdown value', n, a), n.dropdown('restore defaults')) : r ? (F.verbose('Resetting checkbox value', n, a), t.prop('checked', a)) : (F.verbose('Resetting field value', t, a), t.val(a))); }); },
                determine: { isValid() { let t = !0; return e.each(x, function(e, n) { F.validate.field(n, e, !0) || (t = !1); }), t; } },
                is: {
                    bracketedRule(e) { return e.type && e.type.match(y.regExp.bracket); }, shorthandFields(e) { const t = Object.keys(e); const n = e[t[0]]; return F.is.shorthandRules(n); }, shorthandRules(t) { return typeof t === 'string' || e.isArray(t); }, empty(e) { return !e || e.length === 0 || (e.is('input[type="checkbox"]') ? !e.is(':checked') : F.is.blank(e)); }, blank(t) { return e.trim(t.val()) === ''; }, valid(t) { let n = !0; return t ? (F.verbose('Checking if field is valid', t), F.validate.field(x[t], t, !1)) : (F.verbose('Checking if form is valid'), e.each(x, function(e, t) { F.is.valid(e) || (n = !1); }), n); },
                },
                removeEvents() { O.off(P), f.off(P), p.off(P), f.off(P); },
                event: {
                    field: {
                        keydown(t) { const n = e(this); const i = t.which; const o = n.is(w.input); const a = n.is(w.checkbox); const r = n.closest(w.uiDropdown).length > 0; const s = { enter: 13, escape: 27 }; i == s.escape && (F.verbose('Escape key pressed blurring field'), n.blur()), t.ctrlKey || i != s.enter || !o || r || a || (j || (n.one(`keyup${P}`, F.event.field.keyup), F.submit(), F.debug('Enter pressed on input submitting form')), j = !0); }, keyup() { j = !1; }, blur(t) { const n = e(this); const i = n.closest(m); const o = F.get.validation(n); i.hasClass(k.error) ? (F.debug('Revalidating field', n, o), o && F.validate.field(o)) : y.on != 'blur' && y.on != 'change' || o && F.validate.field(o); }, change(t) { const n = e(this); const i = n.closest(m); const o = F.get.validation(n); o && (y.on == 'change' || i.hasClass(k.error) && y.revalidate) && (clearTimeout(F.timer), F.timer = setTimeout(function() { F.debug('Revalidating field', n, F.get.validation(n)), F.validate.field(o); }, y.delay)); },
                    },
                },
                get: {
                    ancillaryValue(e) { return !(!e.type || !e.value && !F.is.bracketedRule(e)) && (void 0 !== e.value ? e.value : `${e.type.match(y.regExp.bracket)[1]}`); }, ruleName(e) { return F.is.bracketedRule(e) ? e.type.replace(e.type.match(y.regExp.bracket)[0], '') : e.type; }, changeEvent(e, t) { return e == 'checkbox' || e == 'radio' || e == 'hidden' || t.is('select') ? 'change' : F.get.inputEvent(); }, inputEvent() { return void 0 !== n.createElement('input').oninput ? 'input' : void 0 !== n.createElement('input').onpropertychange ? 'propertychange' : 'keyup'; }, fieldsFromShorthand(t) { const n = {}; return e.each(t, function(t, i) { typeof i === 'string' && (i = [i]), n[t] = { rules: [] }, e.each(i, function(e, i) { n[t].rules.push({ type: i }); }); }), n; }, prompt(e, t) { let n; let i; let o; const a = F.get.ruleName(e); const r = F.get.ancillaryValue(e); let s = e.prompt || y.prompt[a] || y.text.unspecifiedRule; const l = s.search('{value}') !== -1; const c = s.search('{name}') !== -1; return (c || l) && (i = F.get.field(t.identifier)), l && (s = s.replace('{value}', i.val())), c && (n = i.closest(w.group).find('label').eq(0), o = n.length == 1 ? n.text() : i.prop('placeholder') || y.text.unspecifiedField, s = s.replace('{name}', o)), s = s.replace('{identifier}', t.identifier), s = s.replace('{ruleValue}', r), e.prompt || F.verbose('Using default validation prompt for type', s, a), s; }, settings() { if (e.isPlainObject(t)) { const n = Object.keys(t); const i = n.length > 0 && (void 0 !== t[n[0]].identifier && void 0 !== t[n[0]].rules); i ? (y = e.extend(!0, {}, e.fn.form.settings, c), x = e.extend({}, e.fn.form.settings.defaults, t), F.error(y.error.oldSyntax, D), F.verbose('Extending settings from legacy parameters', x, y)) : (t.fields && F.is.shorthandFields(t.fields) && (t.fields = F.get.fieldsFromShorthand(t.fields)), y = e.extend(!0, {}, e.fn.form.settings, t), x = e.extend({}, e.fn.form.settings.defaults, y.fields), F.verbose('Extending settings', x, y)); } else y = e.fn.form.settings, x = e.fn.form.settings.defaults, F.verbose('Using default form validation', x, y); A = y.namespace, C = y.metadata, w = y.selector, k = y.className, S = y.regExp, T = y.error, R = `module-${A}`, P = `.${A}`, E = O.data(R), F.refresh(); }, field(t) { return F.verbose('Finding field with identifier', t), t = F.escape.string(t), f.filter(`#${t}`).length > 0 ? f.filter(`#${t}`) : f.filter(`[name="${t}"]`).length > 0 ? f.filter(`[name="${t}"]`) : f.filter(`[name="${t}[]"]`).length > 0 ? f.filter(`[name="${t}[]"]`) : f.filter(`[data-${C.validate}="${t}"]`).length > 0 ? f.filter(`[data-${C.validate}="${t}"]`) : e('<input/>'); }, fields(t) { let n = e(); return e.each(t, function(e, t) { n = n.add(F.get.field(t)); }), n; }, validation(t) { let n; let i; return !!x && (e.each(x, function(e, o) { i = o.identifier || e, F.get.field(i)[0] == t[0] && (o.identifier = i, n = o); }), n || !1); }, value(e) { let t; const n = []; return n.push(e), t = F.get.values.call(D, n), t[e]; }, values(t) { const n = e.isArray(t) ? F.get.fields(t) : f; const i = {}; return n.each(function(t, n) { const o = e(n); let a = (o.prop('type'), o.prop('name')); const r = o.val(); const s = o.is(w.checkbox); const l = o.is(w.radio); const c = a.indexOf('[]') !== -1; const u = !!s && o.is(':checked'); a && (c ? (a = a.replace('[]', ''), i[a] || (i[a] = []), s ? u ? i[a].push(r || !0) : i[a].push(!1) : i[a].push(r)) : l ? void 0 === i[a] && (i[a] = !!u) : i[a] = s ? !!u && (r || !0) : r); }), i; },
                },
                has: { field(e) { return F.verbose('Checking for existence of a field with identifier', e), e = F.escape.string(e), typeof e !== 'string' && F.error(T.identifier, e), f.filter(`#${e}`).length > 0 || (f.filter(`[name="${e}"]`).length > 0 || f.filter(`[data-${C.validate}="${e}"]`).length > 0); } },
                escape: { string(e) { return e = String(e), e.replace(S.escape, '\\$&'); } },
                add: {
                    rule(e, t) { F.add.field(e, t); }, field(t, n) { const i = {}; F.is.shorthandRules(n) ? (n = e.isArray(n) ? n : [n], i[t] = { rules: [] }, e.each(n, function(e, n) { i[t].rules.push({ type: n }); })) : i[t] = n, x = e.extend({}, x, i), F.debug('Adding rules', i, x); }, fields(t) { let n; n = t && F.is.shorthandFields(t) ? F.get.fieldsFromShorthand(t) : t, x = e.extend({}, x, n); }, prompt(t, n) { const i = F.get.field(t); const o = i.closest(m); let a = o.children(w.prompt); const r = a.length !== 0; n = typeof n === 'string' ? [n] : n, F.verbose('Adding field error state', t), o.addClass(k.error), y.inline && (r || (a = y.templates.prompt(n), a.appendTo(o)), a.html(n[0]), r ? F.verbose('Inline errors are disabled, no inline error added', t) : y.transition && void 0 !== e.fn.transition && O.transition('is supported') ? (F.verbose('Displaying error with css transition', y.transition), a.transition(`${y.transition} in`, y.duration)) : (F.verbose('Displaying error with fallback javascript animation'), a.fadeIn(y.duration))); }, errors(e) { F.debug('Adding form error messages', e), F.set.error(), g.html(y.templates.error(e)); },
                },
                remove: {
                    rule(t, n) { const i = e.isArray(n) ? n : [n]; if (void 0 == n) return F.debug('Removed all rules'), void (x[t].rules = []); void 0 != x[t] && e.isArray(x[t].rules) && e.each(x[t].rules, function(e, n) { i.indexOf(n.type) !== -1 && (F.debug('Removed rule', n.type), x[t].rules.splice(e, 1)); }); }, field(t) { const n = e.isArray(t) ? t : [t]; e.each(n, function(e, t) { F.remove.rule(t); }); }, rules(t, n) { e.isArray(t) ? e.each(fields, function(e, t) { F.remove.rule(t, n); }) : F.remove.rule(t, n); }, fields(e) { F.remove.field(e); }, prompt(t) { const n = F.get.field(t); const i = n.closest(m); const o = i.children(w.prompt); i.removeClass(k.error), y.inline && o.is(':visible') && (F.verbose('Removing prompt for field', t), y.transition && void 0 !== e.fn.transition && O.transition('is supported') ? o.transition(`${y.transition} out`, y.duration, function() { o.remove(); }) : o.fadeOut(y.duration, function() { o.remove(); })); },
                },
                set: {
                    success() { O.removeClass(k.error).addClass(k.success); }, defaults() { f.each(function() { const t = e(this); const n = t.filter(w.checkbox).length > 0; const i = n ? t.is(':checked') : t.val(); t.data(C.defaultValue, i); }); }, error() { O.removeClass(k.success).addClass(k.error); }, value(e, t) { const n = {}; return n[e] = t, F.set.values.call(D, n); }, values(t) { e.isEmptyObject(t) || e.each(t, function(t, n) { let i; const o = F.get.field(t); let a = o.parent(); const r = e.isArray(n); const s = a.is(w.uiCheckbox); const l = a.is(w.uiDropdown); const c = o.is(w.radio) && s; const u = o.length > 0; u && (r && s ? (F.verbose('Selecting multiple', n, o), a.checkbox('uncheck'), e.each(n, function(e, t) { i = o.filter(`[value="${t}"]`), a = i.parent(), i.length > 0 && a.checkbox('check'); })) : c ? (F.verbose('Selecting radio value', n, o), o.filter(`[value="${n}"]`).parent(w.uiCheckbox).checkbox('check')) : s ? (F.verbose('Setting checkbox value', n, a), !0 === n ? a.checkbox('check') : a.checkbox('uncheck')) : l ? (F.verbose('Setting dropdown value', n, a), a.dropdown('set selected', n)) : (F.verbose('Setting field value', n, o), o.val(n))); }); },
                },
                validate: { form(e, t) { const n = F.get.values(); if (j) return !1; if (q = [], F.determine.isValid()) { if (F.debug('Form has no validation errors, submitting'), F.set.success(), !0 !== t) return y.onSuccess.call(D, e, n); } else if (F.debug('Form has errors'), F.set.error(), y.inline || F.add.errors(q), void 0 !== O.data('moduleApi') && e.stopImmediatePropagation(), !0 !== t) return y.onFailure.call(D, q, n); }, field(t, n, i) { i = void 0 === i || i, typeof t === 'string' && (F.verbose('Validating field', t), n = t, t = x[t]); const o = t.identifier || n; const a = F.get.field(o); const r = !!t.depends && F.get.field(t.depends); let s = !0; const l = []; return t.identifier || (F.debug('Using field name as identifier', o), t.identifier = o), a.prop('disabled') ? (F.debug('Field is disabled. Skipping', o), s = !0) : t.optional && F.is.blank(a) ? (F.debug('Field is optional and blank. Skipping', o), s = !0) : t.depends && F.is.empty(r) ? (F.debug('Field depends on another value that is not present or empty. Skipping', r), s = !0) : void 0 !== t.rules && e.each(t.rules, function(e, n) { F.has.field(o) && !F.validate.rule(t, n) && (F.debug('Field is invalid', o, n.type), l.push(F.get.prompt(n, t)), s = !1); }), s ? (i && (F.remove.prompt(o, l), y.onValid.call(a)), !0) : (i && (q = q.concat(l), F.add.prompt(o, l), y.onInvalid.call(a, l)), !1); }, rule(t, n) { const i = F.get.field(t.identifier); let o = (n.type, i.val()); const a = F.get.ancillaryValue(n); const r = F.get.ruleName(n); const s = y.rules[r]; return e.isFunction(s) ? (o = void 0 === o || o === '' || o === null ? '' : e.trim(`${o}`), s.call(i, o, a)) : void F.error(T.noRule, r); } },
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, y, t); else { if (void 0 === n) return y[t]; y[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, F, t); else { if (void 0 === n) return F[t]; F[t] = n; } },
                debug() { !y.silent && y.debug && (y.performance ? F.performance.log(arguments) : (F.debug = Function.prototype.bind.call(console.info, console, `${y.name}:`), F.debug.apply(console, arguments))); },
                verbose() { !y.silent && y.verbose && y.debug && (y.performance ? F.performance.log(arguments) : (F.verbose = Function.prototype.bind.call(console.info, console, `${y.name}:`), F.verbose.apply(console, arguments))); },
                error() { y.silent || (F.error = Function.prototype.bind.call(console.error, console, `${y.name}:`), F.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; y.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: D, 'Execution Time': n,
                        })), clearTimeout(F.performance.timer), F.performance.timer = setTimeout(F.performance.display, 500);
                    },
                    display() { let t = `${y.name}:`; let n = 0; r = !1, clearTimeout(F.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, n, o) { let a; let r; let s; let l = E; return n = n || d, o = D || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r; },
            }, F.initialize();
        }), void 0 !== i ? i : this;
    }, e.fn.form.settings = {
        name: 'Form',
        namespace: 'form',
        debug: !1,
        verbose: !1,
        performance: !0,
        fields: !1,
        keyboardShortcuts: !0,
        on: 'submit',
        inline: !1,
        delay: 200,
        revalidate: !0,
        transition: 'scale',
        duration: 200,
        onValid() {},
        onInvalid() {},
        onSuccess() { return !0; },
        onFailure() { return !1; },
        metadata: { defaultValue: 'default', validate: 'validate' },
        regExp: {
            htmlID: /^[a-zA-Z][\w:.-]*$/g, bracket: /\[(.*)\]/i, decimal: /^\d+\.?\d*$/, email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, flags: /^\/(.*)\/(.*)?/, integer: /^\-?\d+$/, number: /^\-?\d*(\.\d+)?$/, url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i,
        },
        text: { unspecifiedRule: 'Please enter a valid value', unspecifiedField: 'This field' },
        prompt: {
            empty: '{name} must have a value', checked: '{name} must be checked', email: '{name} must be a valid e-mail', url: '{name} must be a valid url', regExp: '{name} is not formatted correctly', integer: '{name} must be an integer', decimal: '{name} must be a decimal number', number: '{name} must be set to a number', is: '{name} must be "{ruleValue}"', isExactly: '{name} must be exactly "{ruleValue}"', not: '{name} cannot be set to "{ruleValue}"', notExactly: '{name} cannot be set to exactly "{ruleValue}"', contain: '{name} cannot contain "{ruleValue}"', containExactly: '{name} cannot contain exactly "{ruleValue}"', doesntContain: '{name} must contain  "{ruleValue}"', doesntContainExactly: '{name} must contain exactly "{ruleValue}"', minLength: '{name} must be at least {ruleValue} characters', length: '{name} must be at least {ruleValue} characters', exactLength: '{name} must be exactly {ruleValue} characters', maxLength: '{name} cannot be longer than {ruleValue} characters', match: '{name} must match {ruleValue} field', different: '{name} must have a different value than {ruleValue} field', creditCard: '{name} must be a valid credit card number', minCount: '{name} must have at least {ruleValue} choices', exactCount: '{name} must have exactly {ruleValue} choices', maxCount: '{name} must have {ruleValue} or less choices',
        },
        selector: {
            checkbox: 'input[type="checkbox"], input[type="radio"]', clear: '.clear', field: 'input, textarea, select', group: '.field', input: 'input', message: '.error.message', prompt: '.prompt.label', radio: 'input[type="radio"]', reset: '.reset:not([type="reset"])', submit: '.submit:not([type="submit"])', uiCheckbox: '.ui.checkbox', uiDropdown: '.ui.dropdown',
        },
        className: {
            error: 'error', label: 'ui prompt label', pressed: 'down', success: 'success',
        },
        error: {
            identifier: 'You must specify a string identifier for each field', method: 'The method you called is not defined.', noRule: 'There is no rule matching the one you specified', oldSyntax: 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.',
        },
        templates: { error(t) { let n = '<ul class="list">'; return e.each(t, function(e, t) { n += `<li>${t}</li>`; }), n += '</ul>', e(n); }, prompt(t) { return e('<div/>').addClass('ui basic red pointing prompt label').html(t[0]); } },
        rules: {
            empty(t) { return !(void 0 === t || t === '' || e.isArray(t) && t.length === 0); },
            checked() { return e(this).filter(':checked').length > 0; },
            email(t) { return e.fn.form.settings.regExp.email.test(t); },
            url(t) { return e.fn.form.settings.regExp.url.test(t); },
            regExp(t, n) { if (n instanceof RegExp) return t.match(n); let i; const o = n.match(e.fn.form.settings.regExp.flags); return o && (n = o.length >= 2 ? o[1] : n, i = o.length >= 3 ? o[2] : ''), t.match(new RegExp(n, i)); },
            integer(t, n) { let i; let o; let a; const r = e.fn.form.settings.regExp.integer; return n && ['', '..'].indexOf(n) === -1 && (n.indexOf('..') == -1 ? r.test(n) && (i = o = n - 0) : (a = n.split('..', 2), r.test(a[0]) && (i = a[0] - 0), r.test(a[1]) && (o = a[1] - 0))), r.test(t) && (void 0 === i || t >= i) && (void 0 === o || t <= o); },
            decimal(t) { return e.fn.form.settings.regExp.decimal.test(t); },
            number(t) { return e.fn.form.settings.regExp.number.test(t); },
            is(e, t) { return t = typeof t === 'string' ? t.toLowerCase() : t, (e = typeof e === 'string' ? e.toLowerCase() : e) == t; },
            isExactly(e, t) { return e == t; },
            not(e, t) { return e = typeof e === 'string' ? e.toLowerCase() : e, t = typeof t === 'string' ? t.toLowerCase() : t, e != t; },
            notExactly(e, t) { return e != t; },
            contains(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n, 'i')) !== -1; },
            containsExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n)) !== -1; },
            doesntContain(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n, 'i')) === -1; },
            doesntContainExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, '\\$&'), t.search(new RegExp(n)) === -1; },
            minLength(e, t) { return void 0 !== e && e.length >= t; },
            length(e, t) { return void 0 !== e && e.length >= t; },
            exactLength(e, t) { return void 0 !== e && e.length == t; },
            maxLength(e, t) { return void 0 !== e && e.length <= t; },
            match(t, n) { let i; e(this); return e(`[data-validate="${n}"]`).length > 0 ? i = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? i = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? i = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (i = e(`[name="${n}[]"]`)), void 0 !== i && t.toString() == i.toString(); },
            different(t, n) { let i; e(this); return e(`[data-validate="${n}"]`).length > 0 ? i = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? i = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? i = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (i = e(`[name="${n}[]"]`)), void 0 !== i && t.toString() !== i.toString(); },
            creditCard(t, n) {
                let i; let o; const a = {
                    visa: { pattern: /^4/, length: [16] }, amex: { pattern: /^3[47]/, length: [15] }, mastercard: { pattern: /^5[1-5]/, length: [16] }, discover: { pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/, length: [16] }, unionPay: { pattern: /^(62|88)/, length: [16, 17, 18, 19] }, jcb: { pattern: /^35(2[89]|[3-8][0-9])/, length: [16] }, maestro: { pattern: /^(5018|5020|5038|6304|6759|676[1-3])/, length: [12, 13, 14, 15, 16, 17, 18, 19] }, dinersClub: { pattern: /^(30[0-5]|^36)/, length: [14] }, laser: { pattern: /^(6304|670[69]|6771)/, length: [16, 17, 18, 19] }, visaElectron: { pattern: /^(4026|417500|4508|4844|491(3|7))/, length: [16] },
                }; let r = {}; let s = !1; const l = typeof n === 'string' && n.split(','); if (typeof t === 'string' && t.length !== 0) { if (t = t.replace(/[\-]/g, ''), l && (e.each(l, function(n, i) { (o = a[i]) && (r = { length: e.inArray(t.length, o.length) !== -1, pattern: t.search(o.pattern) !== -1 }, r.length && r.pattern && (s = !0)); }), !s)) return !1; if (i = { number: e.inArray(t.length, a.unionPay.length) !== -1, pattern: t.search(a.unionPay.pattern) !== -1 }, i.number && i.pattern) return !0; for (var c = t.length, u = 0, d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], f = 0; c--;)f += d[u][parseInt(t.charAt(c), 10)], u ^= 1; return f % 10 == 0 && f > 0; }
            },
            minCount(e, t) { return t == 0 || (t == 1 ? e !== '' : e.split(',').length >= t); },
            exactCount(e, t) { return t == 0 ? e === '' : t == 1 ? e !== '' && e.search(',') === -1 : e.split(',').length == t; },
            maxCount(e, t) { return t != 0 && (t == 1 ? e.search(',') === -1 : e.split(',').length <= t); },
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.accordion = function(n) {
        let i; const o = e(this); let a = (new Date()).getTime(); let r = []; const s = arguments[0]; const l = typeof s === 'string'; const c = [].slice.call(arguments, 1); t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame; return o.each(function() {
            let u; let d; const f = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.accordion.settings, n) : e.extend({}, e.fn.accordion.settings); const m = f.className; const g = f.namespace; const v = f.selector; const p = f.error; const h = `.${g}`; const b = `module-${g}`; const y = o.selector || ''; const x = e(this); let C = x.find(v.title); let w = x.find(v.content); const k = this; let S = x.data(b); d = {
                initialize() { d.debug('Initializing', x), d.bind.events(), f.observeChanges && d.observeChanges(), d.instantiate(); },
                instantiate() { S = d, x.data(b, d); },
                destroy() { d.debug('Destroying previous instance', x), x.off(h).removeData(b); },
                refresh() { C = x.find(v.title), w = x.find(v.content); },
                observeChanges() { 'MutationObserver' in t && (u = new MutationObserver(function(e) { d.debug('DOM tree modified, updating selector cache'), d.refresh(); }), u.observe(k, { childList: !0, subtree: !0 }), d.debug('Setting up mutation observer', u)); },
                bind: { events() { d.debug('Binding delegated events'), x.on(f.on + h, v.trigger, d.event.click); } },
                event: { click() { d.toggle.call(this); } },
                toggle(t) { const n = void 0 !== t ? typeof t === 'number' ? C.eq(t) : e(t).closest(v.title) : e(this).closest(v.title); const i = n.next(w); const o = i.hasClass(m.animating); const a = i.hasClass(m.active); const r = a && !o; const s = !a && o; d.debug('Toggling visibility of content', n), r || s ? f.collapsible ? d.close.call(n) : d.debug('Cannot close accordion content collapsing is disabled') : d.open.call(n); },
                open(t) {
                    const n = void 0 !== t ? typeof t === 'number' ? C.eq(t) : e(t).closest(v.title) : e(this).closest(v.title); const i = n.next(w); const o = i.hasClass(m.animating); if (i.hasClass(m.active) || o) return void d.debug('Accordion already open, skipping', i); d.debug('Opening accordion content', n), f.onOpening.call(i), f.exclusive && d.closeOthers.call(n), n.addClass(m.active), i.stop(!0, !0).addClass(m.animating), f.animateChildren && (void 0 !== e.fn.transition && x.transition('is supported') ? i.children().transition({
                        animation: 'fade in', queue: !1, useFailSafe: !0, debug: f.debug, verbose: f.verbose, duration: f.duration,
                    }) : i.children().stop(!0, !0).animate({ opacity: 1 }, f.duration, d.resetOpacity)), i.slideDown(f.duration, f.easing, function() { i.removeClass(m.animating).addClass(m.active), d.reset.display.call(this), f.onOpen.call(this), f.onChange.call(this); });
                },
                close(t) {
                    const n = void 0 !== t ? typeof t === 'number' ? C.eq(t) : e(t).closest(v.title) : e(this).closest(v.title); const i = n.next(w); const o = i.hasClass(m.animating); const a = i.hasClass(m.active); const r = !a && o; const s = a && o; !a && !r || s || (d.debug('Closing accordion content', i), f.onClosing.call(i), n.removeClass(m.active), i.stop(!0, !0).addClass(m.animating), f.animateChildren && (void 0 !== e.fn.transition && x.transition('is supported') ? i.children().transition({
                        animation: 'fade out', queue: !1, useFailSafe: !0, debug: f.debug, verbose: f.verbose, duration: f.duration,
                    }) : i.children().stop(!0, !0).animate({ opacity: 0 }, f.duration, d.resetOpacity)), i.slideUp(f.duration, f.easing, function() { i.removeClass(m.animating).removeClass(m.active), d.reset.display.call(this), f.onClose.call(this), f.onChange.call(this); }));
                },
                closeOthers(t) {
                    let n; let i; let o; const a = void 0 !== t ? C.eq(t) : e(this).closest(v.title); const r = a.parents(v.content).prev(v.title); const s = a.closest(v.accordion); const l = `${v.title}.${m.active}:visible`; const c = `${v.content}.${m.active}:visible`; f.closeNested ? (n = s.find(l).not(r), o = n.next(w)) : (n = s.find(l).not(r), i = s.find(c).find(l).not(r), n = n.not(i), o = n.next(w)), n.length > 0 && (d.debug('Exclusive enabled, closing other content', n), n.removeClass(m.active), o.removeClass(m.animating).stop(!0, !0), f.animateChildren && (void 0 !== e.fn.transition && x.transition('is supported') ? o.children().transition({
                        animation: 'fade out', useFailSafe: !0, debug: f.debug, verbose: f.verbose, duration: f.duration,
                    }) : o.children().stop(!0, !0).animate({ opacity: 0 }, f.duration, d.resetOpacity)), o.slideUp(f.duration, f.easing, function() { e(this).removeClass(m.active), d.reset.display.call(this); }));
                },
                reset: { display() { d.verbose('Removing inline display from element', this), e(this).css('display', ''), e(this).attr('style') === '' && e(this).attr('style', '').removeAttr('style'); }, opacity() { d.verbose('Removing inline opacity from element', this), e(this).css('opacity', ''), e(this).attr('style') === '' && e(this).attr('style', '').removeAttr('style'); } },
                setting(t, n) { if (d.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                internal(t, n) { if (d.debug('Changing internal', t, n), void 0 === n) return d[t]; e.isPlainObject(t) ? e.extend(!0, d, t) : d[t] = n; },
                debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                verbose() {
                    !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments)));
                },
                error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = a || t, n = t - i, a = t, r.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: k, 'Execution Time': n,
                        })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                    },
                    display() { let t = `${f.name}:`; let n = 0; a = !1, clearTimeout(d.performance.timer), e.each(r, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, y && (t += ` '${y}'`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), r = []; },
                },
                invoke(t, n, o) { let a; let r; let s; let l = S; return n = n || c, o = k || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (d.error(p.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r; },
            }, l ? (void 0 === S && d.initialize(), d.invoke(s)) : (void 0 !== S && S.invoke('destroy'), d.initialize());
        }), void 0 !== i ? i : this;
    }, e.fn.accordion.settings = {
        name: 'Accordion',
        namespace: 'accordion',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        on: 'click',
        observeChanges: !0,
        exclusive: !0,
        collapsible: !0,
        closeNested: !1,
        animateChildren: !0,
        duration: 350,
        easing: 'easeOutQuad',
        onOpening() {},
        onOpen() {},
        onClosing() {},
        onClose() {},
        onChange() {},
        error: { method: 'The method you called is not defined' },
        className: { active: 'active', animating: 'animating' },
        selector: {
            accordion: '.accordion', title: '.title', trigger: '.title', content: '.content',
        },
    }, e.extend(e.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.checkbox = function(i) {
        let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let l = []; const c = arguments[0]; const u = typeof c === 'string'; const d = [].slice.call(arguments, 1); return a.each(function() {
            let a; let f; const m = e.extend(!0, {}, e.fn.checkbox.settings, i); const g = m.className; const v = m.namespace; const p = m.selector; const h = m.error; const b = `.${v}`; const y = `module-${v}`; let x = e(this); let C = e(this).children(p.label); let w = e(this).children(p.input); let k = w[0]; let S = !1; let T = !1; let A = x.data(y); const R = this; f = {
                initialize() { f.verbose('Initializing checkbox', m), f.create.label(), f.bind.events(), f.set.tabbable(), f.hide.input(), f.observeChanges(), f.instantiate(), f.setup(); },
                instantiate() { f.verbose('Storing instance of module', f), A = f, x.data(y, f); },
                destroy() { f.verbose('Destroying module'), f.unbind.events(), f.show.input(), x.removeData(y); },
                fix: { reference() { x.is(p.input) && (f.debug('Behavior called on <input> adjusting invoked element'), x = x.closest(p.checkbox), f.refresh()); } },
                setup() { f.set.initialLoad(), f.is.indeterminate() ? (f.debug('Initial value is indeterminate'), f.indeterminate()) : f.is.checked() ? (f.debug('Initial value is checked'), f.check()) : (f.debug('Initial value is unchecked'), f.uncheck()), f.remove.initialLoad(); },
                refresh() { C = x.children(p.label), w = x.children(p.input), k = w[0]; },
                hide: { input() { f.verbose('Modifying <input> z-index to be unselectable'), w.addClass(g.hidden); } },
                show: { input() { f.verbose('Modifying <input> z-index to be selectable'), w.removeClass(g.hidden); } },
                observeChanges() { 'MutationObserver' in t && (a = new MutationObserver(function(e) { f.debug('DOM tree modified, updating selector cache'), f.refresh(); }), a.observe(R, { childList: !0, subtree: !0 }), f.debug('Setting up mutation observer', a)); },
                attachEvents(t, n) { const i = e(t); n = e.isFunction(f[n]) ? f[n] : f.toggle, i.length > 0 ? (f.debug('Attaching checkbox events to element', t, n), i.on(`click${b}`, n)) : f.error(h.notFound); },
                event: { click(t) { const n = e(t.target); return n.is(p.input) ? void f.verbose('Using default check action on initialized checkbox') : n.is(p.link) ? void f.debug('Clicking link inside checkbox, skipping toggle') : (f.toggle(), w.focus(), void t.preventDefault()); }, keydown(e) { const t = e.which; const n = { enter: 13, space: 32, escape: 27 }; t == n.escape ? (f.verbose('Escape key pressed blurring field'), w.blur(), T = !0) : e.ctrlKey || t != n.space && t != n.enter ? T = !1 : (f.verbose('Enter/space key pressed, toggling checkbox'), f.toggle(), T = !0); }, keyup(e) { T && e.preventDefault(); } },
                check() { f.should.allowCheck() && (f.debug('Checking checkbox', w), f.set.checked(), f.should.ignoreCallbacks() || (m.onChecked.call(k), m.onChange.call(k))); },
                uncheck() { f.should.allowUncheck() && (f.debug('Unchecking checkbox'), f.set.unchecked(), f.should.ignoreCallbacks() || (m.onUnchecked.call(k), m.onChange.call(k))); },
                indeterminate() { if (f.should.allowIndeterminate()) return void f.debug('Checkbox is already indeterminate'); f.debug('Making checkbox indeterminate'), f.set.indeterminate(), f.should.ignoreCallbacks() || (m.onIndeterminate.call(k), m.onChange.call(k)); },
                determinate() { if (f.should.allowDeterminate()) return void f.debug('Checkbox is already determinate'); f.debug('Making checkbox determinate'), f.set.determinate(), f.should.ignoreCallbacks() || (m.onDeterminate.call(k), m.onChange.call(k)); },
                enable() { if (f.is.enabled()) return void f.debug('Checkbox is already enabled'); f.debug('Enabling checkbox'), f.set.enabled(), m.onEnable.call(k), m.onEnabled.call(k); },
                disable() { if (f.is.disabled()) return void f.debug('Checkbox is already disabled'); f.debug('Disabling checkbox'), f.set.disabled(), m.onDisable.call(k), m.onDisabled.call(k); },
                get: { radios() { const t = f.get.name(); return e(`input[name="${t}"]`).closest(p.checkbox); }, otherRadios() { return f.get.radios().not(x); }, name() { return w.attr('name'); } },
                is: {
                    initialLoad() { return S; }, radio() { return w.hasClass(g.radio) || w.attr('type') == 'radio'; }, indeterminate() { return void 0 !== w.prop('indeterminate') && w.prop('indeterminate'); }, checked() { return void 0 !== w.prop('checked') && w.prop('checked'); }, disabled() { return void 0 !== w.prop('disabled') && w.prop('disabled'); }, enabled() { return !f.is.disabled(); }, determinate() { return !f.is.indeterminate(); }, unchecked() { return !f.is.checked(); },
                },
                should: {
                    allowCheck() { return f.is.determinate() && f.is.checked() && !f.should.forceCallbacks() ? (f.debug('Should not allow check, checkbox is already checked'), !1) : !1 !== m.beforeChecked.apply(k) || (f.debug('Should not allow check, beforeChecked cancelled'), !1); }, allowUncheck() { return f.is.determinate() && f.is.unchecked() && !f.should.forceCallbacks() ? (f.debug('Should not allow uncheck, checkbox is already unchecked'), !1) : !1 !== m.beforeUnchecked.apply(k) || (f.debug('Should not allow uncheck, beforeUnchecked cancelled'), !1); }, allowIndeterminate() { return f.is.indeterminate() && !f.should.forceCallbacks() ? (f.debug('Should not allow indeterminate, checkbox is already indeterminate'), !1) : !1 !== m.beforeIndeterminate.apply(k) || (f.debug('Should not allow indeterminate, beforeIndeterminate cancelled'), !1); }, allowDeterminate() { return f.is.determinate() && !f.should.forceCallbacks() ? (f.debug('Should not allow determinate, checkbox is already determinate'), !1) : !1 !== m.beforeDeterminate.apply(k) || (f.debug('Should not allow determinate, beforeDeterminate cancelled'), !1); }, forceCallbacks() { return f.is.initialLoad() && m.fireOnInit; }, ignoreCallbacks() { return S && !m.fireOnInit; },
                },
                can: { change() { return !(x.hasClass(g.disabled) || x.hasClass(g.readOnly) || w.prop('disabled') || w.prop('readonly')); }, uncheck() { return typeof m.uncheckable === 'boolean' ? m.uncheckable : !f.is.radio(); } },
                set: {
                    initialLoad() { S = !0; }, checked() { if (f.verbose('Setting class to checked'), x.removeClass(g.indeterminate).addClass(g.checked), f.is.radio() && f.uncheckOthers(), !f.is.indeterminate() && f.is.checked()) return void f.debug('Input is already checked, skipping input property change'); f.verbose('Setting state to checked', k), w.prop('indeterminate', !1).prop('checked', !0), f.trigger.change(); }, unchecked() { if (f.verbose('Removing checked class'), x.removeClass(g.indeterminate).removeClass(g.checked), !f.is.indeterminate() && f.is.unchecked()) return void f.debug('Input is already unchecked'); f.debug('Setting state to unchecked'), w.prop('indeterminate', !1).prop('checked', !1), f.trigger.change(); }, indeterminate() { if (f.verbose('Setting class to indeterminate'), x.addClass(g.indeterminate), f.is.indeterminate()) return void f.debug('Input is already indeterminate, skipping input property change'); f.debug('Setting state to indeterminate'), w.prop('indeterminate', !0), f.trigger.change(); }, determinate() { if (f.verbose('Removing indeterminate class'), x.removeClass(g.indeterminate), f.is.determinate()) return void f.debug('Input is already determinate, skipping input property change'); f.debug('Setting state to determinate'), w.prop('indeterminate', !1); }, disabled() { if (f.verbose('Setting class to disabled'), x.addClass(g.disabled), f.is.disabled()) return void f.debug('Input is already disabled, skipping input property change'); f.debug('Setting state to disabled'), w.prop('disabled', 'disabled'), f.trigger.change(); }, enabled() { if (f.verbose('Removing disabled class'), x.removeClass(g.disabled), f.is.enabled()) return void f.debug('Input is already enabled, skipping input property change'); f.debug('Setting state to enabled'), w.prop('disabled', !1), f.trigger.change(); }, tabbable() { f.verbose('Adding tabindex to checkbox'), void 0 === w.attr('tabindex') && w.attr('tabindex', 0); },
                },
                remove: { initialLoad() { S = !1; } },
                trigger: { change() { const e = n.createEvent('HTMLEvents'); const t = w[0]; t && (f.verbose('Triggering native change event'), e.initEvent('change', !0, !1), t.dispatchEvent(e)); } },
                create: { label() { w.prevAll(p.label).length > 0 ? (w.prev(p.label).detach().insertAfter(w), f.debug('Moving existing label', C)) : f.has.label() || (C = e('<label>').insertAfter(w), f.debug('Creating label', C)); } },
                has: { label() { return C.length > 0; } },
                bind: { events() { f.verbose('Attaching checkbox events'), x.on(`click${b}`, f.event.click).on(`keydown${b}`, p.input, f.event.keydown).on(`keyup${b}`, p.input, f.event.keyup); } },
                unbind: { events() { f.debug('Removing events'), x.off(b); } },
                uncheckOthers() { const e = f.get.otherRadios(); f.debug('Unchecking other radios', e), e.removeClass(g.checked); },
                toggle() { if (!f.can.change()) return void (f.is.radio() || f.debug('Checkbox is read-only or disabled, ignoring toggle')); f.is.indeterminate() || f.is.unchecked() ? (f.debug('Currently unchecked'), f.check()) : f.is.checked() && f.can.uncheck() && (f.debug('Currently checked'), f.uncheck()); },
                setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; e.isPlainObject(m[t]) ? e.extend(!0, m[t], n) : m[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; f[t] = n; } },
                debug() { !m.silent && m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
                verbose() { !m.silent && m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
                error() { m.silent || (f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: R, 'Execution Time': n,
                        })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                    },
                    display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(f.performance.timer), e.each(l, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = A; return n = n || d, i = R || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (f.error(h.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, u ? (void 0 === A && f.initialize(), f.invoke(c)) : (void 0 !== A && A.invoke('destroy'), f.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.checkbox.settings = {
        name: 'Checkbox',
        namespace: 'checkbox',
        silent: !1,
        debug: !1,
        verbose: !0,
        performance: !0,
        uncheckable: 'auto',
        fireOnInit: !1,
        onChange() {},
        beforeChecked() {},
        beforeUnchecked() {},
        beforeDeterminate() {},
        beforeIndeterminate() {},
        onChecked() {},
        onUnchecked() {},
        onDeterminate() {},
        onIndeterminate() {},
        onEnable() {},
        onDisable() {},
        onEnabled() {},
        onDisabled() {},
        className: {
            checked: 'checked', indeterminate: 'indeterminate', disabled: 'disabled', hidden: 'hidden', radio: 'radio', readOnly: 'read-only',
        },
        error: { method: 'The method you called is not defined' },
        selector: {
            checkbox: '.ui.checkbox', label: 'label, .box', input: 'input[type="checkbox"], input[type="radio"]', link: 'a[href]',
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.dimmer = function(t) {
        let i; const o = e(this); let a = (new Date()).getTime(); let r = []; const s = arguments[0]; const l = typeof s === 'string'; const c = [].slice.call(arguments, 1); return o.each(function() {
            let u; let d; let f; const m = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.dimmer.settings, t) : e.extend({}, e.fn.dimmer.settings); const g = m.selector; const v = m.namespace; const p = m.className; const h = m.error; const b = `.${v}`; const y = `module-${v}`; const x = o.selector || ''; const C = 'ontouchstart' in n.documentElement ? 'touchstart' : 'click'; const w = e(this); const k = this; let S = w.data(y); f = {
                preinitialize() { f.is.dimmer() ? (d = w.parent(), u = w) : (d = w, u = f.has.dimmer() ? m.dimmerName ? d.find(g.dimmer).filter(`.${m.dimmerName}`) : d.find(g.dimmer) : f.create(), f.set.variation()); },
                initialize() { f.debug('Initializing dimmer', m), f.bind.events(), f.set.dimmable(), f.instantiate(); },
                instantiate() { f.verbose('Storing instance of module', f), S = f, w.data(y, S); },
                destroy() { f.verbose('Destroying previous module', u), f.unbind.events(), f.remove.variation(), d.off(b); },
                bind: { events() { m.on == 'hover' ? d.on(`mouseenter${b}`, f.show).on(`mouseleave${b}`, f.hide) : m.on == 'click' && d.on(C + b, f.toggle), f.is.page() && (f.debug('Setting as a page dimmer', d), f.set.pageDimmer()), f.is.closable() && (f.verbose('Adding dimmer close event', u), d.on(C + b, g.dimmer, f.event.click)); } },
                unbind: { events() { w.removeData(y), d.off(b); } },
                event: { click(t) { f.verbose('Determining if event occured on dimmer', t), (u.find(t.target).length === 0 || e(t.target).is(g.content)) && (f.hide(), t.stopImmediatePropagation()); } },
                addContent(t) { const n = e(t); f.debug('Add content to dimmer', n), n.parent()[0] !== u[0] && n.detach().appendTo(u); },
                create() { const t = e(m.template.dimmer()); return m.dimmerName && (f.debug('Creating named dimmer', m.dimmerName), t.addClass(m.dimmerName)), t.appendTo(d), t; },
                show(t) { t = e.isFunction(t) ? t : function() {}, f.debug('Showing dimmer', u, m), f.is.dimmed() && !f.is.animating() || !f.is.enabled() ? f.debug('Dimmer is already shown or disabled') : (f.animate.show(t), m.onShow.call(k), m.onChange.call(k)); },
                hide(t) { t = e.isFunction(t) ? t : function() {}, f.is.dimmed() || f.is.animating() ? (f.debug('Hiding dimmer', u), f.animate.hide(t), m.onHide.call(k), m.onChange.call(k)) : f.debug('Dimmer is not visible'); },
                toggle() { f.verbose('Toggling dimmer visibility', u), f.is.dimmed() ? f.hide() : f.show(); },
                animate: {
                    show(t) {
                        t = e.isFunction(t) ? t : function() {}, m.useCSS && void 0 !== e.fn.transition && u.transition('is supported') ? (m.opacity !== 'auto' && f.set.opacity(), u.transition({
                            animation: `${m.transition} in`, queue: !1, duration: f.get.duration(), useFailSafe: !0, onStart() { f.set.dimmed(); }, onComplete() { f.set.active(), t(); },
                        })) : (f.verbose('Showing dimmer animation with javascript'), f.set.dimmed(), m.opacity == 'auto' && (m.opacity = 0.8), u.stop().css({ opacity: 0, width: '100%', height: '100%' }).fadeTo(f.get.duration(), m.opacity, function() { u.removeAttr('style'), f.set.active(), t(); }));
                    },
                    hide(t) {
                        t = e.isFunction(t) ? t : function() {}, m.useCSS && void 0 !== e.fn.transition && u.transition('is supported') ? (f.verbose('Hiding dimmer with css'), u.transition({
                            animation: `${m.transition} out`, queue: !1, duration: f.get.duration(), useFailSafe: !0, onStart() { f.remove.dimmed(); }, onComplete() { f.remove.active(), t(); },
                        })) : (f.verbose('Hiding dimmer with javascript'), f.remove.dimmed(), u.stop().fadeOut(f.get.duration(), function() { f.remove.active(), u.removeAttr('style'), t(); }));
                    },
                },
                get: { dimmer() { return u; }, duration() { return typeof m.duration === 'object' ? f.is.active() ? m.duration.hide : m.duration.show : m.duration; } },
                has: { dimmer() { return m.dimmerName ? w.find(g.dimmer).filter(`.${m.dimmerName}`).length > 0 : w.find(g.dimmer).length > 0; } },
                is: {
                    active() { return u.hasClass(p.active); }, animating() { return u.is(':animated') || u.hasClass(p.animating); }, closable() { return m.closable == 'auto' ? m.on != 'hover' : m.closable; }, dimmer() { return w.hasClass(p.dimmer); }, dimmable() { return w.hasClass(p.dimmable); }, dimmed() { return d.hasClass(p.dimmed); }, disabled() { return d.hasClass(p.disabled); }, enabled() { return !f.is.disabled(); }, page() { return d.is('body'); }, pageDimmer() { return u.hasClass(p.pageDimmer); },
                },
                can: { show() { return !u.hasClass(p.disabled); } },
                set: {
                    opacity(e) { let t = u.css('background-color'); const n = t.split(','); const i = n && n.length == 3; const o = n && n.length == 4; e = m.opacity === 0 ? 0 : m.opacity || e, i || o ? (n[3] = `${e})`, t = n.join(',')) : t = `rgba(0, 0, 0, ${e})`, f.debug('Setting opacity to', e), u.css('background-color', t); }, active() { u.addClass(p.active); }, dimmable() { d.addClass(p.dimmable); }, dimmed() { d.addClass(p.dimmed); }, pageDimmer() { u.addClass(p.pageDimmer); }, disabled() { u.addClass(p.disabled); }, variation(e) { (e = e || m.variation) && u.addClass(e); },
                },
                remove: {
                    active() { u.removeClass(p.active); }, dimmed() { d.removeClass(p.dimmed); }, disabled() { u.removeClass(p.disabled); }, variation(e) { (e = e || m.variation) && u.removeClass(e); },
                },
                setting(t, n) { if (f.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; e.isPlainObject(m[t]) ? e.extend(!0, m[t], n) : m[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; f[t] = n; } },
                debug() { !m.silent && m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
                verbose() { !m.silent && m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
                error() { m.silent || (f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = a || t, n = t - i, a = t, r.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: k, 'Execution Time': n,
                        })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                    },
                    display() { let t = `${m.name}:`; let n = 0; a = !1, clearTimeout(f.performance.timer), e.each(r, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, x && (t += ` '${x}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), r = []; },
                },
                invoke(t, n, o) { let a; let r; let s; let l = S; return n = n || c, o = k || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (f.error(h.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r; },
            }, f.preinitialize(), l ? (void 0 === S && f.initialize(), f.invoke(s)) : (void 0 !== S && S.invoke('destroy'), f.initialize());
        }), void 0 !== i ? i : this;
    }, e.fn.dimmer.settings = {
        name: 'Dimmer',
        namespace: 'dimmer',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        dimmerName: !1,
        variation: !1,
        closable: 'auto',
        useCSS: !0,
        transition: 'fade',
        on: !1,
        opacity: 'auto',
        duration: { show: 500, hide: 500 },
        onChange() {},
        onShow() {},
        onHide() {},
        error: { method: 'The method you called is not defined.' },
        className: {
            active: 'active', animating: 'animating', dimmable: 'dimmable', dimmed: 'dimmed', dimmer: 'dimmer', disabled: 'disabled', hide: 'hide', pageDimmer: 'page', show: 'show',
        },
        selector: { dimmer: '> .ui.dimmer', content: '.ui.dimmer > .content, .ui.dimmer > .content > .center' },
        template: { dimmer() { return e('<div />').attr('class', 'ui dimmer'); } },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.dropdown = function(i) {
        let o; let a = e(this); const r = e(n); const s = a.selector || ''; const l = 'ontouchstart' in n.documentElement; let c = (new Date()).getTime(); let u = []; const d = arguments[0]; const f = typeof d === 'string'; const m = [].slice.call(arguments, 1); return a.each(function(g) {
            let v; let p; let h; let b; let y; let x; let C; let w; const k = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.dropdown.settings, i) : e.extend({}, e.fn.dropdown.settings); const S = k.className; const T = k.message; const A = k.fields; const R = k.keys; const P = k.metadata; const E = k.namespace; const F = k.regExp; const O = k.selector; const D = k.error; const q = k.templates; const j = `.${E}`; const z = `module-${E}`; let I = e(this); const M = e(k.context); let L = I.find(O.text); let V = I.find(O.search); let N = I.find(O.sizer); let H = I.find(O.input); let U = I.find(O.icon); let W = I.prev().find(O.text).length > 0 ? I.prev().find(O.text) : I.prev(); let B = I.children(O.menu); let Q = B.find(O.item); let X = !1; let $ = !1; let Y = !1; let Z = this; let K = I.data(z); w = {
                initialize() { w.debug('Initializing dropdown', k), w.is.alreadySetup() ? w.setup.reference() : (w.setup.layout(), k.values && w.change.values(k.values), w.refreshData(), w.save.defaults(), w.restore.selected(), w.create.id(), w.bind.events(), w.observeChanges(), w.instantiate()); },
                instantiate() { w.verbose('Storing instance of dropdown', w), K = w, I.data(z, w); },
                destroy() { w.verbose('Destroying previous dropdown', I), w.remove.tabbable(), I.off(j).removeData(z), B.off(j), r.off(b), w.disconnect.menuObserver(), w.disconnect.selectObserver(); },
                observeChanges() { 'MutationObserver' in t && (x = new MutationObserver(w.event.select.mutation), C = new MutationObserver(w.event.menu.mutation), w.debug('Setting up mutation observer', x, C), w.observe.select(), w.observe.menu()); },
                disconnect: { menuObserver() { C && C.disconnect(); }, selectObserver() { x && x.disconnect(); } },
                observe: { select() { w.has.input() && x.observe(I[0], { childList: !0, subtree: !0 }); }, menu() { w.has.menu() && C.observe(B[0], { childList: !0, subtree: !0 }); } },
                create: {
                    id() { y = (`${Math.random().toString(16)}000000000`).substr(2, 8), b = `.${y}`, w.verbose('Creating unique id for element', y); },
                    userChoice(t) {
                        let n; let i; let o; return !!(t = t || w.get.userValues()) && (t = e.isArray(t) ? t : [t], e.each(t, function(t, a) {
                            !1 === w.get.item(a) && (o = k.templates.addition(w.add.variables(T.addResult, a)), i = e('<div />').html(o).attr(`data-${P.value}`, a).attr(`data-${P.text}`, a)
                                .addClass(S.addition)
                                .addClass(S.item), k.hideAdditions && i.addClass(S.hidden), n = void 0 === n ? i : n.add(i), w.verbose('Creating user choices for value', a, i));
                        }), n);
                    },
                    userLabels(t) { const n = w.get.userValues(); n && (w.debug('Adding user labels', n), e.each(n, function(e, t) { w.verbose('Adding custom user value'), w.add.label(t, t); })); },
                    menu() { B = e('<div />').addClass(S.menu).appendTo(I); },
                    sizer() { N = e('<span />').addClass(S.sizer).insertAfter(V); },
                },
                search(e) { e = void 0 !== e ? e : w.get.query(), w.verbose('Searching for query', e), w.has.minCharacters(e) ? w.filter(e) : w.hide(); },
                select: { firstUnfiltered() { w.verbose('Selecting first non-filtered element'), w.remove.selectedItem(), Q.not(O.unselectable).not(O.addition + O.hidden).eq(0).addClass(S.selected); }, nextAvailable(e) { e = e.eq(0); const t = e.nextAll(O.item).not(O.unselectable).eq(0); const n = e.prevAll(O.item).not(O.unselectable).eq(0); t.length > 0 ? (w.verbose('Moving selection to', t), t.addClass(S.selected)) : (w.verbose('Moving selection to', n), n.addClass(S.selected)); } },
                setup: {
                    api() { const e = { debug: k.debug, urlData: { value: w.get.value(), query: w.get.query() }, on: !1 }; w.verbose('First request, initializing API'), I.api(e); },
                    layout() { I.is('select') && (w.setup.select(), w.setup.returnedObject()), w.has.menu() || w.create.menu(), w.is.search() && !w.has.search() && (w.verbose('Adding search input'), V = e('<input />').addClass(S.search).prop('autocomplete', 'off').insertBefore(L)), w.is.multiple() && w.is.searchSelection() && !w.has.sizer() && w.create.sizer(), k.allowTab && w.set.tabbable(); },
                    select() {
                        const t = w.get.selectValues(); w.debug('Dropdown initialized on a select', t), I.is('select') && (H = I), H.parent(O.dropdown).length > 0 ? (w.debug('UI dropdown already exists. Creating dropdown menu only'), I = H.closest(O.dropdown), w.has.menu() || w.create.menu(), B = I.children(O.menu), w.setup.menu(t)) : (w.debug('Creating entire dropdown from select'), I = e('<div />').attr('class', H.attr('class')).addClass(S.selection).addClass(S.dropdown)
                            .html(q.dropdown(t))
                            .insertBefore(H), H.hasClass(S.multiple) && !1 === H.prop('multiple') && (w.error(D.missingMultiple), H.prop('multiple', !0)), H.is('[multiple]') && w.set.multiple(), H.prop('disabled') && (w.debug('Disabling dropdown'), I.addClass(S.disabled)), H.removeAttr('class').detach().prependTo(I)), w.refresh();
                    },
                    menu(e) { B.html(q.menu(e, A)), Q = B.find(O.item); },
                    reference() { w.debug('Dropdown behavior was called on select, replacing with closest dropdown'), I = I.parent(O.dropdown), K = I.data(z), Z = I.get(0), w.refresh(), w.setup.returnedObject(); },
                    returnedObject() { const e = a.slice(0, g); const t = a.slice(g + 1); a = e.add(I).add(t); },
                },
                refresh() { w.refreshSelectors(), w.refreshData(); },
                refreshItems() { Q = B.find(O.item); },
                refreshSelectors() { w.verbose('Refreshing selector cache'), L = I.find(O.text), V = I.find(O.search), H = I.find(O.input), U = I.find(O.icon), W = I.prev().find(O.text).length > 0 ? I.prev().find(O.text) : I.prev(), B = I.children(O.menu), Q = B.find(O.item); },
                refreshData() { w.verbose('Refreshing cached metadata'), Q.removeData(P.text).removeData(P.value); },
                clearData() { w.verbose('Clearing metadata'), Q.removeData(P.text).removeData(P.value), I.removeData(P.defaultText).removeData(P.defaultValue).removeData(P.placeholderText); },
                toggle() { w.verbose('Toggling menu visibility'), w.is.active() ? w.hide() : w.show(); },
                show(t) { if (t = e.isFunction(t) ? t : function() {}, !w.can.show() && w.is.remote() && (w.debug('No API results retrieved, searching before show'), w.queryRemote(w.get.query(), w.show)), w.can.show() && !w.is.active()) { if (w.debug('Showing dropdown'), !w.has.message() || w.has.maxSelections() || w.has.allResultsFiltered() || w.remove.message(), w.is.allFiltered()) return !0; !1 !== k.onShow.call(Z) && w.animate.show(function() { w.can.click() && w.bind.intent(), w.has.menuSearch() && w.focusSearch(), w.set.visible(), t.call(Z); }); } },
                hide(t) { t = e.isFunction(t) ? t : function() {}, w.is.active() && (w.debug('Hiding dropdown'), !1 !== k.onHide.call(Z) && w.animate.hide(function() { w.remove.visible(), t.call(Z); })); },
                hideOthers() { w.verbose('Finding other dropdowns to hide'), a.not(I).has(`${O.menu}.${S.visible}`).dropdown('hide'); },
                hideMenu() { w.verbose('Hiding menu  instantaneously'), w.remove.active(), w.remove.visible(), B.transition('hide'); },
                hideSubMenus() { const e = B.children(O.item).find(O.menu); w.verbose('Hiding sub menus', e), e.transition('hide'); },
                bind: {
                    events() { l && w.bind.touchEvents(), w.bind.keyboardEvents(), w.bind.inputEvents(), w.bind.mouseEvents(); },
                    touchEvents() { w.debug('Touch device detected binding additional touch events'), w.is.searchSelection() || w.is.single() && I.on(`touchstart${j}`, w.event.test.toggle), B.on(`touchstart${j}`, O.item, w.event.item.mouseenter); },
                    keyboardEvents() { w.verbose('Binding keyboard events'), I.on(`keydown${j}`, w.event.keydown), w.has.search() && I.on(w.get.inputEvent() + j, O.search, w.event.input), w.is.multiple() && r.on(`keydown${b}`, w.event.document.keydown); },
                    inputEvents() { w.verbose('Binding input change events'), I.on(`change${j}`, O.input, w.event.change); },
                    mouseEvents() {
                        w.verbose('Binding mouse events'), w.is.multiple() && I.on(`click${j}`, O.label, w.event.label.click).on(`click${j}`, O.remove, w.event.remove.click), w.is.searchSelection() ? (I.on(`mousedown${j}`, w.event.mousedown).on(`mouseup${j}`, w.event.mouseup).on(`mousedown${j}`, O.menu, w.event.menu.mousedown).on(`mouseup${j}`, O.menu, w.event.menu.mouseup)
                            .on(`click${j}`, O.icon, w.event.icon.click)
                            .on(`focus${j}`, O.search, w.event.search.focus)
                            .on(`click${j}`, O.search, w.event.search.focus)
                            .on(`blur${j}`, O.search, w.event.search.blur)
                            .on(`click${j}`, O.text, w.event.text.focus), w.is.multiple() && I.on(`click${j}`, w.event.click)) : (k.on == 'click' ? I.on(`click${j}`, O.icon, w.event.icon.click).on(`click${j}`, w.event.test.toggle) : k.on == 'hover' ? I.on(`mouseenter${j}`, w.delay.show).on(`mouseleave${j}`, w.delay.hide) : I.on(k.on + j, w.toggle), I.on(`mousedown${j}`, w.event.mousedown).on(`mouseup${j}`, w.event.mouseup).on(`focus${j}`, w.event.focus), w.has.menuSearch() ? I.on(`blur${j}`, O.search, w.event.search.blur) : I.on(`blur${j}`, w.event.blur)), B.on(`mouseenter${j}`, O.item, w.event.item.mouseenter).on(`mouseleave${j}`, O.item, w.event.item.mouseleave).on(`click${j}`, O.item, w.event.item.click);
                    },
                    intent() { w.verbose('Binding hide intent event to document'), l && r.on(`touchstart${b}`, w.event.test.touch).on(`touchmove${b}`, w.event.test.touch), r.on(`click${b}`, w.event.test.hide); },
                },
                unbind: { intent() { w.verbose('Removing hide intent event from document'), l && r.off(`touchstart${b}`).off(`touchmove${b}`), r.off(`click${b}`); } },
                filter(e) { const t = void 0 !== e ? e : w.get.query(); const n = function() { w.is.multiple() && w.filterActive(), (e || !e && w.get.activeItem().length == 0) && w.select.firstUnfiltered(), w.has.allResultsFiltered() ? k.onNoResults.call(Z, t) ? k.allowAdditions ? k.hideAdditions && (w.verbose('User addition with no menu, setting empty style'), w.set.empty(), w.hideMenu()) : (w.verbose('All items filtered, showing message', t), w.add.message(T.noResults)) : (w.verbose('All items filtered, hiding dropdown', t), w.hideMenu()) : (w.remove.empty(), w.remove.message()), k.allowAdditions && w.add.userSuggestion(e), w.is.searchSelection() && w.can.show() && w.is.focusedOnSearch() && w.show(); }; k.useLabels && w.has.maxSelections() || (k.apiSettings ? w.can.useAPI() ? w.queryRemote(t, function() { k.filterRemoteData && w.filterItems(t), n(); }) : w.error(D.noAPI) : (w.filterItems(t), n())); },
                queryRemote(t, n) {
                    let i = {
                        errorDuration: !1, cache: 'local', throttle: k.throttle, urlData: { query: t }, onError() { w.add.message(T.serverError), n(); }, onFailure() { w.add.message(T.serverError), n(); }, onSuccess(e) { w.remove.message(), w.setup.menu({ values: e[A.remoteValues] }), n(); },
                    }; I.api('get request') || w.setup.api(), i = e.extend(!0, {}, i, k.apiSettings), I.api('setting', i).api('query');
                },
                filterItems(t) {
                    const n = void 0 !== t ? t : w.get.query(); let i = null; const o = w.escape.string(n); const a = new RegExp(`^${o}`, 'igm'); w.has.query() && (i = [], w.verbose('Searching for matching values', n), Q.each(function() {
                        let t; let o; const r = e(this); if (k.match == 'both' || k.match == 'text') {
                            if (t = String(w.get.choiceText(r, !1)), t.search(a) !== -1) return i.push(this), !0; if (k.fullTextSearch === 'exact' && w.exactSearch(n, t)) return i.push(this), !0; if (!0 === k.fullTextSearch && w.fuzzySearch(n, t)) return i.push(this), !0;
                        } if (k.match == 'both' || k.match == 'value') { if (o = String(w.get.choiceValue(r, t)), o.search(a) !== -1) return i.push(this), !0; if (k.fullTextSearch === 'exact' && w.exactSearch(n, o)) return i.push(this), !0; if (!0 === k.fullTextSearch && w.fuzzySearch(n, o)) return i.push(this), !0; }
                    })), w.debug('Showing only matched items', n), w.remove.filteredItem(), i && Q.not(i).addClass(S.filtered);
                },
                fuzzySearch(e, t) { const n = t.length; const i = e.length; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; o < i; o++) { for (let r = e.charCodeAt(o); a < n;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0; },
                exactSearch(e, t) { return e = e.toLowerCase(), t = t.toLowerCase(), t.indexOf(e) > -1; },
                filterActive() { k.useLabels && Q.filter(`.${S.active}`).addClass(S.filtered); },
                focusSearch(e) { w.has.search() && !w.is.focusedOnSearch() && (e ? (I.off(`focus${j}`, O.search), V.focus(), I.on(`focus${j}`, O.search, w.event.search.focus)) : V.focus()); },
                forceSelection() { const e = Q.not(S.filtered).filter(`.${S.selected}`).eq(0); const t = Q.not(S.filtered).filter(`.${S.active}`).eq(0); const n = e.length > 0 ? e : t; if (n.length > 0 && !w.is.multiple()) return w.debug('Forcing partial selection to selected item', n), void w.event.item.click.call(n, {}, !0); k.allowAdditions ? (w.set.selected(w.get.query()), w.remove.searchTerm()) : w.remove.searchTerm(); },
                change: { values(t) { k.allowAdditions || w.clear(), w.debug('Creating dropdown with specified values', t), w.setup.menu({ values: t }), e.each(t, function(e, t) { if (t.selected == 1) return w.debug('Setting initial selection to', t.value), w.set.selected(t.value), !0; }); } },
                event: {
                    change() { Y || (w.debug('Input changed, updating selection'), w.set.selected()); }, focus() { k.showOnFocus && !X && w.is.hidden() && !p && w.show(); }, blur(e) { p = n.activeElement === this, X || p || (w.remove.activeLabel(), w.hide()); }, mousedown() { w.is.searchSelection() ? h = !0 : X = !0; }, mouseup() { w.is.searchSelection() ? h = !1 : X = !1; }, click(t) { e(t.target).is(I) && (w.is.focusedOnSearch() ? w.show() : w.focusSearch()); }, search: { focus() { X = !0, w.is.multiple() && w.remove.activeLabel(), k.showOnFocus && w.search(); }, blur(e) { p = n.activeElement === this, w.is.searchSelection() && !h && ($ || p || (k.forceSelection && w.forceSelection(), w.hide())), h = !1; } }, icon: { click(e) { w.toggle(); } }, text: { focus(e) { X = !0, w.focusSearch(); } }, input(e) { (w.is.multiple() || w.is.searchSelection()) && w.set.filtered(), clearTimeout(w.timer), w.timer = setTimeout(w.search, k.delay.search); }, label: { click(t) { const n = e(this); const i = I.find(O.label); const o = i.filter(`.${S.active}`); const a = n.nextAll(`.${S.active}`); const r = n.prevAll(`.${S.active}`); const s = a.length > 0 ? n.nextUntil(a).add(o).add(n) : n.prevUntil(r).add(o).add(n); t.shiftKey ? (o.removeClass(S.active), s.addClass(S.active)) : t.ctrlKey ? n.toggleClass(S.active) : (o.removeClass(S.active), n.addClass(S.active)), k.onLabelSelect.apply(this, i.filter(`.${S.active}`)); } }, remove: { click() { const t = e(this).parent(); t.hasClass(S.active) ? w.remove.activeLabels() : w.remove.activeLabels(t); } }, test: { toggle(e) { const t = w.is.multiple() ? w.show : w.toggle; w.is.bubbledLabelClick(e) || w.is.bubbledIconClick(e) || w.determine.eventOnElement(e, t) && e.preventDefault(); }, touch(e) { w.determine.eventOnElement(e, function() { e.type == 'touchstart' ? w.timer = setTimeout(function() { w.hide(); }, k.delay.touch) : e.type == 'touchmove' && clearTimeout(w.timer); }), e.stopPropagation(); }, hide(e) { w.determine.eventInModule(e, w.hide); } }, select: { mutation(t) { w.debug('<select> modified, recreating menu'); let n = !1; e.each(t, function(t, i) { if (e(i.target).is('select') || e(i.addedNodes).is('select')) return n = !0, !0; }), n && (w.disconnect.selectObserver(), w.refresh(), w.setup.select(), w.set.selected(), w.observe.select()); } }, menu: { mutation(t) { const n = t[0]; const i = e(n.addedNodes ? n.addedNodes[0] : !1); const o = e(n.removedNodes ? n.removedNodes[0] : !1); const a = i.add(o); const r = a.is(O.addition) || a.closest(O.addition).length > 0; const s = a.is(O.message) || a.closest(O.message).length > 0; r || s ? (w.debug('Updating item selector cache'), w.refreshItems()) : (w.debug('Menu modified, updating selector cache'), w.refresh()); }, mousedown() { $ = !0; }, mouseup() { $ = !1; } }, item: { mouseenter(t) { const n = e(t.target); const i = e(this); const o = i.children(O.menu); const a = i.siblings(O.item).children(O.menu); const r = o.length > 0; !(o.find(n).length > 0) && r && (clearTimeout(w.itemTimer), w.itemTimer = setTimeout(function() { w.verbose('Showing sub-menu', o), e.each(a, function() { w.animate.hide(!1, e(this)); }), w.animate.show(!1, o); }, k.delay.show), t.preventDefault()); }, mouseleave(t) { const n = e(this).children(O.menu); n.length > 0 && (clearTimeout(w.itemTimer), w.itemTimer = setTimeout(function() { w.verbose('Hiding sub-menu', n), w.animate.hide(!1, n); }, k.delay.hide)); }, click(t, i) { const o = e(this); const a = e(t ? t.target : ''); const r = o.find(O.menu); const s = w.get.choiceText(o); const l = w.get.choiceValue(o, s); const c = r.length > 0; const u = r.find(a).length > 0; w.has.menuSearch() && e(n.activeElement).blur(), u || c && !k.allowCategorySelection || (w.is.searchSelection() && (k.allowAdditions && w.remove.userAddition(), w.remove.searchTerm(), w.is.focusedOnSearch() || i == 1 || w.focusSearch(!0)), k.useLabels || (w.remove.filteredItem(), w.set.scrollPosition(o)), w.determine.selectAction.call(this, s, l)); } }, document: { keydown(e) { const t = e.which; if (w.is.inObject(t, R)) { const n = I.find(O.label); let i = n.filter(`.${S.active}`); const o = (i.data(P.value), n.index(i)); const a = n.length; const r = i.length > 0; const s = i.length > 1; const l = o === 0; const c = o + 1 == a; const u = w.is.searchSelection(); const d = w.is.focusedOnSearch(); const f = w.is.focused(); const m = d && w.get.caretPosition() === 0; if (u && !r && !d) return; t == R.leftArrow ? !f && !m || r ? r && (e.shiftKey ? w.verbose('Adding previous label to selection') : (w.verbose('Selecting previous label'), n.removeClass(S.active)), l && !s ? i.addClass(S.active) : i.prev(O.siblingLabel).addClass(S.active).end(), e.preventDefault()) : (w.verbose('Selecting previous label'), n.last().addClass(S.active)) : t == R.rightArrow ? (f && !r && n.first().addClass(S.active), r && (e.shiftKey ? w.verbose('Adding next label to selection') : (w.verbose('Selecting next label'), n.removeClass(S.active)), c ? u ? d ? n.removeClass(S.active) : w.focusSearch() : s ? i.next(O.siblingLabel).addClass(S.active) : i.addClass(S.active) : i.next(O.siblingLabel).addClass(S.active), e.preventDefault())) : t == R.deleteKey || t == R.backspace ? r ? (w.verbose('Removing active labels'), c && u && !d && w.focusSearch(), i.last().next(O.siblingLabel).addClass(S.active), w.remove.activeLabels(i), e.preventDefault()) : m && !r && t == R.backspace && (w.verbose('Removing last label on input backspace'), i = n.last().addClass(S.active), w.remove.activeLabels(i)) : i.removeClass(S.active); } } }, keydown(e) { let t = e.which; if (w.is.inObject(t, R)) { let n; const i = Q.not(O.unselectable).filter(`.${S.selected}`).eq(0); const o = B.children(`.${S.active}`).eq(0); const a = i.length > 0 ? i : o; const r = a.length > 0 ? a.siblings(`:not(.${S.filtered})`).addBack() : B.children(`:not(.${S.filtered})`); const s = a.children(O.menu); const l = a.closest(O.menu); const c = l.hasClass(S.visible) || l.hasClass(S.animating) || l.parent(O.menu).length > 0; const u = s.length > 0; const d = a.length > 0; const f = a.not(O.unselectable).length > 0; const m = t == R.delimiter && k.allowAdditions && w.is.multiple(); const g = k.allowAdditions && k.hideAdditions && (t == R.enter || m) && f; if (g && (w.verbose('Selecting item from keyboard shortcut', a), w.event.item.click.call(a, e), w.is.searchSelection() && w.remove.searchTerm()), w.is.visible()) { if ((t == R.enter || m) && (t == R.enter && d && u && !k.allowCategorySelection ? (w.verbose('Pressed enter on unselectable category, opening sub menu'), t = R.rightArrow) : f && (w.verbose('Selecting item from keyboard shortcut', a), w.event.item.click.call(a, e), w.is.searchSelection() && w.remove.searchTerm()), e.preventDefault()), d && (t == R.leftArrow && l[0] !== B[0] && (w.verbose('Left key pressed, closing sub-menu'), w.animate.hide(!1, l), a.removeClass(S.selected), l.closest(O.item).addClass(S.selected), e.preventDefault()), t == R.rightArrow && u && (w.verbose('Right key pressed, opening sub-menu'), w.animate.show(!1, s), a.removeClass(S.selected), s.find(O.item).eq(0).addClass(S.selected), e.preventDefault())), t == R.upArrow) { if (n = d && c ? a.prevAll(`${O.item}:not(${O.unselectable})`).eq(0) : Q.eq(0), r.index(n) < 0) return w.verbose('Up key pressed but reached top of current menu'), void e.preventDefault(); w.verbose('Up key pressed, changing active item'), a.removeClass(S.selected), n.addClass(S.selected), w.set.scrollPosition(n), k.selectOnKeydown && w.is.single() && w.set.selectedItem(n), e.preventDefault(); } if (t == R.downArrow) { if (n = d && c ? n = a.nextAll(`${O.item}:not(${O.unselectable})`).eq(0) : Q.eq(0), n.length === 0) return w.verbose('Down key pressed but reached bottom of current menu'), void e.preventDefault(); w.verbose('Down key pressed, changing active item'), Q.removeClass(S.selected), n.addClass(S.selected), w.set.scrollPosition(n), k.selectOnKeydown && w.is.single() && w.set.selectedItem(n), e.preventDefault(); }t == R.pageUp && (w.scrollPage('up'), e.preventDefault()), t == R.pageDown && (w.scrollPage('down'), e.preventDefault()), t == R.escape && (w.verbose('Escape key pressed, closing dropdown'), w.hide()); } else m && e.preventDefault(), t != R.downArrow || w.is.visible() || (w.verbose('Down key pressed, showing dropdown'), w.show(), e.preventDefault()); } else w.has.search() || w.set.selectedLetter(String.fromCharCode(t)); },
                },
                trigger: { change() { const e = n.createEvent('HTMLEvents'); const t = H[0]; t && (w.verbose('Triggering native change event'), e.initEvent('change', !0, !1), t.dispatchEvent(e)); } },
                determine: { selectAction(t, n) { w.verbose('Determining action', k.action), e.isFunction(w.action[k.action]) ? (w.verbose('Triggering preset action', k.action, t, n), w.action[k.action].call(Z, t, n, this)) : e.isFunction(k.action) ? (w.verbose('Triggering user action', k.action, t, n), k.action.call(Z, t, n, this)) : w.error(D.action, k.action); }, eventInModule(t, i) { const o = e(t.target); const a = o.closest(n.documentElement).length > 0; const r = o.closest(I).length > 0; return i = e.isFunction(i) ? i : function() {}, a && !r ? (w.verbose('Triggering event', i), i(), !0) : (w.verbose('Event occurred in dropdown, canceling callback'), !1); }, eventOnElement(t, i) { const o = e(t.target); const a = o.closest(O.siblingLabel); const r = n.body.contains(t.target); const s = I.find(a).length === 0; const l = o.closest(B).length === 0; return i = e.isFunction(i) ? i : function() {}, r && s && l ? (w.verbose('Triggering event', i), i(), !0) : (w.verbose('Event occurred in dropdown menu, canceling callback'), !1); } },
                action: {
                    nothing() {}, activate(t, n, i) { if (n = void 0 !== n ? n : t, w.can.activate(e(i))) { if (w.set.selected(n, e(i)), w.is.multiple() && !w.is.allFiltered()) return; w.hideAndClear(); } }, select(t, n, i) { if (n = void 0 !== n ? n : t, w.can.activate(e(i))) { if (w.set.value(n, e(i)), w.is.multiple() && !w.is.allFiltered()) return; w.hideAndClear(); } }, combo(t, n, i) { n = void 0 !== n ? n : t, w.set.selected(n, e(i)), w.hideAndClear(); }, hide(e, t, n) { w.set.value(t, e), w.hideAndClear(); },
                },
                get: {
                    id() { return y; }, defaultText() { return I.data(P.defaultText); }, defaultValue() { return I.data(P.defaultValue); }, placeholderText() { return k.placeholder != 'auto' && typeof k.placeholder === 'string' ? k.placeholder : I.data(P.placeholderText) || ''; }, text() { return L.text(); }, query() { return e.trim(V.val()); }, searchWidth(e) { return e = void 0 !== e ? e : V.val(), N.text(e), Math.ceil(N.width() + 1); }, selectionCount() { const t = w.get.values(); return w.is.multiple() ? e.isArray(t) ? t.length : 0 : w.get.value() !== '' ? 1 : 0; }, transition(e) { return k.transition == 'auto' ? w.is.upward(e) ? 'slide up' : 'slide down' : k.transition; }, userValues() { let t = w.get.values(); return !!t && (t = e.isArray(t) ? t : [t], e.grep(t, function(e) { return !1 === w.get.item(e); })); }, uniqueArray(t) { return e.grep(t, function(n, i) { return e.inArray(n, t) === i; }); }, caretPosition() { let e; let t; const i = V.get(0); return 'selectionStart' in i ? i.selectionStart : n.selection ? (i.focus(), e = n.selection.createRange(), t = e.text.length, e.moveStart('character', -i.value.length), e.text.length - t) : void 0; }, value() { const t = H.length > 0 ? H.val() : I.data(P.value); const n = e.isArray(t) && t.length === 1 && t[0] === ''; return void 0 === t || n ? '' : t; }, values() { const e = w.get.value(); return e === '' ? '' : !w.has.selectInput() && w.is.multiple() ? typeof e === 'string' ? e.split(k.delimiter) : '' : e; }, remoteValues() { let t = w.get.values(); let n = !1; return t && (typeof t === 'string' && (t = [t]), e.each(t, function(e, t) { const i = w.read.remoteData(t); w.verbose('Restoring value from session data', i, t), i && (n || (n = {}), n[t] = i); })), n; }, choiceText(t, n) { if (n = void 0 !== n ? n : k.preserveHTML, t) return t.find(O.menu).length > 0 && (w.verbose('Retrieving text of element with sub-menu'), t = t.clone(), t.find(O.menu).remove(), t.find(O.menuIcon).remove()), void 0 !== t.data(P.text) ? t.data(P.text) : n ? e.trim(t.html()) : e.trim(t.text()); }, choiceValue(t, n) { return n = n || w.get.choiceText(t), !!t && (void 0 !== t.data(P.value) ? String(t.data(P.value)) : typeof n === 'string' ? e.trim(n.toLowerCase()) : String(n)); }, inputEvent() { const e = V[0]; return !!e && (void 0 !== e.oninput ? 'input' : void 0 !== e.onpropertychange ? 'propertychange' : 'keyup'); }, selectValues() { const t = {}; return t.values = [], I.find('option').each(function() { const n = e(this); const i = n.html(); const o = n.attr('disabled'); const a = void 0 !== n.attr('value') ? n.attr('value') : i; k.placeholder === 'auto' && a === '' ? t.placeholder = i : t.values.push({ name: i, value: a, disabled: o }); }), k.placeholder && k.placeholder !== 'auto' && (w.debug('Setting placeholder value to', k.placeholder), t.placeholder = k.placeholder), k.sortSelect ? (t.values.sort(function(e, t) { return e.name > t.name ? 1 : -1; }), w.debug('Retrieved and sorted values from select', t)) : w.debug('Retrieved values from select', t), t; }, activeItem() { return Q.filter(`.${S.active}`); }, selectedItem() { const e = Q.not(O.unselectable).filter(`.${S.selected}`); return e.length > 0 ? e : Q.eq(0); }, itemWithAdditions(e) { let t = w.get.item(e); const n = w.create.userChoice(e); return n && n.length > 0 && (t = t.length > 0 ? t.add(n) : n), t; }, item(t, n) { let i; let o; let a = !1; return t = void 0 !== t ? t : void 0 !== w.get.values() ? w.get.values() : w.get.text(), i = o ? t.length > 0 : void 0 !== t && t !== null, o = w.is.multiple() && e.isArray(t), n = t === '' || t === 0 || (n || !1), i && Q.each(function() { const i = e(this); const r = w.get.choiceText(i); const s = w.get.choiceValue(i, r); if (s !== null && void 0 !== s) if (o)e.inArray(String(s), t) === -1 && e.inArray(r, t) === -1 || (a = a ? a.add(i) : i); else if (n) { if (w.verbose('Ambiguous dropdown value using strict type check', i, t), s === t || r === t) return a = i, !0; } else if (String(s) == String(t) || r == t) return w.verbose('Found select item by value', s, t), a = i, !0; }), a; },
                },
                check: { maxSelections(e) { return !k.maxSelections || (e = void 0 !== e ? e : w.get.selectionCount(), e >= k.maxSelections ? (w.debug('Maximum selection count reached'), k.useLabels && (Q.addClass(S.filtered), w.add.message(T.maxSelections)), !0) : (w.verbose('No longer at maximum selection count'), w.remove.message(), w.remove.filteredItem(), w.is.searchSelection() && w.filterItems(), !1)); } },
                restore: {
                    defaults() { w.clear(), w.restore.defaultText(), w.restore.defaultValue(); }, defaultText() { const e = w.get.defaultText(); e === w.get.placeholderText ? (w.debug('Restoring default placeholder text', e), w.set.placeholderText(e)) : (w.debug('Restoring default text', e), w.set.text(e)); }, placeholderText() { w.set.placeholderText(); }, defaultValue() { const e = w.get.defaultValue(); void 0 !== e && (w.debug('Restoring default value', e), e !== '' ? (w.set.value(e), w.set.selected()) : (w.remove.activeItem(), w.remove.selectedItem())); }, labels() { k.allowAdditions && (k.useLabels || (w.error(D.labels), k.useLabels = !0), w.debug('Restoring selected values'), w.create.userLabels()), w.check.maxSelections(); }, selected() { w.restore.values(), w.is.multiple() ? (w.debug('Restoring previously selected values and labels'), w.restore.labels()) : w.debug('Restoring previously selected values'); }, values() { w.set.initialLoad(), k.apiSettings && k.saveRemoteData && w.get.remoteValues() ? w.restore.remoteValues() : w.set.selected(), w.remove.initialLoad(); }, remoteValues() { const t = w.get.remoteValues(); w.debug('Recreating selected from session data', t), t && (w.is.single() ? e.each(t, function(e, t) { w.set.text(t); }) : e.each(t, function(e, t) { w.add.label(e, t); })); },
                },
                read: { remoteData(e) { let n; return void 0 === t.Storage ? void w.error(D.noStorage) : void 0 !== (n = sessionStorage.getItem(e)) && n; } },
                save: {
                    defaults() { w.save.defaultText(), w.save.placeholderText(), w.save.defaultValue(); }, defaultValue() { const e = w.get.value(); w.verbose('Saving default value as', e), I.data(P.defaultValue, e); }, defaultText() { const e = w.get.text(); w.verbose('Saving default text as', e), I.data(P.defaultText, e); }, placeholderText() { let e; !1 !== k.placeholder && L.hasClass(S.placeholder) && (e = w.get.text(), w.verbose('Saving placeholder text as', e), I.data(P.placeholderText, e)); }, remoteData(e, n) { if (void 0 === t.Storage) return void w.error(D.noStorage); w.verbose('Saving remote data to session storage', n, e), sessionStorage.setItem(n, e); },
                },
                clear() { w.is.multiple() && k.useLabels ? w.remove.labels() : (w.remove.activeItem(), w.remove.selectedItem()), w.set.placeholderText(), w.clearValue(); },
                clearValue() { w.set.value(''); },
                scrollPage(e, t) { let n; let i; let o; const a = t || w.get.selectedItem(); const r = a.closest(O.menu); const s = r.outerHeight(); const l = r.scrollTop(); const c = Q.eq(0).outerHeight(); const u = Math.floor(s / c); const d = (r.prop('scrollHeight'), e == 'up' ? l - c * u : l + c * u); const f = Q.not(O.unselectable); o = e == 'up' ? f.index(a) - u : f.index(a) + u, n = e == 'up' ? o >= 0 : o < f.length, i = n ? f.eq(o) : e == 'up' ? f.first() : f.last(), i.length > 0 && (w.debug('Scrolling page', e, i), a.removeClass(S.selected), i.addClass(S.selected), k.selectOnKeydown && w.is.single() && w.set.selectedItem(i), r.scrollTop(d)); },
                set: {
                    filtered() { const e = w.is.multiple(); const t = w.is.searchSelection(); const n = e && t; const i = t ? w.get.query() : ''; const o = typeof i === 'string' && i.length > 0; const a = w.get.searchWidth(); const r = i !== ''; e && o && (w.verbose('Adjusting input width', a, k.glyphWidth), V.css('width', a)), o || n && r ? (w.verbose('Hiding placeholder text'), L.addClass(S.filtered)) : (!e || n && !r) && (w.verbose('Showing placeholder text'), L.removeClass(S.filtered)); }, empty() { I.addClass(S.empty); }, loading() { I.addClass(S.loading); }, placeholderText(e) { e = e || w.get.placeholderText(), w.debug('Setting placeholder text', e), w.set.text(e), L.addClass(S.placeholder); }, tabbable() { w.is.searchSelection() ? (w.debug('Added tabindex to searchable dropdown'), V.val('').attr('tabindex', 0), B.attr('tabindex', -1)) : (w.debug('Added tabindex to dropdown'), void 0 === I.attr('tabindex') && (I.attr('tabindex', 0), B.attr('tabindex', -1))); }, initialLoad() { w.verbose('Setting initial load'), v = !0; }, activeItem(e) { k.allowAdditions && e.filter(O.addition).length > 0 ? e.addClass(S.filtered) : e.addClass(S.active); }, partialSearch(e) { const t = w.get.query().length; V.val(e.substr(0, t)); }, scrollPosition(e, t) { let n; let i; let o; let a; let r; let s; let l; let c; let u; e = e || w.get.selectedItem(), n = e.closest(O.menu), i = e && e.length > 0, t = void 0 !== t && t, e && n.length > 0 && i && (a = e.position().top, n.addClass(S.loading), s = n.scrollTop(), r = n.offset().top, a = e.offset().top, o = s - r + a, t || (l = n.height(), u = s + l < o + 5, c = o - 5 < s), w.debug('Scrolling to active item', o), (t || c || u) && n.scrollTop(o), n.removeClass(S.loading)); }, text(e) { k.action !== 'select' && (k.action == 'combo' ? (w.debug('Changing combo button text', e, W), k.preserveHTML ? W.html(e) : W.text(e)) : (e !== w.get.placeholderText() && L.removeClass(S.placeholder), w.debug('Changing text', e, L), L.removeClass(S.filtered), k.preserveHTML ? L.html(e) : L.text(e))); }, selectedItem(e) { const t = w.get.choiceValue(e); const n = w.get.choiceText(e, !1); const i = w.get.choiceText(e, !0); w.debug('Setting user selection to item', e), w.remove.activeItem(), w.set.partialSearch(n), w.set.activeItem(e), w.set.selected(t, e), w.set.text(i); }, selectedLetter(t) { let n; const i = Q.filter(`.${S.selected}`); const o = i.length > 0 && w.has.firstLetter(i, t); let a = !1; o && (n = i.nextAll(Q).eq(0), w.has.firstLetter(n, t) && (a = n)), a || Q.each(function() { if (w.has.firstLetter(e(this), t)) return a = e(this), !1; }), a && (w.verbose('Scrolling to next value with letter', t), w.set.scrollPosition(a), i.removeClass(S.selected), a.addClass(S.selected), k.selectOnKeydown && w.is.single() && w.set.selectedItem(a)); }, direction(e) { k.direction == 'auto' ? (w.remove.upward(), w.can.openDownward(e) ? w.remove.upward(e) : w.set.upward(e), w.is.leftward(e) || w.can.openRightward(e) || w.set.leftward(e)) : k.direction == 'upward' && w.set.upward(e); }, upward(e) { (e || I).addClass(S.upward); }, leftward(e) { (e || B).addClass(S.leftward); }, value(e, t, n) { const i = w.escape.value(e); const o = H.length > 0; const a = (w.has.value(e), w.get.values()); const r = void 0 !== e ? String(e) : e; if (o) { if (!k.allowReselection && r == a && (w.verbose('Skipping value update already same value', e, a), !w.is.initialLoad())) return; w.is.single() && w.has.selectInput() && w.can.extendSelect() && (w.debug('Adding user option', e), w.add.optionValue(e)), w.debug('Updating input value', i, a), Y = !0, H.val(i), !1 === k.fireOnInit && w.is.initialLoad() ? w.debug('Input native change event ignored on initial load') : w.trigger.change(), Y = !1; } else w.verbose('Storing value in metadata', i, H), i !== a && I.data(P.value, r); !1 === k.fireOnInit && w.is.initialLoad() ? w.verbose('No callback on initial load', k.onChange) : k.onChange.call(Z, e, t, n); }, active() { I.addClass(S.active); }, multiple() { I.addClass(S.multiple); }, visible() { I.addClass(S.visible); }, exactly(e, t) { w.debug('Setting selected to exact values'), w.clear(), w.set.selected(e, t); }, selected(t, n) { const i = w.is.multiple(); (n = k.allowAdditions ? n || w.get.itemWithAdditions(t) : n || w.get.item(t)) && (w.debug('Setting selected menu item to', n), w.is.multiple() && w.remove.searchWidth(), w.is.single() ? (w.remove.activeItem(), w.remove.selectedItem()) : k.useLabels && w.remove.selectedItem(), n.each(function() { const t = e(this); const o = w.get.choiceText(t); const a = w.get.choiceValue(t, o); const r = t.hasClass(S.filtered); const s = t.hasClass(S.active); const l = t.hasClass(S.addition); const c = i && n.length == 1; i ? !s || l ? (k.apiSettings && k.saveRemoteData && w.save.remoteData(o, a), k.useLabels ? (w.add.value(a, o, t), w.add.label(a, o, c), w.set.activeItem(t), w.filterActive(), w.select.nextAvailable(n)) : (w.add.value(a, o, t), w.set.text(w.add.variables(T.count)), w.set.activeItem(t))) : r || (w.debug('Selected active value, removing label'), w.remove.selected(a)) : (k.apiSettings && k.saveRemoteData && w.save.remoteData(o, a), w.set.text(o), w.set.value(a, o, t), t.addClass(S.active).addClass(S.selected)); })); },
                },
                add: {
                    label(t, n, i) { let o; const a = w.is.searchSelection() ? V : L; const r = w.escape.value(t); if (o = e('<a />').addClass(S.label).attr(`data-${P.value}`, r).html(q.label(r, n)), o = k.onLabelCreate.call(o, r, n), w.has.label(t)) return void w.debug('Label already exists, skipping', r); k.label.variation && o.addClass(k.label.variation), !0 === i ? (w.debug('Animating in label', o), o.addClass(S.hidden).insertBefore(a).transition(k.label.transition, k.label.duration)) : (w.debug('Adding selection label', o), o.insertBefore(a)); },
                    message(t) { let n = B.children(O.message); const i = k.templates.message(w.add.variables(t)); n.length > 0 ? n.html(i) : n = e('<div/>').html(i).addClass(S.message).appendTo(B); },
                    optionValue(t) {
                        const n = w.escape.value(t); H.find(`option[value="${w.escape.string(n)}"]`).length > 0 || (w.disconnect.selectObserver(), w.is.single() && (w.verbose('Removing previous user addition'), H.find(`option.${S.addition}`).remove()), e('<option/>').prop('value', n).addClass(S.addition).html(t)
                            .appendTo(H), w.verbose('Adding user addition as an <option>', t), w.observe.select());
                    },
                    userSuggestion(e) {
                        let t; let n = B.children(O.addition); const i = w.get.item(e); const o = i && i.not(O.addition).length; const a = n.length > 0; if (!k.useLabels || !w.has.maxSelections()) {
                            if (e === '' || o) return void n.remove(); a ? (n.data(P.value, e).data(P.text, e).attr(`data-${P.value}`, e).attr(`data-${P.text}`, e)
                                .removeClass(S.filtered), k.hideAdditions || (t = k.templates.addition(w.add.variables(T.addResult, e)), n.html(t)), w.verbose('Replacing user suggestion with new value', n)) : (n = w.create.userChoice(e), n.prependTo(B), w.verbose('Adding item choice to menu corresponding with user choice addition', n)), k.hideAdditions && !w.is.allFiltered() || n.addClass(S.selected).siblings().removeClass(S.selected), w.refreshItems();
                        }
                    },
                    variables(e, t) { let n; let i; const o = e.search('{count}') !== -1; const a = e.search('{maxCount}') !== -1; const r = e.search('{term}') !== -1; return w.verbose('Adding templated variables to message', e), o && (n = w.get.selectionCount(), e = e.replace('{count}', n)), a && (n = w.get.selectionCount(), e = e.replace('{maxCount}', k.maxSelections)), r && (i = t || w.get.query(), e = e.replace('{term}', i)), e; },
                    value(t, n, i) { let o; const a = w.get.values(); if (t === '') return void w.debug('Cannot select blank values from multiselect'); e.isArray(a) ? (o = a.concat([t]), o = w.get.uniqueArray(o)) : o = [t], w.has.selectInput() ? w.can.extendSelect() && (w.debug('Adding value to select', t, o, H), w.add.optionValue(t)) : (o = o.join(k.delimiter), w.debug('Setting hidden input to delimited value', o, H)), !1 === k.fireOnInit && w.is.initialLoad() ? w.verbose('Skipping onadd callback on initial load', k.onAdd) : k.onAdd.call(Z, t, n, i), w.set.value(o, t, n, i), w.check.maxSelections(); },
                },
                remove: {
                    active() { I.removeClass(S.active); }, activeLabel() { I.find(O.label).removeClass(S.active); }, empty() { I.removeClass(S.empty); }, loading() { I.removeClass(S.loading); }, initialLoad() { v = !1; }, upward(e) { (e || I).removeClass(S.upward); }, leftward(e) { (e || B).removeClass(S.leftward); }, visible() { I.removeClass(S.visible); }, activeItem() { Q.removeClass(S.active); }, filteredItem() { k.useLabels && w.has.maxSelections() || (k.useLabels && w.is.multiple() ? Q.not(`.${S.active}`).removeClass(S.filtered) : Q.removeClass(S.filtered), w.remove.empty()); }, optionValue(e) { const t = w.escape.value(e); const n = H.find(`option[value="${w.escape.string(t)}"]`); n.length > 0 && n.hasClass(S.addition) && (x && (x.disconnect(), w.verbose('Temporarily disconnecting mutation observer')), n.remove(), w.verbose('Removing user addition as an <option>', t), x && x.observe(H[0], { childList: !0, subtree: !0 })); }, message() { B.children(O.message).remove(); }, searchWidth() { V.css('width', ''); }, searchTerm() { w.verbose('Cleared search term'), V.val(''), w.set.filtered(); }, userAddition() { Q.filter(O.addition).remove(); }, selected(t, n) { if (!(n = k.allowAdditions ? n || w.get.itemWithAdditions(t) : n || w.get.item(t))) return !1; n.each(function() { const t = e(this); const n = w.get.choiceText(t); const i = w.get.choiceValue(t, n); w.is.multiple() ? k.useLabels ? (w.remove.value(i, n, t), w.remove.label(i)) : (w.remove.value(i, n, t), w.get.selectionCount() === 0 ? w.set.placeholderText() : w.set.text(w.add.variables(T.count))) : w.remove.value(i, n, t), t.removeClass(S.filtered).removeClass(S.active), k.useLabels && t.removeClass(S.selected); }); }, selectedItem() { Q.removeClass(S.selected); }, value(e, t, n) { let i; const o = w.get.values(); w.has.selectInput() ? (w.verbose('Input is <select> removing selected option', e), i = w.remove.arrayValue(e, o), w.remove.optionValue(e)) : (w.verbose('Removing from delimited values', e), i = w.remove.arrayValue(e, o), i = i.join(k.delimiter)), !1 === k.fireOnInit && w.is.initialLoad() ? w.verbose('No callback on initial load', k.onRemove) : k.onRemove.call(Z, e, t, n), w.set.value(i, t, n), w.check.maxSelections(); }, arrayValue(t, n) { return e.isArray(n) || (n = [n]), n = e.grep(n, function(e) { return t != e; }), w.verbose('Removed value from delimited string', t, n), n; }, label(e, t) { const n = I.find(O.label); const i = n.filter(`[data-${P.value}="${w.escape.string(e)}"]`); w.verbose('Removing label', i), i.remove(); }, activeLabels(e) { e = e || I.find(O.label).filter(`.${S.active}`), w.verbose('Removing active label selections', e), w.remove.labels(e); }, labels(t) { t = t || I.find(O.label), w.verbose('Removing labels', t), t.each(function() { const t = e(this); const n = t.data(P.value); const i = void 0 !== n ? String(n) : n; const o = w.is.userValue(i); if (!1 === k.onLabelRemove.call(t, n)) return void w.debug('Label remove callback cancelled removal'); w.remove.message(), o ? (w.remove.value(i), w.remove.label(i)) : w.remove.selected(i); }); }, tabbable() { w.is.searchSelection() ? (w.debug('Searchable dropdown initialized'), V.removeAttr('tabindex'), B.removeAttr('tabindex')) : (w.debug('Simple selection dropdown initialized'), I.removeAttr('tabindex'), B.removeAttr('tabindex')); },
                },
                has: {
                    menuSearch() { return w.has.search() && V.closest(B).length > 0; }, search() { return V.length > 0; }, sizer() { return N.length > 0; }, selectInput() { return H.is('select'); }, minCharacters(e) { return !k.minCharacters || (e = void 0 !== e ? String(e) : String(w.get.query()), e.length >= k.minCharacters); }, firstLetter(e, t) { let n; let i; return !(!e || e.length === 0 || typeof t !== 'string') && (n = w.get.choiceText(e, !1), t = t.toLowerCase(), i = String(n).charAt(0).toLowerCase(), t == i); }, input() { return H.length > 0; }, items() { return Q.length > 0; }, menu() { return B.length > 0; }, message() { return B.children(O.message).length !== 0; }, label(e) { const t = w.escape.value(e); return I.find(O.label).filter(`[data-${P.value}="${w.escape.string(t)}"]`).length > 0; }, maxSelections() { return k.maxSelections && w.get.selectionCount() >= k.maxSelections; }, allResultsFiltered() { const e = Q.not(O.addition); return e.filter(O.unselectable).length === e.length; }, userSuggestion() { return B.children(O.addition).length > 0; }, query() { return w.get.query() !== ''; }, value(t) { const n = w.get.values(); return !!(e.isArray(n) ? n && e.inArray(t, n) !== -1 : n == t); },
                },
                is: {
                    active() { return I.hasClass(S.active); }, bubbledLabelClick(t) { return e(t.target).is('select, input') && I.closest('label').length > 0; }, bubbledIconClick(t) { return e(t.target).closest(U).length > 0; }, alreadySetup() { return I.is('select') && void 0 !== I.parent(O.dropdown).data(z) && I.prev().length === 0; }, animating(e) { return e ? e.transition && e.transition('is animating') : B.transition && B.transition('is animating'); }, leftward(e) { return (e || B).hasClass(S.leftward); }, disabled() { return I.hasClass(S.disabled); }, focused() { return n.activeElement === I[0]; }, focusedOnSearch() { return n.activeElement === V[0]; }, allFiltered() { return (w.is.multiple() || w.has.search()) && !(k.hideAdditions == 0 && w.has.userSuggestion()) && !w.has.message() && w.has.allResultsFiltered(); }, hidden(e) { return !w.is.visible(e); }, initialLoad() { return v; }, inObject(t, n) { let i = !1; return e.each(n, function(e, n) { if (n == t) return i = !0, !0; }), i; }, multiple() { return I.hasClass(S.multiple); }, remote() { return k.apiSettings && w.can.useAPI(); }, single() { return !w.is.multiple(); }, selectMutation(t) { let n = !1; return e.each(t, function(t, i) { if (i.target && e(i.target).is('select')) return n = !0, !0; }), n; }, search() { return I.hasClass(S.search); }, searchSelection() { return w.has.search() && V.parent(O.dropdown).length === 1; }, selection() { return I.hasClass(S.selection); }, userValue(t) { return e.inArray(t, w.get.userValues()) !== -1; }, upward(e) { return (e || I).hasClass(S.upward); }, visible(e) { return e ? e.hasClass(S.visible) : B.hasClass(S.visible); }, verticallyScrollableContext() { const e = M.get(0) !== t && M.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = M.get(0) !== t && M.css('overflow-X'); return e == 'auto' || e == 'scroll'; },
                },
                can: {
                    activate(e) { return !!k.useLabels || (!w.has.maxSelections() || !(!w.has.maxSelections() || !e.hasClass(S.active))); },
                    openDownward(e) { let t; const n = e || B; let i = !0; let o = {}; return n.addClass(S.loading), t = { context: { scrollTop: M.scrollTop(), height: M.outerHeight() }, menu: { offset: n.offset(), height: n.outerHeight() } }, w.is.verticallyScrollableContext() && (t.menu.offset.top += t.context.scrollTop), o = { above: t.context.scrollTop <= t.menu.offset.top - t.menu.height, below: t.context.scrollTop + t.context.height >= t.menu.offset.top + t.menu.height }, o.below ? (w.verbose('Dropdown can fit in context downward', o), i = !0) : o.below || o.above ? (w.verbose('Dropdown cannot fit below, opening upward', o), i = !1) : (w.verbose('Dropdown cannot fit in either direction, favoring downward', o), i = !0), n.removeClass(S.loading), i; },
                    openRightward(e) {
                        let t; const n = e || B; let i = !0; let o = !1; return n.addClass(S.loading), t = { context: { scrollLeft: M.scrollLeft(), width: M.outerWidth() }, menu: { offset: n.offset(), width: n.outerWidth() } }, w.is.horizontallyScrollableContext() && (t.menu.offset.left += t.context.scrollLeft), o = t.menu.offset.left + t.menu.width >= t.context.scrollLeft + t.context.width, o && (w.verbose('Dropdown cannot fit in context rightward', o), i = !1),
                        n.removeClass(S.loading), i;
                    },
                    click() { return l || k.on == 'click'; },
                    extendSelect() { return k.allowAdditions || k.apiSettings; },
                    show() { return !w.is.disabled() && (w.has.items() || w.has.message()); },
                    useAPI() { return void 0 !== e.fn.api; },
                },
                animate: {
                    show(t, n) {
                        let i; const o = n || B; const a = n ? function() {} : function() { w.hideSubMenus(), w.hideOthers(), w.set.active(); }; t = e.isFunction(t) ? t : function() {}, w.verbose('Doing menu show animation', o), w.set.direction(n), i = w.get.transition(n), w.is.selection() && w.set.scrollPosition(w.get.selectedItem(), !0), (w.is.hidden(o) || w.is.animating(o)) && (i == 'none' ? (a(), o.transition('show'), t.call(Z)) : void 0 !== e.fn.transition && I.transition('is supported') ? o.transition({
                            animation: `${i} in`, debug: k.debug, verbose: k.verbose, duration: k.duration, queue: !0, onStart: a, onComplete() { t.call(Z); },
                        }) : w.error(D.noTransition, i));
                    },
                    hide(t, n) {
                        const i = n || B; const o = (n ? k.duration : k.duration, n ? function() {} : function() { w.can.click() && w.unbind.intent(), w.remove.active(); }); const a = w.get.transition(n); t = e.isFunction(t) ? t : function() {}, (w.is.visible(i) || w.is.animating(i)) && (w.verbose('Doing menu hide animation', i), a == 'none' ? (o(), i.transition('hide'), t.call(Z)) : void 0 !== e.fn.transition && I.transition('is supported') ? i.transition({
                            animation: `${a} out`, duration: k.duration, debug: k.debug, verbose: k.verbose, queue: !0, onStart: o, onComplete() { t.call(Z); },
                        }) : w.error(D.transition));
                    },
                },
                hideAndClear() { w.remove.searchTerm(), w.has.maxSelections() || (w.has.search() ? w.hide(function() { w.remove.filteredItem(); }) : w.hide()); },
                delay: { show() { w.verbose('Delaying show event to ensure user intent'), clearTimeout(w.timer), w.timer = setTimeout(w.show, k.delay.show); }, hide() { w.verbose('Delaying hide event to ensure user intent'), clearTimeout(w.timer), w.timer = setTimeout(w.hide, k.delay.hide); } },
                escape: { value(t) { const n = e.isArray(t); const i = typeof t === 'string'; const o = !i && !n; const a = i && t.search(F.quote) !== -1; const r = []; return o || !a ? t : (w.debug('Encoding quote values for use in select', t), n ? (e.each(t, function(e, t) { r.push(t.replace(F.quote, '&quot;')); }), r) : t.replace(F.quote, '&quot;')); }, string(e) { return e = String(e), e.replace(F.escape, '\\$&'); } },
                setting(t, n) { if (w.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, k, t); else { if (void 0 === n) return k[t]; e.isPlainObject(k[t]) ? e.extend(!0, k[t], n) : k[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, w, t); else { if (void 0 === n) return w[t]; w[t] = n; } },
                debug() { !k.silent && k.debug && (k.performance ? w.performance.log(arguments) : (w.debug = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.debug.apply(console, arguments))); },
                verbose() { !k.silent && k.verbose && k.debug && (k.performance ? w.performance.log(arguments) : (w.verbose = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.verbose.apply(console, arguments))); },
                error() { k.silent || (w.error = Function.prototype.bind.call(console.error, console, `${k.name}:`), w.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; k.performance && (t = (new Date()).getTime(), i = c || t, n = t - i, c = t, u.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: Z, 'Execution Time': n,
                        })), clearTimeout(w.performance.timer), w.performance.timer = setTimeout(w.performance.display, 500);
                    },
                    display() { let t = `${k.name}:`; let n = 0; c = !1, clearTimeout(w.performance.timer), e.each(u, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, s && (t += ` '${s}'`), (void 0 !== console.group || void 0 !== console.table) && u.length > 0 && (console.groupCollapsed(t), console.table ? console.table(u) : e.each(u, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), u = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = K; return n = n || m, i = Z || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (w.error(D.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, f ? (void 0 === K && w.initialize(), w.invoke(d)) : (void 0 !== K && K.invoke('destroy'), w.initialize());
        }), void 0 !== o ? o : a;
    }, e.fn.dropdown.settings = {
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        on: 'click',
        action: 'activate',
        values: !1,
        apiSettings: !1,
        selectOnKeydown: !0,
        minCharacters: 0,
        filterRemoteData: !1,
        saveRemoteData: !0,
        throttle: 200,
        context: t,
        direction: 'auto',
        keepOnScreen: !0,
        match: 'both',
        fullTextSearch: !1,
        placeholder: 'auto',
        preserveHTML: !0,
        sortSelect: !1,
        forceSelection: !0,
        allowAdditions: !1,
        hideAdditions: !0,
        maxSelections: !1,
        useLabels: !0,
        delimiter: ',',
        showOnFocus: !0,
        allowReselection: !1,
        allowTab: !0,
        allowCategorySelection: !1,
        fireOnInit: !1,
        transition: 'auto',
        duration: 200,
        glyphWidth: 1.037,
        label: { transition: 'scale', duration: 200, variation: !1 },
        delay: {
            hide: 300, show: 200, search: 20, touch: 50,
        },
        onChange(e, t, n) {},
        onAdd(e, t, n) {},
        onRemove(e, t, n) {},
        onLabelSelect(e) {},
        onLabelCreate(t, n) { return e(this); },
        onLabelRemove(e) { return !0; },
        onNoResults(e) { return !0; },
        onShow() {},
        onHide() {},
        name: 'Dropdown',
        namespace: 'dropdown',
        message: {
            addResult: 'Add <b>{term}</b>', count: '{count} selected', maxSelections: 'Max {maxCount} selections', noResults: 'No results found.', serverError: 'There was an error contacting the server',
        },
        error: {
            action: 'You called a dropdown action that was not defined', alreadySetup: 'Once a select has been initialized behaviors must be called on the created ui dropdown', labels: 'Allowing user additions currently requires the use of labels.', missingMultiple: '<select> requires multiple property to be set to correctly preserve multiple values', method: 'The method you called is not defined.', noAPI: 'The API module is required to load resources remotely', noStorage: 'Saving remote data requires session storage', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
        },
        regExp: { escape: /[-[\]{}()*+?.,\\^$|#\s]/g, quote: /"/g },
        metadata: {
            defaultText: 'defaultText', defaultValue: 'defaultValue', placeholderText: 'placeholder', text: 'text', value: 'value',
        },
        fields: {
            remoteValues: 'results', values: 'values', disabled: 'disabled', name: 'name', value: 'value', text: 'text',
        },
        keys: {
            backspace: 8, delimiter: 188, deleteKey: 46, enter: 13, escape: 27, pageUp: 33, pageDown: 34, leftArrow: 37, upArrow: 38, rightArrow: 39, downArrow: 40,
        },
        selector: {
            addition: '.addition', dropdown: '.ui.dropdown', hidden: '.hidden', icon: '> .dropdown.icon', input: '> input[type="hidden"], > select', item: '.item', label: '> .label', remove: '> .label > .delete.icon', siblingLabel: '.label', menu: '.menu', message: '.message', menuIcon: '.dropdown.icon', search: 'input.search, .menu > .search > input, .menu input.search', sizer: '> input.sizer', text: '> .text:not(.icon)', unselectable: '.disabled, .filtered',
        },
        className: {
            active: 'active', addition: 'addition', animating: 'animating', disabled: 'disabled', empty: 'empty', dropdown: 'ui dropdown', filtered: 'filtered', hidden: 'hidden transition', item: 'item', label: 'ui label', loading: 'loading', menu: 'menu', message: 'message', multiple: 'multiple', placeholder: 'default', sizer: 'sizer', search: 'search', selected: 'selected', selection: 'selection', upward: 'upward', leftward: 'left', visible: 'visible',
        },
    }, e.fn.dropdown.settings.templates = {
        dropdown(t) { const n = t.placeholder || !1; let i = (t.values, ''); return i += '<i class="dropdown icon"></i>', t.placeholder ? i += `<div class="default text">${n}</div>` : i += '<div class="text"></div>', i += '<div class="menu">', e.each(t.values, function(e, t) { i += t.disabled ? `<div class="disabled item" data-value="${t.value}">${t.name}</div>` : `<div class="item" data-value="${t.value}">${t.name}</div>`; }), i += '</div>'; },
        menu(t, n) {
            const i = t[n.values] || {}; let o = ''; return e.each(i, function(e, t) {
                const i = t[n.text] ? `data-text="${t[n.text]}"` : '';
                const a = t[n.disabled] ? 'disabled ' : ''; o += `<div class="${a}item" data-value="${t[n.value]}"${i}>`, o += t[n.name], o += '</div>';
            }), o;
        },
        label(e, t) { return `${t}<i class="delete icon"></i>`; },
        message(e) { return e; },
        addition(e) { return e; },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.embed = function(n) {
        let i; const o = e(this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); return o.each(function() {
            let d; const f = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.embed.settings, n) : e.extend({}, e.fn.embed.settings); const m = f.selector; const g = f.className; const v = f.sources; const p = f.error; const h = f.metadata; const b = f.namespace; const y = f.templates; const x = `.${b}`; const C = `module-${b}`; const w = (e(t), e(this)); let k = w.find(m.placeholder); let S = w.find(m.icon); let T = w.find(m.embed); const A = this; let R = w.data(C); d = {
                initialize() { d.debug('Initializing embed'), d.determine.autoplay(), d.create(), d.bind.events(), d.instantiate(); },
                instantiate() { d.verbose('Storing instance of module', d), R = d, w.data(C, d); },
                destroy() { d.verbose('Destroying previous instance of embed'), d.reset(), w.removeData(C).off(x); },
                refresh() { d.verbose('Refreshing selector cache'), k = w.find(m.placeholder), S = w.find(m.icon), T = w.find(m.embed); },
                bind: { events() { d.has.placeholder() && (d.debug('Adding placeholder events'), w.on(`click${x}`, m.placeholder, d.createAndShow).on(`click${x}`, m.icon, d.createAndShow)); } },
                create() { d.get.placeholder() ? d.createPlaceholder() : d.createAndShow(); },
                createPlaceholder(e) { const t = d.get.icon(); const n = d.get.url(); d.generate.embed(n); e = e || d.get.placeholder(), w.html(y.placeholder(e, t)), d.debug('Creating placeholder for embed', e, t); },
                createEmbed(t) { d.refresh(), t = t || d.get.url(), T = e('<div/>').addClass(g.embed).html(d.generate.embed(t)).appendTo(w), f.onCreate.call(A, t), d.debug('Creating embed object', T); },
                changeEmbed(e) { T.html(d.generate.embed(e)); },
                createAndShow() { d.createEmbed(), d.show(); },
                change(e, t, n) { d.debug('Changing video to ', e, t, n), w.data(h.source, e).data(h.id, t), n ? w.data(h.url, n) : w.removeData(h.url), d.has.embed() ? d.changeEmbed() : d.create(); },
                reset() { d.debug('Clearing embed and showing placeholder'), d.remove.active(), d.remove.embed(), d.showPlaceholder(), f.onReset.call(A); },
                show() { d.debug('Showing embed'), d.set.active(), f.onDisplay.call(A); },
                hide() { d.debug('Hiding embed'), d.showPlaceholder(); },
                showPlaceholder() { d.debug('Showing placeholder image'), d.remove.active(), f.onPlaceholderDisplay.call(A); },
                get: {
                    id() { return f.id || w.data(h.id); }, placeholder() { return f.placeholder || w.data(h.placeholder); }, icon() { return f.icon ? f.icon : void 0 !== w.data(h.icon) ? w.data(h.icon) : d.determine.icon(); }, source(e) { return f.source ? f.source : void 0 !== w.data(h.source) ? w.data(h.source) : d.determine.source(); }, type() { const e = d.get.source(); return void 0 !== v[e] && v[e].type; }, url() { return f.url ? f.url : void 0 !== w.data(h.url) ? w.data(h.url) : d.determine.url(); },
                },
                determine: {
                    autoplay() { d.should.autoplay() && (f.autoplay = !0); }, source(t) { let n = !1; return t = t || d.get.url(), t && e.each(v, function(e, i) { if (t.search(i.domain) !== -1) return n = e, !1; }), n; }, icon() { const e = d.get.source(); return void 0 !== v[e] && v[e].icon; }, url() { let e; const t = f.id || w.data(h.id); const n = f.source || w.data(h.source); return e = void 0 !== v[n] && v[n].url.replace('{id}', t), e && w.data(h.url, e), e; },
                },
                set: { active() { w.addClass(g.active); } },
                remove: { active() { w.removeClass(g.active); }, embed() { T.empty(); } },
                encode: { parameters(e) { let t; const n = []; for (t in e)n.push(`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`); return n.join('&amp;'); } },
                generate: { embed(e) { d.debug('Generating embed html'); let t; let n; const i = d.get.source(); return e = d.get.url(e), e ? (n = d.generate.parameters(i), t = y.iframe(e, n)) : d.error(p.noURL, w), t; }, parameters(t, n) { let i = v[t] && void 0 !== v[t].parameters ? v[t].parameters(f) : {}; return n = n || f.parameters, n && (i = e.extend({}, i, n)), i = f.onEmbed(i), d.encode.parameters(i); } },
                has: { embed() { return T.length > 0; }, placeholder() { return f.placeholder || w.data(h.placeholder); } },
                should: { autoplay() { return f.autoplay === 'auto' ? f.placeholder || void 0 !== w.data(h.placeholder) : f.autoplay; } },
                is: { video() { return d.get.type() == 'video'; } },
                setting(t, n) { if (d.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: A, 'Execution Time': n,
                        })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                    },
                    display() { let t = `${f.name}:`; let n = 0; r = !1, clearTimeout(d.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, n, o) { let a; let r; let s; let l = R; return n = n || u, o = A || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (d.error(p.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r; },
            }, c ? (void 0 === R && d.initialize(), d.invoke(l)) : (void 0 !== R && R.invoke('destroy'), d.initialize());
        }), void 0 !== i ? i : this;
    }, e.fn.embed.settings = {
        name: 'Embed',
        namespace: 'embed',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        icon: !1,
        source: !1,
        url: !1,
        id: !1,
        autoplay: 'auto',
        color: '#444444',
        hd: !0,
        brandedUI: !1,
        parameters: !1,
        onDisplay() {},
        onPlaceholderDisplay() {},
        onReset() {},
        onCreate(e) {},
        onEmbed(e) { return e; },
        metadata: {
            id: 'id', icon: 'icon', placeholder: 'placeholder', source: 'source', url: 'url',
        },
        error: { noURL: 'No URL specified', method: 'The method you called is not defined' },
        className: { active: 'active', embed: 'embed' },
        selector: { embed: '.embed', placeholder: '.placeholder', icon: '.icon' },
        sources: {
            youtube: {
                name: 'youtube',
                type: 'video',
                icon: 'video play',
                domain: 'youtube.com',
                url: '//www.youtube.com/embed/{id}',
                parameters(e) {
                    return {
                        autohide: !e.brandedUI, autoplay: e.autoplay, color: e.color || void 0, hq: e.hd, jsapi: e.api, modestbranding: !e.brandedUI,
                    };
                },
            },
            vimeo: {
                name: 'vimeo',
                type: 'video',
                icon: 'video play',
                domain: 'vimeo.com',
                url: '//player.vimeo.com/video/{id}',
                parameters(e) {
                    return {
                        api: e.api, autoplay: e.autoplay, byline: e.brandedUI, color: e.color || void 0, portrait: e.brandedUI, title: e.brandedUI,
                    };
                },
            },
        },
        templates: { iframe(e, t) { let n = e; return t && (n += `?${t}`), `<iframe src="${n}" width="100%" height="100%" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>`; }, placeholder(e, t) { let n = ''; return t && (n += `<i class="${t} icon"></i>`), e && (n += `<img class="placeholder" src="${e}">`), n; } },
        api: !1,
        onPause() {},
        onPlay() {},
        onStop() {},
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.modal = function(i) {
        let o; const a = e(this); const r = e(t); const s = e(n); const l = e('body'); const c = a.selector || ''; let u = (new Date()).getTime(); let d = []; const f = arguments[0]; const m = typeof f === 'string'; const g = [].slice.call(arguments, 1); const v = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; return a.each(function() {
            let a; let p; let h; let b; let y; let x; let C; let w; let k; const S = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.modal.settings, i) : e.extend({}, e.fn.modal.settings); const T = S.selector; const A = S.className; const R = S.namespace; const P = S.error; const E = `.${R}`; const F = `module-${R}`; const O = e(this); const D = e(S.context); const q = O.find(T.close); const j = this; let z = O.data(F); let I = !1; k = {
                initialize() { k.verbose('Initializing dimmer', D), k.create.id(), k.create.dimmer(), k.refreshModals(), k.bind.events(), S.observeChanges && k.observeChanges(), k.instantiate(); },
                instantiate() { k.verbose('Storing instance of modal'), z = k, O.data(F, z); },
                create: { dimmer() { const t = { debug: S.debug, dimmerName: 'modals' }; const n = e.extend(!0, t, S.dimmerSettings); if (void 0 === e.fn.dimmer) return void k.error(P.dimmer); k.debug('Creating dimmer'), b = D.dimmer(n), S.detachable ? (k.verbose('Modal is detachable, moving content into dimmer'), b.dimmer('add content', O)) : k.set.undetached(), y = b.dimmer('get dimmer'); }, id() { C = (`${Math.random().toString(16)}000000000`).substr(2, 8), x = `.${C}`, k.verbose('Creating unique id for element', C); } },
                destroy() { k.verbose('Destroying previous modal'), O.removeData(F).off(E), r.off(x), y.off(x), q.off(E), D.dimmer('destroy'); },
                observeChanges() { 'MutationObserver' in t && (w = new MutationObserver(function(e) { k.debug('DOM tree modified, refreshing'), k.refresh(); }), w.observe(j, { childList: !0, subtree: !0 }), k.debug('Setting up mutation observer', w)); },
                refresh() { k.remove.scrolling(), k.cacheSizes(), k.set.screenHeight(), k.set.type(), k.set.position(); },
                refreshModals() { p = O.siblings(T.modal), a = p.add(O); },
                attachEvents(t, n) { const i = e(t); n = e.isFunction(k[n]) ? k[n] : k.toggle, i.length > 0 ? (k.debug('Attaching modal events to element', t, n), i.off(E).on(`click${E}`, n)) : k.error(P.notFound, t); },
                bind: { events() { k.verbose('Attaching events'), O.on(`click${E}`, T.close, k.event.close).on(`click${E}`, T.approve, k.event.approve).on(`click${E}`, T.deny, k.event.deny), r.on(`resize${x}`, k.event.resize); } },
                get: { id() { return (`${Math.random().toString(16)}000000000`).substr(2, 8); } },
                event: {
                    approve() { if (I || !1 === S.onApprove.call(j, e(this))) return void k.verbose('Approve callback returned false cancelling hide'); I = !0, k.hide(function() { I = !1; }); }, deny() { if (I || !1 === S.onDeny.call(j, e(this))) return void k.verbose('Deny callback returned false cancelling hide'); I = !0, k.hide(function() { I = !1; }); }, close() { k.hide(); }, click(t) { const i = e(t.target); const o = i.closest(T.modal).length > 0; const a = e.contains(n.documentElement, t.target); !o && a && (k.debug('Dimmer clicked, hiding all modals'), k.is.active() && (k.remove.clickaway(), S.allowMultiple ? k.hide() : k.hideAll())); }, debounce(e, t) { clearTimeout(k.timer), k.timer = setTimeout(e, t); }, keyboard(e) { e.which == 27 && (S.closable ? (k.debug('Escape key pressed hiding modal'), k.hide()) : k.debug('Escape key pressed, but closable is set to false'), e.preventDefault()); }, resize() { b.dimmer('is active') && (k.is.animating() || k.is.active()) && v(k.refresh); },
                },
                toggle() { k.is.active() || k.is.animating() ? k.hide() : k.show(); },
                show(t) { t = e.isFunction(t) ? t : function() {}, k.refreshModals(), k.set.dimmerSettings(), k.showModal(t); },
                hide(t) { t = e.isFunction(t) ? t : function() {}, k.refreshModals(), k.hideModal(t); },
                showModal(t) {
                    t = e.isFunction(t) ? t : function() {}, k.is.animating() || !k.is.active() ? (k.showDimmer(), k.cacheSizes(), k.set.position(), k.set.screenHeight(), k.set.type(), k.set.clickaway(), !S.allowMultiple && k.others.active() ? k.hideOthers(k.showModal) : (S.allowMultiple && S.detachable && O.detach().appendTo(y), S.onShow.call(j), S.transition && void 0 !== e.fn.transition && O.transition('is supported') ? (k.debug('Showing modal with css animations'), O.transition({
                        debug: S.debug, animation: `${S.transition} in`, queue: S.queue, duration: S.duration, useFailSafe: !0, onComplete() { S.onVisible.apply(j), S.keyboardShortcuts && k.add.keyboardShortcuts(), k.save.focus(), k.set.active(), S.autofocus && k.set.autofocus(), t(); },
                    })) : k.error(P.noTransition))) : k.debug('Modal is already visible');
                },
                hideModal(t, n) {
                    if (t = e.isFunction(t) ? t : function() {}, k.debug('Hiding modal'), !1 === S.onHide.call(j, e(this))) return void k.verbose('Hide callback returned false cancelling hide'); (k.is.animating() || k.is.active()) && (S.transition && void 0 !== e.fn.transition && O.transition('is supported') ? (k.remove.active(), O.transition({
                        debug: S.debug, animation: `${S.transition} out`, queue: S.queue, duration: S.duration, useFailSafe: !0, onStart() { k.others.active() || n || k.hideDimmer(), S.keyboardShortcuts && k.remove.keyboardShortcuts(); }, onComplete() { S.onHidden.call(j), k.restore.focus(), t(); },
                    })) : k.error(P.noTransition));
                },
                showDimmer() { b.dimmer('is animating') || !b.dimmer('is active') ? (k.debug('Showing dimmer'), b.dimmer('show')) : k.debug('Dimmer already visible'); },
                hideDimmer() { if (!b.dimmer('is animating') && !b.dimmer('is active')) return void k.debug('Dimmer is not visible cannot hide'); b.dimmer('hide', function() { k.remove.clickaway(), k.remove.screenHeight(); }); },
                hideAll(t) { const n = a.filter(`.${A.active}, .${A.animating}`); t = e.isFunction(t) ? t : function() {}, n.length > 0 && (k.debug('Hiding all visible modals'), k.hideDimmer(), n.modal('hide modal', t)); },
                hideOthers(t) { const n = p.filter(`.${A.active}, .${A.animating}`); t = e.isFunction(t) ? t : function() {}, n.length > 0 && (k.debug('Hiding other modals', p), n.modal('hide modal', t, !0)); },
                others: { active() { return p.filter(`.${A.active}`).length > 0; }, animating() { return p.filter(`.${A.animating}`).length > 0; } },
                add: { keyboardShortcuts() { k.verbose('Adding keyboard shortcuts'), s.on(`keyup${E}`, k.event.keyboard); } },
                save: { focus() { h = e(n.activeElement).blur(); } },
                restore: { focus() { h && h.length > 0 && h.focus(); } },
                remove: {
                    active() { O.removeClass(A.active); }, clickaway() { S.closable && y.off(`click${x}`); }, bodyStyle() { l.attr('style') === '' && (k.verbose('Removing style attribute'), l.removeAttr('style')); }, screenHeight() { k.debug('Removing page height'), l.css('height', ''); }, keyboardShortcuts() { k.verbose('Removing keyboard shortcuts'), s.off(`keyup${E}`); }, scrolling() { b.removeClass(A.scrolling), O.removeClass(A.scrolling); },
                },
                cacheSizes() {
                    O.addClass(A.loading); const i = O.prop('scrollHeight'); const o = O.outerHeight(); void 0 !== k.cache && o === 0 || (k.cache = {
                        pageHeight: e(n).outerHeight(), height: o + S.offset, scrollHeight: i + S.offset, contextHeight: S.context == 'body' ? e(t).height() : b.height(),
                    }, k.cache.topOffset = -k.cache.height / 2), O.removeClass(A.loading), k.debug('Caching modal and container sizes', k.cache);
                },
                can: { fit() { const e = k.cache.contextHeight; const t = k.cache.contextHeight / 2; const n = k.cache.topOffset; const i = k.cache.scrollHeight; const o = k.cache.height; const a = S.padding; const r = t + n; return i > o ? r + i + a < e : o + 2 * a < e; } },
                is: {
                    active() { return O.hasClass(A.active); }, animating() { return O.transition('is supported') ? O.transition('is animating') : O.is(':visible'); }, scrolling() { return b.hasClass(A.scrolling); }, modernBrowser() { return !(t.ActiveXObject || 'ActiveXObject' in t); },
                },
                set: {
                    autofocus() { const e = O.find('[tabindex], :input').filter(':visible'); const t = e.filter('[autofocus]'); const n = t.length > 0 ? t.first() : e.first(); n.length > 0 && n.focus(); },
                    clickaway() { S.closable && y.on(`click${x}`, k.event.click); },
                    dimmerSettings() {
                        if (void 0 === e.fn.dimmer) return void k.error(P.dimmer); const t = {
                            debug: S.debug, dimmerName: 'modals', variation: !1, closable: 'auto', duration: { show: S.duration, hide: S.duration },
                        }; const n = e.extend(!0, t, S.dimmerSettings); S.inverted ? (n.variation = void 0 !== n.variation ? `${n.variation} inverted` : 'inverted', y.addClass(A.inverted)) : y.removeClass(A.inverted), S.blurring ? b.addClass(A.blurring) : b.removeClass(A.blurring), D.dimmer('setting', n);
                    },
                    screenHeight() { k.can.fit() ? l.css('height', '') : (k.debug('Modal is taller than page content, resizing page height'), l.css('height', k.cache.height + 2 * S.padding)); },
                    active() { O.addClass(A.active); },
                    scrolling() { b.addClass(A.scrolling), O.addClass(A.scrolling); },
                    type() { k.can.fit() ? (k.verbose('Modal fits on screen'), k.others.active() || k.others.animating() || k.remove.scrolling()) : (k.verbose('Modal cannot fit on screen setting to scrolling'), k.set.scrolling()); },
                    position() { k.verbose('Centering modal on page', k.cache), k.can.fit() ? O.css({ top: '', marginTop: k.cache.topOffset }) : O.css({ marginTop: '', top: s.scrollTop() }); },
                    undetached() { b.addClass(A.undetached); },
                },
                setting(t, n) { if (k.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, S, t); else { if (void 0 === n) return S[t]; e.isPlainObject(S[t]) ? e.extend(!0, S[t], n) : S[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, k, t); else { if (void 0 === n) return k[t]; k[t] = n; } },
                debug() { !S.silent && S.debug && (S.performance ? k.performance.log(arguments) : (k.debug = Function.prototype.bind.call(console.info, console, `${S.name}:`), k.debug.apply(console, arguments))); },
                verbose() { !S.silent && S.verbose && S.debug && (S.performance ? k.performance.log(arguments) : (k.verbose = Function.prototype.bind.call(console.info, console, `${S.name}:`), k.verbose.apply(console, arguments))); },
                error() { S.silent || (k.error = Function.prototype.bind.call(console.error, console, `${S.name}:`), k.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; S.performance && (t = (new Date()).getTime(), i = u || t, n = t - i, u = t, d.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: j, 'Execution Time': n,
                        })), clearTimeout(k.performance.timer), k.performance.timer = setTimeout(k.performance.display, 500);
                    },
                    display() { let t = `${S.name}:`; let n = 0; u = !1, clearTimeout(k.performance.timer), e.each(d, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, c && (t += ` '${c}'`), (void 0 !== console.group || void 0 !== console.table) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), d = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = z; return n = n || g, i = j || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, m ? (void 0 === z && k.initialize(), k.invoke(f)) : (void 0 !== z && z.invoke('destroy'), k.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.modal.settings = {
        name: 'Modal',
        namespace: 'modal',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        observeChanges: !1,
        allowMultiple: !1,
        detachable: !0,
        closable: !0,
        autofocus: !0,
        inverted: !1,
        blurring: !1,
        dimmerSettings: { closable: !1, useCSS: !0 },
        keyboardShortcuts: !0,
        context: 'body',
        queue: !1,
        duration: 500,
        offset: 0,
        transition: 'scale',
        padding: 50,
        onShow() {},
        onVisible() {},
        onHide() { return !0; },
        onHidden() {},
        onApprove() { return !0; },
        onDeny() { return !0; },
        selector: {
            close: '> .close', approve: '.actions .positive, .actions .approve, .actions .ok', deny: '.actions .negative, .actions .deny, .actions .cancel', modal: '.ui.modal',
        },
        error: { dimmer: 'UI Dimmer, a required component is not included in this page', method: 'The method you called is not defined.', notFound: 'The element you specified could not be found' },
        className: {
            active: 'active', animating: 'animating', blurring: 'blurring', inverted: 'inverted', loading: 'loading', scrolling: 'scrolling', undetached: 'undetached',
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.nag = function(n) {
        let i; const o = e(this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); return o.each(function() {
            let o; const d = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.nag.settings, n) : e.extend({}, e.fn.nag.settings); const f = (d.className, d.selector); const m = d.error; const g = d.namespace; const v = `.${g}`; const p = `${g}-module`; const h = e(this); const b = (h.find(f.close), e(d.context ? d.context : 'body')); const y = this; const x = h.data(p); t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame; o = {
                initialize() { o.verbose('Initializing element'), h.on(`click${v}`, f.close, o.dismiss).data(p, o), d.detachable && h.parent()[0] !== b[0] && h.detach().prependTo(b), d.displayTime > 0 && setTimeout(o.hide, d.displayTime), o.show(); },
                destroy() { o.verbose('Destroying instance'), h.removeData(p).off(v); },
                show() { o.should.show() && !h.is(':visible') && (o.debug('Showing nag', d.animation.show), d.animation.show == 'fade' ? h.fadeIn(d.duration, d.easing) : h.slideDown(d.duration, d.easing)); },
                hide() { o.debug('Showing nag', d.animation.hide), d.animation.show == 'fade' ? h.fadeIn(d.duration, d.easing) : h.slideUp(d.duration, d.easing); },
                onHide() { o.debug('Removing nag', d.animation.hide), h.remove(), d.onHide && d.onHide(); },
                dismiss(e) { d.storageMethod && o.storage.set(d.key, d.value), o.hide(), e.stopImmediatePropagation(), e.preventDefault(); },
                should: { show() { return d.persist ? (o.debug('Persistent nag is set, can show nag'), !0) : o.storage.get(d.key) != d.value.toString() ? (o.debug('Stored value is not set, can show nag', o.storage.get(d.key)), !0) : (o.debug('Stored value is set, cannot show nag', o.storage.get(d.key)), !1); } },
                get: { storageOptions() { const e = {}; return d.expires && (e.expires = d.expires), d.domain && (e.domain = d.domain), d.path && (e.path = d.path), e; } },
                clear() { o.storage.remove(d.key); },
                storage: { set(n, i) { const a = o.get.storageOptions(); if (d.storageMethod == 'localstorage' && void 0 !== t.localStorage)t.localStorage.setItem(n, i), o.debug('Value stored using local storage', n, i); else if (d.storageMethod == 'sessionstorage' && void 0 !== t.sessionStorage)t.sessionStorage.setItem(n, i), o.debug('Value stored using session storage', n, i); else { if (void 0 === e.cookie) return void o.error(m.noCookieStorage); e.cookie(n, i, a), o.debug('Value stored using cookie', n, i, a); } }, get(n, i) { let a; return d.storageMethod == 'localstorage' && void 0 !== t.localStorage ? a = t.localStorage.getItem(n) : d.storageMethod == 'sessionstorage' && void 0 !== t.sessionStorage ? a = t.sessionStorage.getItem(n) : void 0 !== e.cookie ? a = e.cookie(n) : o.error(m.noCookieStorage), a != 'undefined' && a != 'null' && void 0 !== a && a !== null || (a = void 0), a; }, remove(n) { const i = o.get.storageOptions(); d.storageMethod == 'localstorage' && void 0 !== t.localStorage ? t.localStorage.removeItem(n) : d.storageMethod == 'sessionstorage' && void 0 !== t.sessionStorage ? t.sessionStorage.removeItem(n) : void 0 !== e.cookie ? e.removeCookie(n, i) : o.error(m.noStorage); } },
                setting(t, n) { if (o.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; e.isPlainObject(d[t]) ? e.extend(!0, d[t], n) : d[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, o, t); else { if (void 0 === n) return o[t]; o[t] = n; } },
                debug() { !d.silent && d.debug && (d.performance ? o.performance.log(arguments) : (o.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.debug.apply(console, arguments))); },
                verbose() { !d.silent && d.verbose && d.debug && (d.performance ? o.performance.log(arguments) : (o.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.verbose.apply(console, arguments))); },
                error() { d.silent || (o.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), o.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; d.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: y, 'Execution Time': n,
                        })), clearTimeout(o.performance.timer), o.performance.timer = setTimeout(o.performance.display, 500);
                    },
                    display() {
                        let t = `${d.name}:`; let n = 0; r = !1, clearTimeout(o.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t),
                        console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = [];
                    },
                },
                invoke(t, n, a) { let r; let s; let l; let c = x; return n = n || u, a = y || a, typeof t === 'string' && void 0 !== c && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, function(n, i) { const a = n != r ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(c[a]) && n != r)c = c[a]; else { if (void 0 !== c[a]) return s = c[a], !1; if (!e.isPlainObject(c[i]) || n == r) return void 0 !== c[i] ? (s = c[i], !1) : (o.error(m.method, t), !1); c = c[i]; } })), e.isFunction(s) ? l = s.apply(a, n) : void 0 !== s && (l = s), e.isArray(i) ? i.push(l) : void 0 !== i ? i = [i, l] : void 0 !== l && (i = l), s; },
            }, c ? (void 0 === x && o.initialize(), o.invoke(l)) : (void 0 !== x && x.invoke('destroy'), o.initialize());
        }), void 0 !== i ? i : this;
    }, e.fn.nag.settings = {
        name: 'Nag', silent: !1, debug: !1, verbose: !1, performance: !0, namespace: 'Nag', persist: !1, displayTime: 0, animation: { show: 'slide', hide: 'slide' }, context: !1, detachable: !1, expires: 30, domain: !1, path: '/', storageMethod: 'cookie', key: 'nag', value: 'dismiss', error: { noCookieStorage: '$.cookie is not included. A storage solution is required.', noStorage: 'Neither $.cookie or store is defined. A storage solution is required for storing state', method: 'The method you called is not defined.' }, className: { bottom: 'bottom', fixed: 'fixed' }, selector: { close: '.close.icon' }, speed: 500, easing: 'easeOutQuad', onHide() {},
    }, e.extend(e.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.popup = function(i) {
        let o; const a = e(this); const r = e(n); const s = e(t); const l = e('body'); const c = a.selector || ''; let u = (new Date()).getTime(); let d = []; const f = arguments[0]; const m = typeof f === 'string'; const g = [].slice.call(arguments, 1); return a.each(function() {
            let a; let v; let p; let h; let b; let y; const x = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.popup.settings, i) : e.extend({}, e.fn.popup.settings); const C = x.selector; const w = x.className; const k = x.error; const S = x.metadata; const T = x.namespace; const A = `.${x.namespace}`; const R = `module-${T}`; const P = e(this); const E = e(x.context); const F = e(x.scrollContext); const O = e(x.boundary); const D = x.target ? e(x.target) : P; let q = 0; let j = !1; let z = !1; const I = this; let M = P.data(R); y = {
                initialize() { y.debug('Initializing', P), y.createID(), y.bind.events(), !y.exists() && x.preserve && y.create(), x.observeChanges && y.observeChanges(), y.instantiate(); },
                instantiate() { y.verbose('Storing instance', y), M = y, P.data(R, M); },
                observeChanges() { 'MutationObserver' in t && (p = new MutationObserver(y.event.documentChanged), p.observe(n, { childList: !0, subtree: !0 }), y.debug('Setting up mutation observer', p)); },
                refresh() { x.popup ? a = e(x.popup).eq(0) : x.inline && (a = D.nextAll(C.popup).eq(0), x.popup = a), x.popup ? (a.addClass(w.loading), v = y.get.offsetParent(), a.removeClass(w.loading), x.movePopup && y.has.popup() && y.get.offsetParent(a)[0] !== v[0] && (y.debug('Moving popup to the same offset parent as target'), a.detach().appendTo(v))) : v = x.inline ? y.get.offsetParent(D) : y.has.popup() ? y.get.offsetParent(a) : l, v.is('html') && v[0] !== l[0] && (y.debug('Setting page as offset parent'), v = l), y.get.variation() && y.set.variation(); },
                reposition() { y.refresh(), y.set.position(); },
                destroy() { y.debug('Destroying previous module'), p && p.disconnect(), a && !x.preserve && y.removePopup(), clearTimeout(y.hideTimer), clearTimeout(y.showTimer), y.unbind.close(), y.unbind.events(), P.removeData(R); },
                event: {
                    start(t) { const n = e.isPlainObject(x.delay) ? x.delay.show : x.delay; clearTimeout(y.hideTimer), z || (y.showTimer = setTimeout(y.show, n)); }, end() { const t = e.isPlainObject(x.delay) ? x.delay.hide : x.delay; clearTimeout(y.showTimer), y.hideTimer = setTimeout(y.hide, t); }, touchstart(e) { z = !0, y.show(); }, resize() { y.is.visible() && y.set.position(); }, documentChanged(t) { [].forEach.call(t, function(t) { t.removedNodes && [].forEach.call(t.removedNodes, function(t) { (t == I || e(t).find(I).length > 0) && (y.debug('Element removed from DOM, tearing down events'), y.destroy()); }); }); }, hideGracefully(t) { const i = e(t.target); const o = e.contains(n.documentElement, t.target); const a = i.closest(C.popup).length > 0; t && !a && o ? (y.debug('Click occurred outside popup hiding popup'), y.hide()) : y.debug('Click was inside popup, keeping popup open'); },
                },
                create() { let t = y.get.html(); const n = y.get.title(); const i = y.get.content(); t || i || n ? (y.debug('Creating pop-up html'), t || (t = x.templates.popup({ title: n, content: i })), a = e('<div/>').addClass(w.popup).data(S.activator, P).html(t), x.inline ? (y.verbose('Inserting popup element inline', a), a.insertAfter(P)) : (y.verbose('Appending popup element to body', a), a.appendTo(E)), y.refresh(), y.set.variation(), x.hoverable && y.bind.popup(), x.onCreate.call(a, I)) : D.next(C.popup).length !== 0 ? (y.verbose('Pre-existing popup found'), x.inline = !0, x.popup = D.next(C.popup).data(S.activator, P), y.refresh(), x.hoverable && y.bind.popup()) : x.popup ? (e(x.popup).data(S.activator, P), y.verbose('Used popup specified in settings'), y.refresh(), x.hoverable && y.bind.popup()) : y.debug('No content specified skipping display', I); },
                createID() { b = (`${Math.random().toString(16)}000000000`).substr(2, 8), h = `.${b}`, y.verbose('Creating unique id for element', b); },
                toggle() { y.debug('Toggling pop-up'), y.is.hidden() ? (y.debug('Popup is hidden, showing pop-up'), y.unbind.close(), y.show()) : (y.debug('Popup is visible, hiding pop-up'), y.hide()); },
                show(e) { if (e = e || function() {}, y.debug('Showing pop-up', x.transition), y.is.hidden() && (!y.is.active() || !y.is.dropdown())) { if (y.exists() || y.create(), !1 === x.onShow.call(a, I)) return void y.debug('onShow callback returned false, cancelling popup animation'); x.preserve || x.popup || y.refresh(), a && y.set.position() && (y.save.conditions(), x.exclusive && y.hideAll(), y.animate.show(e)); } },
                hide(e) { if (e = e || function() {}, y.is.visible() || y.is.animating()) { if (!1 === x.onHide.call(a, I)) return void y.debug('onHide callback returned false, cancelling popup animation'); y.remove.visible(), y.unbind.close(), y.restore.conditions(), y.animate.hide(e); } },
                hideAll() { e(C.popup).filter(`.${w.popupVisible}`).each(function() { e(this).data(S.activator).popup('hide'); }); },
                exists() { return !!a && (x.inline || x.popup ? y.has.popup() : a.closest(E).length >= 1); },
                removePopup() { y.has.popup() && !x.popup && (y.debug('Removing popup', a), a.remove(), a = void 0, x.onRemove.call(a, I)); },
                save: { conditions() { y.cache = { title: P.attr('title') }, y.cache.title && P.removeAttr('title'), y.verbose('Saving original attributes', y.cache.title); } },
                restore: { conditions() { return y.cache && y.cache.title && (P.attr('title', y.cache.title), y.verbose('Restoring original attributes', y.cache.title)), !0; } },
                supports: { svg() { return typeof SVGGraphicsElement === 'undefined'; } },
                animate: {
                    show(t) {
                        t = e.isFunction(t) ? t : function() {}, x.transition && void 0 !== e.fn.transition && P.transition('is supported') ? (y.set.visible(), a.transition({
                            animation: `${x.transition} in`, queue: !1, debug: x.debug, verbose: x.verbose, duration: x.duration, onComplete() { y.bind.close(), t.call(a, I), x.onVisible.call(a, I); },
                        })) : y.error(k.noTransition);
                    },
                    hide(t) {
                        if (t = e.isFunction(t) ? t : function() {}, y.debug('Hiding pop-up'), !1 === x.onHide.call(a, I)) return void y.debug('onHide callback returned false, cancelling popup animation'); x.transition && void 0 !== e.fn.transition && P.transition('is supported') ? a.transition({
                            animation: `${x.transition} out`, queue: !1, duration: x.duration, debug: x.debug, verbose: x.verbose, onComplete() { y.reset(), t.call(a, I), x.onHidden.call(a, I); },
                        }) : y.error(k.noTransition);
                    },
                },
                change: { content(e) { a.html(e); } },
                get: {
                    html() { return P.removeData(S.html), P.data(S.html) || x.html; },
                    title() { return P.removeData(S.title), P.data(S.title) || x.title; },
                    content() { return P.removeData(S.content), P.data(S.content) || P.attr('title') || x.content; },
                    variation() { return P.removeData(S.variation), P.data(S.variation) || x.variation; },
                    popup() { return a; },
                    popupOffset() { return a.offset(); },
                    calculations() {
                        let e; const n = D[0]; const i = O[0] == t; const o = x.inline || x.popup && x.movePopup ? D.position() : D.offset(); const r = i ? { top: 0, left: 0 } : O.offset(); let l = {}; const c = i ? { top: s.scrollTop(), left: s.scrollLeft() } : { top: 0, left: 0 }; return l = {
                            target: {
                                element: D[0], width: D.outerWidth(), height: D.outerHeight(), top: o.top, left: o.left, margin: {},
                            },
                            popup: { width: a.outerWidth(), height: a.outerHeight() },
                            parent: { width: v.outerWidth(), height: v.outerHeight() },
                            screen: {
                                top: r.top, left: r.left, scroll: { top: c.top, left: c.left }, width: O.width(), height: O.height(),
                            },
                        }, x.setFluidWidth && y.is.fluid() && (l.container = { width: a.parent().outerWidth() }, l.popup.width = l.container.width), l.target.margin.top = x.inline ? parseInt(t.getComputedStyle(n).getPropertyValue('margin-top'), 10) : 0, l.target.margin.left = x.inline ? y.is.rtl() ? parseInt(t.getComputedStyle(n).getPropertyValue('margin-right'), 10) : parseInt(t.getComputedStyle(n).getPropertyValue('margin-left'), 10) : 0, e = l.screen, l.boundary = {
                            top: e.top + e.scroll.top, bottom: e.top + e.scroll.top + e.height, left: e.left + e.scroll.left, right: e.left + e.scroll.left + e.width,
                        }, l;
                    },
                    id() { return b; },
                    startEvent() { return x.on == 'hover' ? 'mouseenter' : x.on == 'focus' && 'focus'; },
                    scrollEvent() { return 'scroll'; },
                    endEvent() { return x.on == 'hover' ? 'mouseleave' : x.on == 'focus' && 'blur'; },
                    distanceFromBoundary(e, t) {
                        let n; let i; let o = {}; return t = t || y.get.calculations(), n = t.popup, i = t.boundary, e && (o = {
                            top: e.top - i.top, left: e.left - i.left, right: i.right - (e.left + n.width), bottom: i.bottom - (e.top + n.height),
                        }, y.verbose('Distance from boundaries determined', e, o)), o;
                    },
                    offsetParent(t) { const n = void 0 !== t ? t[0] : P[0]; let i = n.parentNode; let o = e(i); if (i) for (let a = o.css('transform') === 'none', r = o.css('position') === 'static', s = o.is('html'); i && !s && r && a;)i = i.parentNode, o = e(i), a = o.css('transform') === 'none', r = o.css('position') === 'static', s = o.is('html'); return o && o.length > 0 ? o : e(); },
                    positions() {
                        return {
                            'top left': !1, 'top center': !1, 'top right': !1, 'bottom left': !1, 'bottom center': !1, 'bottom right': !1, 'left center': !1, 'right center': !1,
                        };
                    },
                    nextPosition(e) {
                        const t = e.split(' '); const n = t[0]; const i = t[1]; const o = {
                            top: 'bottom', bottom: 'top', left: 'right', right: 'left',
                        }; const a = { left: 'center', center: 'right', right: 'left' }; const r = {
                            'top left': 'top center', 'top center': 'top right', 'top right': 'right center', 'right center': 'bottom right', 'bottom right': 'bottom center', 'bottom center': 'bottom left', 'bottom left': 'left center', 'left center': 'top left',
                        }; const s = n == 'top' || n == 'bottom'; let l = !1; let c = !1; let u = !1; return j || (y.verbose('All available positions available'), j = y.get.positions()), y.debug('Recording last position tried', e), j[e] = !0, x.prefer === 'opposite' && (u = [o[n], i], u = u.join(' '), l = !0 === j[u], y.debug('Trying opposite strategy', u)), x.prefer === 'adjacent' && s && (u = [n, a[i]], u = u.join(' '), c = !0 === j[u], y.debug('Trying adjacent strategy', u)), (c || l) && (y.debug('Using backup position', u), u = r[e]), u;
                    },
                },
                set: {
                    position(e, t) {
                        if (D.length === 0 || a.length === 0) return void y.error(k.notFound); let n; let i; let o; let r; let s; let l; let c; let u; if (t = t || y.get.calculations(), e = e || P.data(S.position) || x.position, n = P.data(S.offset) || x.offset, i = x.distanceAway, o = t.target, r = t.popup, s = t.parent, o.width === 0 && o.height === 0 && !y.is.svg(o.element)) return y.debug('Popup target is hidden, no action taken'), !1; switch (x.inline && (y.debug('Adding margin to calculation', o.margin), e == 'left center' || e == 'right center' ? (n += o.margin.top, i += -o.margin.left) : e == 'top left' || e == 'top center' || e == 'top right' ? (n += o.margin.left, i -= o.margin.top) : (n += o.margin.left, i += o.margin.top)), y.debug('Determining popup position from calculations', e, t), y.is.rtl() && (e = e.replace(/left|right/g, function(e) { return e == 'left' ? 'right' : 'left'; }), y.debug('RTL: Popup position updated', e)), q == x.maxSearchDepth && typeof x.lastResort === 'string' && (e = x.lastResort), e) {
                        case 'top left':l = {
                            top: 'auto', bottom: s.height - o.top + i, left: o.left + n, right: 'auto',
                        }; break; case 'top center':l = {
                            bottom: s.height - o.top + i, left: o.left + o.width / 2 - r.width / 2 + n, top: 'auto', right: 'auto',
                        }; break; case 'top right':l = {
                            bottom: s.height - o.top + i, right: s.width - o.left - o.width - n, top: 'auto', left: 'auto',
                        }; break; case 'left center':l = {
                            top: o.top + o.height / 2 - r.height / 2 + n, right: s.width - o.left + i, left: 'auto', bottom: 'auto',
                        }; break; case 'right center':l = {
                            top: o.top + o.height / 2 - r.height / 2 + n, left: o.left + o.width + i, bottom: 'auto', right: 'auto',
                        }; break; case 'bottom left':l = {
                            top: o.top + o.height + i, left: o.left + n, bottom: 'auto', right: 'auto',
                        }; break; case 'bottom center':l = {
                            top: o.top + o.height + i, left: o.left + o.width / 2 - r.width / 2 + n, bottom: 'auto', right: 'auto',
                        }; break; case 'bottom right':l = {
                            top: o.top + o.height + i, right: s.width - o.left - o.width - n, left: 'auto', bottom: 'auto',
                        };
                        } if (void 0 === l && y.error(k.invalidPosition, e), y.debug('Calculated popup positioning values', l), a.css(l).removeClass(w.position).addClass(e).addClass(w.loading), c = y.get.popupOffset(), u = y.get.distanceFromBoundary(c, t), y.is.offstage(u, e)) { if (y.debug('Position is outside viewport', e), q < x.maxSearchDepth) return q++, e = y.get.nextPosition(e), y.debug('Trying new position', e), !!a && y.set.position(e, t); if (!x.lastResort) return y.debug('Popup could not find a position to display', a), y.error(k.cannotPlace, I), y.remove.attempts(), y.remove.loading(), y.reset(), x.onUnplaceable.call(a, I), !1; y.debug('No position found, showing with last position'); } return y.debug('Position is on stage', e), y.remove.attempts(), y.remove.loading(), x.setFluidWidth && y.is.fluid() && y.set.fluidWidth(t), !0;
                    },
                    fluidWidth(e) { e = e || y.get.calculations(), y.debug('Automatically setting element width to parent width', e.parent.width), a.css('width', e.container.width); },
                    variation(e) { (e = e || y.get.variation()) && y.has.popup() && (y.verbose('Adding variation to popup', e), a.addClass(e)); },
                    visible() { P.addClass(w.visible); },
                },
                remove: {
                    loading() { a.removeClass(w.loading); }, variation(e) { (e = e || y.get.variation()) && (y.verbose('Removing variation', e), a.removeClass(e)); }, visible() { P.removeClass(w.visible); }, attempts() { y.verbose('Resetting all searched positions'), q = 0, j = !1; },
                },
                bind: {
                    events() { y.debug('Binding popup events to module'), x.on == 'click' && P.on(`click${A}`, y.toggle), x.on == 'hover' && P.on(`touchstart${A}`, y.event.touchstart), y.get.startEvent() && P.on(y.get.startEvent() + A, y.event.start).on(y.get.endEvent() + A, y.event.end), x.target && y.debug('Target set to element', D), s.on(`resize${h}`, y.event.resize); }, popup() { y.verbose('Allowing hover events on popup to prevent closing'), a && y.has.popup() && a.on(`mouseenter${A}`, y.event.start).on(`mouseleave${A}`, y.event.end); }, close() { (!0 === x.hideOnScroll || x.hideOnScroll == 'auto' && x.on != 'click') && y.bind.closeOnScroll(), x.on == 'hover' && z && y.bind.touchClose(), x.on == 'click' && x.closable && y.bind.clickaway(); }, closeOnScroll() { y.verbose('Binding scroll close event to document'), F.one(y.get.scrollEvent() + h, y.event.hideGracefully); }, touchClose() { y.verbose('Binding popup touchclose event to document'), r.on(`touchstart${h}`, function(e) { y.verbose('Touched away from popup'), y.event.hideGracefully.call(I, e); }); }, clickaway() { y.verbose('Binding popup close event to document'), r.on(`click${h}`, function(e) { y.verbose('Clicked away from popup'), y.event.hideGracefully.call(I, e); }); },
                },
                unbind: { events() { s.off(h), P.off(A); }, close() { r.off(h), F.off(h); } },
                has: { popup() { return a && a.length > 0; } },
                is: {
                    offstage(t, n) { const i = []; return e.each(t, function(e, t) { t < -x.jitter && (y.debug('Position exceeds allowable distance from edge', e, t, n), i.push(e)); }), i.length > 0; }, svg(e) { return y.supports.svg() && e instanceof SVGGraphicsElement; }, active() { return P.hasClass(w.active); }, animating() { return void 0 !== a && a.hasClass(w.animating); }, fluid() { return void 0 !== a && a.hasClass(w.fluid); }, visible() { return void 0 !== a && a.hasClass(w.popupVisible); }, dropdown() { return P.hasClass(w.dropdown); }, hidden() { return !y.is.visible(); }, rtl() { return P.css('direction') == 'rtl'; },
                },
                reset() { y.remove.visible(), x.preserve ? void 0 !== e.fn.transition && a.transition('remove transition') : y.removePopup(); },
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, x, t); else { if (void 0 === n) return x[t]; x[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, y, t); else { if (void 0 === n) return y[t]; y[t] = n; } },
                debug() { !x.silent && x.debug && (x.performance ? y.performance.log(arguments) : (y.debug = Function.prototype.bind.call(console.info, console, `${x.name}:`), y.debug.apply(console, arguments))); },
                verbose() { !x.silent && x.verbose && x.debug && (x.performance ? y.performance.log(arguments) : (y.verbose = Function.prototype.bind.call(console.info, console, `${x.name}:`), y.verbose.apply(console, arguments))); },
                error() { x.silent || (y.error = Function.prototype.bind.call(console.error, console, `${x.name}:`), y.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; x.performance && (t = (new Date()).getTime(), i = u || t, n = t - i, u = t, d.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: I, 'Execution Time': n,
                        })), clearTimeout(y.performance.timer), y.performance.timer = setTimeout(y.performance.display, 500);
                    },
                    display() { let t = `${x.name}:`; let n = 0; u = !1, clearTimeout(y.performance.timer), e.each(d, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, c && (t += ` '${c}'`), (void 0 !== console.group || void 0 !== console.table) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), d = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = M; return n = n || g, i = I || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, m ? (void 0 === M && y.initialize(), y.invoke(f)) : (void 0 !== M && M.invoke('destroy'), y.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.popup.settings = {
        name: 'Popup',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        namespace: 'popup',
        observeChanges: !0,
        onCreate() {},
        onRemove() {},
        onShow() {},
        onVisible() {},
        onHide() {},
        onUnplaceable() {},
        onHidden() {},
        on: 'hover',
        boundary: t,
        addTouchEvents: !0,
        position: 'top left',
        variation: '',
        movePopup: !0,
        target: !1,
        popup: !1,
        inline: !1,
        preserve: !1,
        hoverable: !1,
        content: !1,
        html: !1,
        title: !1,
        closable: !0,
        hideOnScroll: 'auto',
        exclusive: !1,
        context: 'body',
        scrollContext: t,
        prefer: 'opposite',
        lastResort: !1,
        delay: { show: 50, hide: 70 },
        setFluidWidth: !0,
        duration: 200,
        transition: 'scale',
        distanceAway: 0,
        jitter: 2,
        offset: 0,
        maxSearchDepth: 15,
        error: {
            invalidPosition: 'The position you specified is not a valid position', cannotPlace: 'Popup does not fit within the boundaries of the viewport', method: 'The method you called is not defined.', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>', notFound: 'The target or popup you specified does not exist on the page',
        },
        metadata: {
            activator: 'activator', content: 'content', html: 'html', offset: 'offset', position: 'position', title: 'title', variation: 'variation',
        },
        className: {
            active: 'active', animating: 'animating', dropdown: 'dropdown', fluid: 'fluid', loading: 'loading', popup: 'ui popup', position: 'top left center bottom right', visible: 'visible', popupVisible: 'visible',
        },
        selector: { popup: '.ui.popup' },
        templates: {
            escape(e) {
                const t = /[&<>"'`]/g; const n = /[&<>"'`]/; const i = {
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
                }; const o = function(e) { return i[e]; }; return n.test(e) ? e.replace(t, o) : e;
            },
            popup(t) { let n = ''; const i = e.fn.popup.settings.templates.escape; return void 0 !== typeof t && (void 0 !== typeof t.title && t.title && (t.title = i(t.title), n += `<div class="header">${t.title}</div>`), void 0 !== typeof t.content && t.content && (t.content = i(t.content), n += `<div class="content">${t.content}</div>`)), n; },
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); void 0 !== t && t.Math == Math || (typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')()); e.fn.progress = function(t) {
        let i; const o = e(this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); return o.each(function() {
            let o; let d; const f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.progress.settings, t) : e.extend({}, e.fn.progress.settings); const m = f.className; const g = f.metadata; const v = f.namespace; const p = f.selector; const h = f.error; const b = `.${v}`; const y = `module-${v}`; const x = e(this); const C = e(this).find(p.bar); const w = e(this).find(p.progress); const k = e(this).find(p.label); const S = this; let T = x.data(y); let A = !1; d = {
                initialize() { d.debug('Initializing progress bar', f), d.set.duration(), d.set.transitionEvent(), d.read.metadata(), d.read.settings(), d.instantiate(); },
                instantiate() { d.verbose('Storing instance of progress', d), T = d, x.data(y, d); },
                destroy() { d.verbose('Destroying previous progress for', x), clearInterval(T.interval), d.remove.state(), x.removeData(y), T = void 0; },
                reset() { d.remove.nextValue(), d.update.progress(0); },
                complete() { (void 0 === d.percent || d.percent < 100) && (d.remove.progressPoll(), d.set.percent(100)); },
                read: { metadata() { const e = { percent: x.data(g.percent), total: x.data(g.total), value: x.data(g.value) }; e.percent && (d.debug('Current percent value set from metadata', e.percent), d.set.percent(e.percent)), e.total && (d.debug('Total value set from metadata', e.total), d.set.total(e.total)), e.value && (d.debug('Current value set from metadata', e.value), d.set.value(e.value), d.set.progress(e.value)); }, settings() { !1 !== f.total && (d.debug('Current total set in settings', f.total), d.set.total(f.total)), !1 !== f.value && (d.debug('Current value set in settings', f.value), d.set.value(f.value), d.set.progress(d.value)), !1 !== f.percent && (d.debug('Current percent set in settings', f.percent), d.set.percent(f.percent)); } },
                bind: { transitionEnd(e) { const t = d.get.transitionEnd(); C.one(t + b, function(t) { clearTimeout(d.failSafeTimer), e.call(this, t); }), d.failSafeTimer = setTimeout(function() { C.triggerHandler(t); }, f.duration + f.failSafeDelay), d.verbose('Adding fail safe timer', d.timer); } },
                increment(e) { let t; let n; d.has.total() ? (t = d.get.value(), e = e || 1, n = t + e) : (t = d.get.percent(), e = e || d.get.randomValue(), n = t + e, 100, d.debug('Incrementing percentage by', t, n)), n = d.get.normalizedValue(n), d.set.progress(n); },
                decrement(e) { let t; let n; const i = d.get.total(); i ? (t = d.get.value(), e = e || 1, n = t - e, d.debug('Decrementing value by', e, t)) : (t = d.get.percent(), e = e || d.get.randomValue(), n = t - e, d.debug('Decrementing percentage by', e, t)), n = d.get.normalizedValue(n), d.set.progress(n); },
                has: { progressPoll() { return d.progressPoll; }, total() { return !1 !== d.get.total(); } },
                get: {
                    text(e) { const t = d.value || 0; const n = d.total || 0; const i = A ? d.get.displayPercent() : d.percent || 0; const o = d.total > 0 ? n - t : 100 - i; return e = e || '', e = e.replace('{value}', t).replace('{total}', n).replace('{left}', o).replace('{percent}', i), d.verbose('Adding variables to progress bar text', e), e; },
                    normalizedValue(e) { if (e < 0) return d.debug('Value cannot decrement below 0'), 0; if (d.has.total()) { if (e > d.total) return d.debug('Value cannot increment above total', d.total), d.total; } else if (e > 100) return d.debug('Value cannot increment above 100 percent'), 100; return e; },
                    updateInterval() { return f.updateInterval == 'auto' ? f.duration : f.updateInterval; },
                    randomValue() { return d.debug('Generating random increment percentage'), Math.floor(Math.random() * f.random.max + f.random.min); },
                    numericValue(e) { return typeof e === 'string' ? e.replace(/[^\d.]/g, '') !== '' && +e.replace(/[^\d.]/g, '') : e; },
                    transitionEnd() {
                        let e; const t = n.createElement('element'); const i = {
                            transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
                        }; for (e in i) if (void 0 !== t.style[e]) return i[e];
                    },
                    displayPercent() { const e = C.width(); const t = x.width(); const n = parseInt(C.css('min-width'), 10); const i = e > n ? e / t * 100 : d.percent; return f.precision > 0 ? Math.round(i * (10 * f.precision)) / (10 * f.precision) : Math.round(i); },
                    percent() { return d.percent || 0; },
                    value() { return d.nextValue || d.value || 0; },
                    total() { return d.total || !1; },
                },
                create: { progressPoll() { d.progressPoll = setTimeout(function() { d.update.toNextValue(), d.remove.progressPoll(); }, d.get.updateInterval()); } },
                is: {
                    complete() { return d.is.success() || d.is.warning() || d.is.error(); }, success() { return x.hasClass(m.success); }, warning() { return x.hasClass(m.warning); }, error() { return x.hasClass(m.error); }, active() { return x.hasClass(m.active); }, visible() { return x.is(':visible'); },
                },
                remove: {
                    progressPoll() { d.verbose('Removing progress poll timer'), d.progressPoll && (clearTimeout(d.progressPoll), delete d.progressPoll); }, nextValue() { d.verbose('Removing progress value stored for next update'), delete d.nextValue; }, state() { d.verbose('Removing stored state'), delete d.total, delete d.percent, delete d.value; }, active() { d.verbose('Removing active state'), x.removeClass(m.active); }, success() { d.verbose('Removing success state'), x.removeClass(m.success); }, warning() { d.verbose('Removing warning state'), x.removeClass(m.warning); }, error() { d.verbose('Removing error state'), x.removeClass(m.error); },
                },
                set: {
                    barWidth(e) { e > 100 ? d.error(h.tooHigh, e) : e < 0 ? d.error(h.tooLow, e) : (C.css('width', `${e}%`), x.attr('data-percent', parseInt(e, 10))); }, duration(e) { e = e || f.duration, e = typeof e === 'number' ? `${e}ms` : e, d.verbose('Setting progress bar transition duration', e), C.css({ 'transition-duration': e }); }, percent(e) { e = typeof e === 'string' ? +e.replace('%', '') : e, e = f.precision > 0 ? Math.round(e * (10 * f.precision)) / (10 * f.precision) : Math.round(e), d.percent = e, d.has.total() || (d.value = f.precision > 0 ? Math.round(e / 100 * d.total * (10 * f.precision)) / (10 * f.precision) : Math.round(e / 100 * d.total * 10) / 10, f.limitValues && (d.value = d.value > 100 ? 100 : d.value < 0 ? 0 : d.value)), d.set.barWidth(e), d.set.labelInterval(), d.set.labels(), f.onChange.call(S, e, d.value, d.total); }, labelInterval() { const t = function() { d.verbose('Bar finished animating, removing continuous label updates'), clearInterval(d.interval), A = !1, d.set.labels(); }; clearInterval(d.interval), d.bind.transitionEnd(t), A = !0, d.interval = setInterval(function() { e.contains(n.documentElement, S) || (clearInterval(d.interval), A = !1), d.set.labels(); }, f.framerate); }, labels() { d.verbose('Setting both bar progress and outer label text'), d.set.barLabel(), d.set.state(); }, label(e) { (e = e || '') && (e = d.get.text(e), d.verbose('Setting label to text', e), k.text(e)); }, state(e) { e = void 0 !== e ? e : d.percent, e === 100 ? f.autoSuccess && !(d.is.warning() || d.is.error() || d.is.success()) ? (d.set.success(), d.debug('Automatically triggering success at 100%')) : (d.verbose('Reached 100% removing active state'), d.remove.active(), d.remove.progressPoll()) : e > 0 ? (d.verbose('Adjusting active progress bar label', e), d.set.active()) : (d.remove.active(), d.set.label(f.text.active)); }, barLabel(e) { void 0 !== e ? w.text(d.get.text(e)) : f.label == 'ratio' && d.total ? (d.verbose('Adding ratio to bar label'), w.text(d.get.text(f.text.ratio))) : f.label == 'percent' && (d.verbose('Adding percentage to bar label'), w.text(d.get.text(f.text.percent))); }, active(e) { e = e || f.text.active, d.debug('Setting active state'), f.showActivity && !d.is.active() && x.addClass(m.active), d.remove.warning(), d.remove.error(), d.remove.success(), e = f.onLabelUpdate('active', e, d.value, d.total), e && d.set.label(e), d.bind.transitionEnd(function() { f.onActive.call(S, d.value, d.total); }); }, success(e) { e = e || f.text.success || f.text.active, d.debug('Setting success state'), x.addClass(m.success), d.remove.active(), d.remove.warning(), d.remove.error(), d.complete(), f.text.success ? (e = f.onLabelUpdate('success', e, d.value, d.total), d.set.label(e)) : (e = f.onLabelUpdate('active', e, d.value, d.total), d.set.label(e)), d.bind.transitionEnd(function() { f.onSuccess.call(S, d.total); }); }, warning(e) { e = e || f.text.warning, d.debug('Setting warning state'), x.addClass(m.warning), d.remove.active(), d.remove.success(), d.remove.error(), d.complete(), e = f.onLabelUpdate('warning', e, d.value, d.total), e && d.set.label(e), d.bind.transitionEnd(function() { f.onWarning.call(S, d.value, d.total); }); }, error(e) { e = e || f.text.error, d.debug('Setting error state'), x.addClass(m.error), d.remove.active(), d.remove.success(), d.remove.warning(), d.complete(), e = f.onLabelUpdate('error', e, d.value, d.total), e && d.set.label(e), d.bind.transitionEnd(function() { f.onError.call(S, d.value, d.total); }); }, transitionEvent() { o = d.get.transitionEnd(); }, total(e) { d.total = e; }, value(e) { d.value = e; }, progress(e) { d.has.progressPoll() ? (d.debug('Updated within interval, setting next update to use new value', e), d.set.nextValue(e)) : (d.debug('First update in progress update interval, immediately updating', e), d.update.progress(e), d.create.progressPoll()); }, nextValue(e) { d.nextValue = e; },
                },
                update: { toNextValue() { const e = d.nextValue; e && (d.debug('Update interval complete using last updated value', e), d.update.progress(e), d.remove.nextValue()); }, progress(e) { let t; e = d.get.numericValue(e), !1 === e && d.error(h.nonNumeric, e), e = d.get.normalizedValue(e), d.has.total() ? (d.set.value(e), t = e / d.total * 100, d.debug('Calculating percent complete from total', t), d.set.percent(t)) : (t = e, d.debug('Setting value to exact percentage value', t), d.set.percent(t)); } },
                setting(t, n) { if (d.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: S, 'Execution Time': n,
                        })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                    },
                    display() { let t = `${f.name}:`; let n = 0; r = !1, clearTimeout(d.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, n, o) { let a; let r; let s; let l = T; return n = n || u, o = S || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (d.error(h.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r; },
            }, c ? (void 0 === T && d.initialize(), d.invoke(l)) : (void 0 !== T && T.invoke('destroy'), d.initialize());
        }), void 0 !== i ? i : this;
    }, e.fn.progress.settings = {
        name: 'Progress',
        namespace: 'progress',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        random: { min: 2, max: 5 },
        duration: 300,
        updateInterval: 'auto',
        autoSuccess: !0,
        showActivity: !0,
        limitValues: !0,
        label: 'percent',
        precision: 0,
        framerate: 1e3 / 30,
        percent: !1,
        total: !1,
        value: !1,
        failSafeDelay: 100,
        onLabelUpdate(e, t, n, i) { return t; },
        onChange(e, t, n) {},
        onSuccess(e) {},
        onActive(e, t) {},
        onError(e, t) {},
        onWarning(e, t) {},
        error: {
            method: 'The method you called is not defined.', nonNumeric: 'Progress value is non numeric', tooHigh: 'Value specified is above 100%', tooLow: 'Value specified is below 0%',
        },
        regExp: { variable: /\{\$*[A-z0-9]+\}/g },
        metadata: { percent: 'percent', total: 'total', value: 'value' },
        selector: { bar: '> .bar', label: '> .label', progress: '.bar > .progress' },
        text: {
            active: !1,
            error: !1,
            success: !1,
            warning: !1,
            percent: '{percent}%',
            ratio: '{value} of {total}',
        },
        className: {
            active: 'active', error: 'error', success: 'success', warning: 'warning',
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.rating = function(t) {
        let n; const i = e(this); const o = i.selector || ''; let a = (new Date()).getTime(); let r = []; const s = arguments[0]; const l = typeof s === 'string'; const c = [].slice.call(arguments, 1); return i.each(function() {
            let u; let d; const f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.rating.settings, t) : e.extend({}, e.fn.rating.settings); const m = f.namespace; const g = f.className; const v = f.metadata; const p = f.selector; const h = (f.error, `.${m}`); const b = `module-${m}`; const y = this; let x = e(this).data(b); const C = e(this); let w = C.find(p.icon); d = {
                initialize() { d.verbose('Initializing rating module', f), w.length === 0 && d.setup.layout(), f.interactive ? d.enable() : d.disable(), d.set.initialLoad(), d.set.rating(d.get.initialRating()), d.remove.initialLoad(), d.instantiate(); },
                instantiate() { d.verbose('Instantiating module', f), x = d, C.data(b, d); },
                destroy() { d.verbose('Destroying previous instance', x), d.remove.events(), C.removeData(b); },
                refresh() { w = C.find(p.icon); },
                setup: { layout() { const t = d.get.maxRating(); const n = e.fn.rating.settings.templates.icon(t); d.debug('Generating icon html dynamically'), C.html(n), d.refresh(); } },
                event: { mouseenter() { const t = e(this); t.nextAll().removeClass(g.selected), C.addClass(g.selected), t.addClass(g.selected).prevAll().addClass(g.selected); }, mouseleave() { C.removeClass(g.selected), w.removeClass(g.selected); }, click() { const t = e(this); const n = d.get.rating(); const i = w.index(t) + 1; (f.clearable == 'auto' ? w.length === 1 : f.clearable) && n == i ? d.clearRating() : d.set.rating(i); } },
                clearRating() { d.debug('Clearing current rating'), d.set.rating(0); },
                bind: { events() { d.verbose('Binding events'), C.on(`mouseenter${h}`, p.icon, d.event.mouseenter).on(`mouseleave${h}`, p.icon, d.event.mouseleave).on(`click${h}`, p.icon, d.event.click); } },
                remove: { events() { d.verbose('Removing events'), C.off(h); }, initialLoad() { u = !1; } },
                enable() { d.debug('Setting rating to interactive mode'), d.bind.events(), C.removeClass(g.disabled); },
                disable() { d.debug('Setting rating to read-only mode'), d.remove.events(), C.addClass(g.disabled); },
                is: { initialLoad() { return u; } },
                get: { initialRating() { return void 0 !== C.data(v.rating) ? (C.removeData(v.rating), C.data(v.rating)) : f.initialRating; }, maxRating() { return void 0 !== C.data(v.maxRating) ? (C.removeData(v.maxRating), C.data(v.maxRating)) : f.maxRating; }, rating() { const e = w.filter(`.${g.active}`).length; return d.verbose('Current rating retrieved', e), e; } },
                set: { rating(e) { const t = e - 1 >= 0 ? e - 1 : 0; const n = w.eq(t); C.removeClass(g.selected), w.removeClass(g.selected).removeClass(g.active), e > 0 && (d.verbose('Setting current rating to', e), n.prevAll().addBack().addClass(g.active)), d.is.initialLoad() || f.onRate.call(y, e); }, initialLoad() { u = !0; } },
                setting(t, n) { if (d.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = a || t, n = t - i, a = t, r.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: y, 'Execution Time': n,
                        })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                    },
                    display() { let t = `${f.name}:`; let n = 0; a = !1, clearTimeout(d.performance.timer), e.each(r, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, o && (t += ` '${o}'`), i.length > 1 && (t += ` (${i.length})`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), r = []; },
                },
                invoke(t, i, o) { let a; let r; let s; let l = x; return i = i || c, o = y || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, i) : void 0 !== r && (s = r), e.isArray(n) ? n.push(s) : void 0 !== n ? n = [n, s] : void 0 !== s && (n = s), r; },
            }, l ? (void 0 === x && d.initialize(), d.invoke(s)) : (void 0 !== x && x.invoke('destroy'), d.initialize());
        }), void 0 !== n ? n : this;
    }, e.fn.rating.settings = {
        name: 'Rating',
        namespace: 'rating',
        slent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        initialRating: 0,
        interactive: !0,
        maxRating: 4,
        clearable: 'auto',
        fireOnInit: !1,
        onRate(e) {},
        error: { method: 'The method you called is not defined', noMaximum: 'No maximum rating specified. Cannot generate HTML automatically' },
        metadata: { rating: 'rating', maxRating: 'maxRating' },
        className: {
            active: 'active', disabled: 'disabled', selected: 'selected', loading: 'loading',
        },
        selector: { icon: '.icon' },
        templates: { icon(e) { for (var t = 1, n = ''; t <= e;)n += '<i class="icon"></i>', t++; return n; } },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.search = function(i) {
        let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let l = []; const c = arguments[0]; const u = typeof c === 'string'; const d = [].slice.call(arguments, 1); return e(this).each(function() {
            let f; const m = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.search.settings, i) : e.extend({}, e.fn.search.settings); const g = m.className; const v = m.metadata; const p = m.regExp; const h = m.fields; const b = m.selector; const y = m.error; const x = m.namespace; const C = `.${x}`; const w = `${x}-module`; const k = e(this); let S = k.find(b.prompt); let T = k.find(b.searchButton); let A = k.find(b.results); let R = k.find(b.result); let P = k.find(b.category); const E = this; let F = k.data(w); let O = !1; let D = !1; f = {
                initialize() { f.verbose('Initializing module'), f.determine.searchFields(), f.bind.events(), f.set.type(), f.create.results(), f.instantiate(); },
                instantiate() { f.verbose('Storing instance of module', f), F = f, k.data(w, f); },
                destroy() { f.verbose('Destroying instance'), k.off(C).removeData(w); },
                refresh() { f.debug('Refreshing selector cache'), S = k.find(b.prompt), T = k.find(b.searchButton), P = k.find(b.category), A = k.find(b.results), R = k.find(b.result); },
                refreshResults() { A = k.find(b.results), R = k.find(b.result); },
                bind: {
                    events() {
                        f.verbose('Binding events to search'), m.automatic && (k.on(f.get.inputEvent() + C, b.prompt, f.event.input), S.attr('autocomplete', 'off')), k.on(`focus${C}`, b.prompt, f.event.focus).on(`blur${C}`, b.prompt, f.event.blur).on(`keydown${C}`, b.prompt, f.handleKeyboard).on(`click${C}`, b.searchButton, f.query)
                            .on(`mousedown${C}`, b.results, f.event.result.mousedown)
                            .on(`mouseup${C}`, b.results, f.event.result.mouseup)
                            .on(`click${C}`, b.result, f.event.result.click);
                    },
                },
                determine: { searchFields() { i && void 0 !== i.searchFields && (m.searchFields = i.searchFields); } },
                event: {
                    input() { m.searchDelay ? (clearTimeout(f.timer), f.timer = setTimeout(function() { f.is.focused() && f.query(); }, m.searchDelay)) : f.query(); }, focus() { f.set.focus(), m.searchOnFocus && f.has.minimumCharacters() && f.query(function() { f.can.show() && f.showResults(); }); }, blur(e) { const t = n.activeElement === this; const i = function() { f.cancel.query(), f.remove.focus(), f.timer = setTimeout(f.hideResults, m.hideDelay); }; t || (D = !1, f.resultsClicked ? (f.debug('Determining if user action caused search to close'), k.one(`click.close${C}`, b.results, function(e) { if (f.is.inMessage(e) || O) return void S.focus(); O = !1, f.is.animating() || f.is.hidden() || i(); })) : (f.debug('Input blurred without user action, closing results'), i())); }, result: { mousedown() { f.resultsClicked = !0; }, mouseup() { f.resultsClicked = !1; }, click(n) { f.debug('Search result selected'); const i = e(this); const o = i.find(b.title).eq(0); const a = i.is('a[href]') ? i : i.find('a[href]').eq(0); const r = a.attr('href') || !1; const s = a.attr('target') || !1; const l = (o.html(), o.length > 0 && o.text()); const c = f.get.results(); const u = i.data(v.result) || f.get.result(l, c); if (e.isFunction(m.onSelect) && !1 === m.onSelect.call(E, u, c)) return f.debug('Custom onSelect callback cancelled default select action'), void (O = !0); f.hideResults(), l && f.set.value(l), r && (f.verbose('Opening search link found in result', a), s == '_blank' || n.ctrlKey ? t.open(r) : t.location.href = r); } },
                },
                handleKeyboard(e) {
                    let t; const n = k.find(b.result); const i = k.find(b.category); const o = n.filter(`.${g.active}`); const a = n.index(o); const r = n.length; const s = o.length > 0; const l = e.which; const c = {
                        backspace: 8, enter: 13, escape: 27, upArrow: 38, downArrow: 40,
                    }; if (l == c.escape && (f.verbose('Escape key pressed, blurring search field'), f.hideResults(), D = !0), f.is.visible()) {
                        if (l == c.enter) { if (f.verbose('Enter key pressed, selecting active result'), n.filter(`.${g.active}`).length > 0) return f.event.result.click.call(n.filter(`.${g.active}`), e), e.preventDefault(), !1; } else {
                            l == c.upArrow && s ? (f.verbose('Up key pressed, changing active result'), t = a - 1 < 0 ? a : a - 1, i.removeClass(g.active), n.removeClass(g.active).eq(t).addClass(g.active).closest(i)
                                .addClass(g.active), e.preventDefault()) : l == c.downArrow && (f.verbose('Down key pressed, changing active result'), t = a + 1 >= r ? a : a + 1, i.removeClass(g.active), n.removeClass(g.active).eq(t).addClass(g.active).closest(i)
                                .addClass(g.active), e.preventDefault());
                        }
                    } else l == c.enter && (f.verbose('Enter key pressed, executing query'), f.query(), f.set.buttonPressed(), S.one('keyup', f.remove.buttonFocus));
                },
                setup: {
                    api(t, n) {
                        const i = {
                            debug: m.debug, on: !1, cache: !0, action: 'search', urlData: { query: t }, onSuccess(e) { f.parse.response.call(E, e, t), n(); }, onFailure() { f.displayMessage(y.serverError), n(); }, onAbort(e) {}, onError: f.error,
                        }; e.extend(!0, i, m.apiSettings), f.verbose('Setting up API request', i), k.api(i);
                    },
                },
                can: { useAPI() { return void 0 !== e.fn.api; }, show() { return f.is.focused() && !f.is.visible() && !f.is.empty(); }, transition() { return m.transition && void 0 !== e.fn.transition && k.transition('is supported'); } },
                is: {
                    animating() { return A.hasClass(g.animating); }, hidden() { return A.hasClass(g.hidden); }, inMessage(t) { if (t.target) { const i = e(t.target); return e.contains(n.documentElement, t.target) && i.closest(b.message).length > 0; } }, empty() { return A.html() === ''; }, visible() { return A.filter(':visible').length > 0; }, focused() { return S.filter(':focus').length > 0; },
                },
                get: {
                    inputEvent() { const e = S[0]; return void 0 !== e && void 0 !== e.oninput ? 'input' : void 0 !== e && void 0 !== e.onpropertychange ? 'propertychange' : 'keyup'; }, value() { return S.val(); }, results() { return k.data(v.results); }, result(t, n) { const i = ['title', 'id']; let o = !1; return t = void 0 !== t ? t : f.get.value(), n = void 0 !== n ? n : f.get.results(), m.type === 'category' ? (f.debug('Finding result that matches', t), e.each(n, function(n, a) { if (e.isArray(a.results) && (o = f.search.object(t, a.results, i)[0])) return !1; })) : (f.debug('Finding result in results object', t), o = f.search.object(t, n, i)[0]), o || !1; },
                },
                select: { firstResult() { f.verbose('Selecting first result'), R.first().addClass(g.active); } },
                set: {
                    focus() { k.addClass(g.focus); }, loading() { k.addClass(g.loading); }, value(e) { f.verbose('Setting search input value', e), S.val(e); }, type(e) { e = e || m.type, m.type == 'category' && k.addClass(m.type); }, buttonPressed() { T.addClass(g.pressed); },
                },
                remove: { loading() { k.removeClass(g.loading); }, focus() { k.removeClass(g.focus); }, buttonPressed() { T.removeClass(g.pressed); } },
                query(t) { t = e.isFunction(t) ? t : function() {}; const n = f.get.value(); const i = f.read.cache(n); t = t || function() {}, f.has.minimumCharacters() ? (i ? (f.debug('Reading result from cache', n), f.save.results(i.results), f.addResults(i.html), f.inject.id(i.results), t()) : (f.debug('Querying for', n), e.isPlainObject(m.source) || e.isArray(m.source) ? (f.search.local(n), t()) : f.can.useAPI() ? f.search.remote(n, t) : (f.error(y.source), t())), m.onSearchQuery.call(E, n)) : f.hideResults(); },
                search: { local(e) { let t; const n = f.search.object(e, m.content); f.set.loading(), f.save.results(n), f.debug('Returned local search results', n), t = f.generateResults({ results: n }), f.remove.loading(), f.addResults(t), f.inject.id(n), f.write.cache(e, { html: t, results: n }); }, remote(t, n) { n = e.isFunction(n) ? n : function() {}, k.api('is loading') && k.api('abort'), f.setup.api(t, n), k.api('query'); }, object(t, n, i) { const o = []; const a = []; const r = t.toString().replace(p.escape, '\\$&'); const s = new RegExp(p.beginsWith + r, 'i'); const l = function(t, n) { const i = e.inArray(n, o) == -1; const r = e.inArray(n, a) == -1; i && r && t.push(n); }; return n = n || m.source, i = void 0 !== i ? i : m.searchFields, e.isArray(i) || (i = [i]), void 0 === n || !1 === n ? (f.error(y.source), []) : (e.each(i, function(i, r) { e.each(n, function(e, n) { typeof n[r] === 'string' && (n[r].search(s) !== -1 ? l(o, n) : m.searchFullText && f.fuzzySearch(t, n[r]) && l(a, n)); }); }), e.merge(o, a)); } },
                fuzzySearch(e, t) { const n = t.length; const i = e.length; if (typeof e !== 'string') return !1; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; o < i; o++) { for (let r = e.charCodeAt(o); a < n;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0; },
                parse: { response(e, t) { const n = f.generateResults(e); f.verbose('Parsing server response', e), void 0 !== e && void 0 !== t && void 0 !== e[h.results] && (f.addResults(n), f.inject.id(e[h.results]), f.write.cache(t, { html: n, results: e[h.results] }), f.save.results(e[h.results])); } },
                cancel: { query() { f.can.useAPI() && k.api('abort'); } },
                has: { minimumCharacters() { return f.get.value().length >= m.minCharacters; }, results() { return A.length !== 0 && A.html() != ''; } },
                clear: { cache(e) { const t = k.data(v.cache); e ? e && t && t[e] && (f.debug('Removing value from cache', e), delete t[e], k.data(v.cache, t)) : (f.debug('Clearing cache', e), k.removeData(v.cache)); } },
                read: { cache(e) { const t = k.data(v.cache); return !!m.cache && (f.verbose('Checking cache for generated html for query', e), typeof t === 'object' && void 0 !== t[e] && t[e]); } },
                create: { id(e, t) { let n; let i; const o = e + 1; return void 0 !== t ? (n = String.fromCharCode(97 + t), i = n + o, f.verbose('Creating category result id', i)) : (i = o, f.verbose('Creating result id', i)), i; }, results() { A.length === 0 && (A = e('<div />').addClass(g.results).appendTo(k)); } },
                inject: { result(e, t, n) { f.verbose('Injecting result into results'); const i = void 0 !== n ? A.children().eq(n).children(b.result).eq(t) : A.children(b.result).eq(t); f.verbose('Injecting results metadata', i), i.data(v.result, e); }, id(t) { f.debug('Injecting unique ids into results'); let n = 0; let i = 0; return m.type === 'category' ? e.each(t, function(t, o) { i = 0, e.each(o.results, function(e, t) { const a = o.results[e]; void 0 === a.id && (a.id = f.create.id(i, n)), f.inject.result(a, i, n), i++; }), n++; }) : e.each(t, function(e, n) { const o = t[e]; void 0 === o.id && (o.id = f.create.id(i)), f.inject.result(o, i), i++; }), t; } },
                save: { results(e) { f.verbose('Saving current search results to metadata', e), k.data(v.results, e); } },
                write: { cache(e, t) { const n = void 0 !== k.data(v.cache) ? k.data(v.cache) : {}; m.cache && (f.verbose('Writing generated html to cache', e, t), n[e] = t, k.data(v.cache, n)); } },
                addResults(t) { if (e.isFunction(m.onResultsAdd) && !1 === m.onResultsAdd.call(A, t)) return f.debug('onResultsAdd callback cancelled default action'), !1; t ? (A.html(t), f.refreshResults(), m.selectFirstResult && f.select.firstResult(), f.showResults()) : f.hideResults(function() { A.empty(); }); },
                showResults(t) {
                    t = e.isFunction(t) ? t : function() {}, D || !f.is.visible() && f.has.results() && (f.can.transition() ? (f.debug('Showing results with css animations'), A.transition({
                        animation: `${m.transition} in`, debug: m.debug, verbose: m.verbose, duration: m.duration, onComplete() { t(); }, queue: !0,
                    })) : (f.debug('Showing results with javascript'), A.stop().fadeIn(m.duration, m.easing)), m.onResultsOpen.call(A));
                },
                hideResults(t) {
                    t = e.isFunction(t) ? t : function() {}, f.is.visible() && (f.can.transition() ? (f.debug('Hiding results with css animations'), A.transition({
                        animation: `${m.transition} out`, debug: m.debug, verbose: m.verbose, duration: m.duration, onComplete() { t(); }, queue: !0,
                    })) : (f.debug('Hiding results with javascript'), A.stop().fadeOut(m.duration, m.easing)), m.onResultsClose.call(A));
                },
                generateResults(t) { f.debug('Generating html from response', t); const n = m.templates[m.type]; const i = e.isPlainObject(t[h.results]) && !e.isEmptyObject(t[h.results]); const o = e.isArray(t[h.results]) && t[h.results].length > 0; let a = ''; return i || o ? (m.maxResults > 0 && (i ? m.type == 'standard' && f.error(y.maxResults) : t[h.results] = t[h.results].slice(0, m.maxResults)), e.isFunction(n) ? a = n(t, h) : f.error(y.noTemplate, !1)) : m.showNoResults && (a = f.displayMessage(y.noResults, 'empty')), m.onResults.call(E, t), a; },
                displayMessage(e, t) { return t = t || 'standard', f.debug('Displaying message', e, t), f.addResults(m.templates.message(e, t)), m.templates.message(e, t); },
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; m[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; f[t] = n; } },
                debug() { !m.silent && m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
                verbose() { !m.silent && m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
                error() { m.silent || (f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: E, 'Execution Time': n,
                        })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                    },
                    display() { let t = `${m.name}:`; let n = 0; s = !1, clearTimeout(f.performance.timer), e.each(l, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), a.length > 1 && (t += ` (${a.length})`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = F; return n = n || d, i = E || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, u ? (void 0 === F && f.initialize(), f.invoke(c)) : (void 0 !== F && F.invoke('destroy'), f.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.search.settings = {
        name: 'Search',
        namespace: 'search',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        type: 'standard',
        minCharacters: 1,
        selectFirstResult: !1,
        apiSettings: !1,
        source: !1,
        searchOnFocus: !0,
        searchFields: ['title', 'description'],
        displayField: '',
        searchFullText: !0,
        automatic: !0,
        hideDelay: 0,
        searchDelay: 200,
        maxResults: 7,
        cache: !0,
        showNoResults: !0,
        transition: 'scale',
        duration: 200,
        easing: 'easeOutExpo',
        onSelect: !1,
        onResultsAdd: !1,
        onSearchQuery(e) {},
        onResults(e) {},
        onResultsOpen() {},
        onResultsClose() {},
        className: {
            animating: 'animating', active: 'active', empty: 'empty', focus: 'focus', hidden: 'hidden', loading: 'loading', results: 'results', pressed: 'down',
        },
        error: {
            source: 'Cannot search. No source used, and Semantic API module was not included', noResults: 'Your search returned no results', logging: 'Error in debug logging, exiting.', noEndpoint: 'No search endpoint was specified', noTemplate: 'A valid template name was not specified.', serverError: 'There was an issue querying the server.', maxResults: 'Results must be an array to use maxResults setting', method: 'The method you called is not defined.',
        },
        metadata: { cache: 'cache', results: 'results', result: 'result' },
        regExp: { escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, beginsWith: '(?:s|^)' },
        fields: {
            categories: 'results', categoryName: 'name', categoryResults: 'results', description: 'description', image: 'image', price: 'price', results: 'results', title: 'title', url: 'url', action: 'action', actionText: 'text', actionURL: 'url',
        },
        selector: {
            prompt: '.prompt', searchButton: '.search.button', results: '.results', message: '.results > .message', category: '.category', result: '.result', title: '.title, .name',
        },
        templates: {
            escape(e) {
                const t = /[&<>"'`]/g; const n = /[&<>"'`]/; const i = {
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
                }; const o = function(e) { return i[e]; }; return n.test(e) ? e.replace(t, o) : e;
            },
            message(e, t) { let n = ''; return void 0 !== e && void 0 !== t && (n += `<div class="message ${t}">`, n += t == 'empty' ? `<div class="header">No Results</div class="header"><div class="description">${e}</div class="description">` : ` <div class="description">${e}</div>`, n += '</div>'), n; },
            category(t, n) { let i = ''; e.fn.search.settings.templates.escape; return void 0 !== t[n.categoryResults] && (e.each(t[n.categoryResults], function(t, o) { void 0 !== o[n.results] && o.results.length > 0 && (i += '<div class="category">', void 0 !== o[n.categoryName] && (i += `<div class="name">${o[n.categoryName]}</div>`), e.each(o.results, function(e, t) { t[n.url] ? i += `<a class="result" href="${t[n.url]}">` : i += '<a class="result">', void 0 !== t[n.image] && (i += `<div class="image"> <img src="${t[n.image]}"></div>`), i += '<div class="content">', void 0 !== t[n.price] && (i += `<div class="price">${t[n.price]}</div>`), void 0 !== t[n.title] && (i += `<div class="title">${t[n.title]}</div>`), void 0 !== t[n.description] && (i += `<div class="description">${t[n.description]}</div>`), i += '</div>', i += '</a>'; }), i += '</div>'); }), t[n.action] && (i += `<a href="${t[n.action][n.actionURL]}" class="action">${t[n.action][n.actionText]}</a>`), i); },
            standard(t, n) { let i = ''; return void 0 !== t[n.results] && (e.each(t[n.results], function(e, t) { t[n.url] ? i += `<a class="result" href="${t[n.url]}">` : i += '<a class="result">', void 0 !== t[n.image] && (i += `<div class="image"> <img src="${t[n.image]}"></div>`), i += '<div class="content">', void 0 !== t[n.price] && (i += `<div class="price">${t[n.price]}</div>`), void 0 !== t[n.title] && (i += `<div class="title">${t[n.title]}</div>`), void 0 !== t[n.description] && (i += `<div class="description">${t[n.description]}</div>`), i += '</div>', i += '</a>'; }), t[n.action] && (i += `<a href="${t[n.action][n.actionURL]}" class="action">${t[n.action][n.actionText]}</a>`), i); },
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.shape = function(i) {
        let o; const a = e(this); let r = (e('body'), (new Date()).getTime()); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); const d = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; return a.each(function() {
            let t; let f; let m; const g = a.selector || ''; const v = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.shape.settings, i) : e.extend({}, e.fn.shape.settings); const p = v.namespace; const h = v.selector; const b = v.error; const y = v.className; const x = `.${p}`; const C = `module-${p}`; let w = e(this); let k = w.find(h.sides); let S = w.find(h.side); let T = !1; const A = this; let R = w.data(C); m = {
                initialize() { m.verbose('Initializing module for', A), m.set.defaultSide(), m.instantiate(); },
                instantiate() { m.verbose('Storing instance of module', m), R = m, w.data(C, R); },
                destroy() { m.verbose('Destroying previous module for', A), w.removeData(C).off(x); },
                refresh() { m.verbose('Refreshing selector cache for', A), w = e(A), k = e(this).find(h.shape), S = e(this).find(h.side); },
                repaint() { m.verbose('Forcing repaint event'); const e = k[0] || n.createElement('div'); e.offsetWidth; },
                animate(e, n) { m.verbose('Animating box with properties', e), n = n || function(e) { m.verbose('Executing animation callback'), void 0 !== e && e.stopPropagation(), m.reset(), m.set.active(); }, v.beforeChange.call(f[0]), m.get.transitionEvent() ? (m.verbose('Starting CSS animation'), w.addClass(y.animating), k.css(e).one(m.get.transitionEvent(), n), m.set.duration(v.duration), d(function() { w.addClass(y.animating), t.addClass(y.hidden); })) : n(); },
                queue(e) { m.debug('Queueing animation of', e), k.one(m.get.transitionEvent(), function() { m.debug('Executing queued animation'), setTimeout(function() { w.shape(e); }, 0); }); },
                reset() { m.verbose('Animating states reset'), w.removeClass(y.animating).attr('style', '').removeAttr('style'), k.attr('style', '').removeAttr('style'), S.attr('style', '').removeAttr('style').removeClass(y.hidden), f.removeClass(y.animating).attr('style', '').removeAttr('style'); },
                is: { complete() { return S.filter(`.${y.active}`)[0] == f[0]; }, animating() { return w.hasClass(y.animating); } },
                set: {
                    defaultSide() { t = w.find(`.${v.className.active}`), f = t.next(h.side).length > 0 ? t.next(h.side) : w.find(h.side).first(), T = !1, m.verbose('Active side set to', t), m.verbose('Next side set to', f); },
                    duration(e) {
                        e = e || v.duration, e = typeof e === 'number' ? `${e}ms` : e, m.verbose('Setting animation duration', e), (v.duration || v.duration === 0) && k.add(S).css({
                            '-webkit-transition-duration': e, '-moz-transition-duration': e, '-ms-transition-duration': e, '-o-transition-duration': e, 'transition-duration': e,
                        });
                    },
                    currentStageSize() { const e = w.find(`.${v.className.active}`); const t = e.outerWidth(!0); const n = e.outerHeight(!0); w.css({ width: t, height: n }); },
                    stageSize() { const e = w.clone().addClass(y.loading); const t = e.find(`.${v.className.active}`); const n = T ? e.find(h.side).eq(T) : t.next(h.side).length > 0 ? t.next(h.side) : e.find(h.side).first(); const i = v.width == 'next' ? n.outerWidth(!0) : v.width == 'initial' ? w.width() : v.width; const o = v.height == 'next' ? n.outerHeight(!0) : v.height == 'initial' ? w.height() : v.height; t.removeClass(y.active), n.addClass(y.active), e.insertAfter(w), e.remove(), v.width != 'auto' && (w.css('width', i + v.jitter), m.verbose('Specifying width during animation', i)), v.height != 'auto' && (w.css('height', o + v.jitter), m.verbose('Specifying height during animation', o)); },
                    nextSide(e) { T = e, f = S.filter(e), T = S.index(f), f.length === 0 && (m.set.defaultSide(), m.error(b.side)), m.verbose('Next side manually set to', f); },
                    active() { m.verbose('Setting new side to active', f), S.removeClass(y.active), f.addClass(y.active), v.onChange.call(f[0]), m.set.defaultSide(); },
                },
                flip: {
                    up() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug('Side already visible', f); if (m.is.animating())m.queue('flip up'); else { m.debug('Flipping up', f); const e = m.get.transform.up(); m.set.stageSize(), m.stage.above(), m.animate(e); } }, down() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug('Side already visible', f); if (m.is.animating())m.queue('flip down'); else { m.debug('Flipping down', f); const e = m.get.transform.down(); m.set.stageSize(), m.stage.below(), m.animate(e); } }, left() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug('Side already visible', f); if (m.is.animating())m.queue('flip left'); else { m.debug('Flipping left', f); const e = m.get.transform.left(); m.set.stageSize(), m.stage.left(), m.animate(e); } }, right() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug('Side already visible', f); if (m.is.animating())m.queue('flip right'); else { m.debug('Flipping right', f); const e = m.get.transform.right(); m.set.stageSize(), m.stage.right(), m.animate(e); } }, over() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug('Side already visible', f); m.is.animating() ? m.queue('flip over') : (m.debug('Flipping over', f), m.set.stageSize(), m.stage.behind(), m.animate(m.get.transform.over())); }, back() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug('Side already visible', f); m.is.animating() ? m.queue('flip back') : (m.debug('Flipping back', f), m.set.stageSize(), m.stage.behind(), m.animate(m.get.transform.back())); },
                },
                get: {
                    transform: {
                        up() { const e = { y: -(t.outerHeight(!0) - f.outerHeight(!0)) / 2, z: -t.outerHeight(!0) / 2 }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(-90deg)` }; }, down() { const e = { y: -(t.outerHeight(!0) - f.outerHeight(!0)) / 2, z: -t.outerHeight(!0) / 2 }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(90deg)` }; }, left() { const e = { x: -(t.outerWidth(!0) - f.outerWidth(!0)) / 2, z: -t.outerWidth(!0) / 2 }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(90deg)` }; }, right() { const e = { x: -(t.outerWidth(!0) - f.outerWidth(!0)) / 2, z: -t.outerWidth(!0) / 2 }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(-90deg)` }; }, over() { return { transform: `translateX(${{ x: -(t.outerWidth(!0) - f.outerWidth(!0)) / 2 }.x}px) rotateY(180deg)` }; }, back() { return { transform: `translateX(${{ x: -(t.outerWidth(!0) - f.outerWidth(!0)) / 2 }.x}px) rotateY(-180deg)` }; },
                    },
                    transitionEvent() {
                        let e; const t = n.createElement('element'); const i = {
                            transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
                        }; for (e in i) if (void 0 !== t.style[e]) return i[e];
                    },
                    nextSide() { return t.next(h.side).length > 0 ? t.next(h.side) : w.find(h.side).first(); },
                },
                stage: {
                    above() { const e = { origin: (t.outerHeight(!0) - f.outerHeight(!0)) / 2, depth: { active: f.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; m.verbose('Setting the initial animation position as above', f, e), k.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), f.addClass(y.animating).css({ top: `${e.origin}px`, transform: `rotateX(90deg) translateZ(${e.depth.next}px)` }); }, below() { const e = { origin: (t.outerHeight(!0) - f.outerHeight(!0)) / 2, depth: { active: f.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; m.verbose('Setting the initial animation position as below', f, e), k.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), f.addClass(y.animating).css({ top: `${e.origin}px`, transform: `rotateX(-90deg) translateZ(${e.depth.next}px)` }); }, left() { const e = { active: t.outerWidth(!0), next: f.outerWidth(!0) }; const n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; m.verbose('Setting the initial animation position as left', f, n), k.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: `rotateY(-90deg) translateZ(${n.depth.next}px)` }); }, right() { const e = { active: t.outerWidth(!0), next: f.outerWidth(!0) }; const n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; m.verbose('Setting the initial animation position as left', f, n), k.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: `rotateY(90deg) translateZ(${n.depth.next}px)` }); }, behind() { const e = { active: t.outerWidth(!0), next: f.outerWidth(!0) }; const n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; m.verbose('Setting the initial animation position as behind', f, n), t.css({ transform: 'rotateY(0deg)' }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: 'rotateY(-180deg)' }); },
                },
                setting(t, n) { if (m.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, v, t); else { if (void 0 === n) return v[t]; e.isPlainObject(v[t]) ? e.extend(!0, v[t], n) : v[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; m[t] = n; } },
                debug() { !v.silent && v.debug && (v.performance ? m.performance.log(arguments) : (m.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), m.debug.apply(console, arguments))); },
                verbose() { !v.silent && v.verbose && v.debug && (v.performance ? m.performance.log(arguments) : (m.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), m.verbose.apply(console, arguments))); },
                error() {
                    v.silent || (m.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), m.error.apply(console, arguments));
                },
                performance: {
                    log(e) {
                        let t; let n; let i; v.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: A, 'Execution Time': n,
                        })), clearTimeout(m.performance.timer), m.performance.timer = setTimeout(m.performance.display, 500);
                    },
                    display() { let t = `${v.name}:`; let n = 0; r = !1, clearTimeout(m.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, g && (t += ` '${g}'`), a.length > 1 && (t += ` (${a.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = R; return n = n || u, i = A || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, c ? (void 0 === R && m.initialize(), m.invoke(l)) : (void 0 !== R && R.invoke('destroy'), m.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.shape.settings = {
        name: 'Shape',
        silent: !1,
        debug: !1,
        verbose: !1,
        jitter: 0,
        performance: !0,
        namespace: 'shape',
        width: 'initial',
        height: 'initial',
        beforeChange() {},
        onChange() {},
        allowRepeats: !1,
        duration: !1,
        error: { side: 'You tried to switch to a side that does not exist.', method: 'The method you called is not defined' },
        className: {
            animating: 'animating', hidden: 'hidden', loading: 'loading', active: 'active',
        },
        selector: { sides: '.sides', side: '.side' },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.sidebar = function(i) {
        let o; const a = e(this); const r = e(t); const s = e(n); const l = e('html'); const c = e('head'); const u = a.selector || ''; let d = (new Date()).getTime(); let f = []; const m = arguments[0]; const g = typeof m === 'string'; const v = [].slice.call(arguments, 1); const p = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; return a.each(function() {
            let a; let h; let b; let y; let x; let C; const w = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.sidebar.settings, i) : e.extend({}, e.fn.sidebar.settings); const k = w.selector; const S = w.className; const T = w.namespace; const A = w.regExp; const R = w.error; const P = `.${T}`; const E = `module-${T}`; const F = e(this); let O = e(w.context); let D = F.children(k.sidebar); let q = O.children(k.fixed); let j = O.children(k.pusher); const z = this; let I = F.data(E); C = {
                initialize() { C.debug('Initializing sidebar', i), C.create.id(), x = C.get.transitionEvent(), w.delaySetup ? p(C.setup.layout) : C.setup.layout(), p(function() { C.setup.cache(); }), C.instantiate(); },
                instantiate() { C.verbose('Storing instance of module', C), I = C, F.data(E, C); },
                create: { id() { b = (`${Math.random().toString(16)}000000000`).substr(2, 8), h = `.${b}`, C.verbose('Creating unique id for element', b); } },
                destroy() { C.verbose('Destroying previous module for', F), F.off(P).removeData(E), C.is.ios() && C.remove.ios(), O.off(h), r.off(h), s.off(h); },
                event: {
                    clickaway(e) { const t = j.find(e.target).length > 0 || j.is(e.target); const n = O.is(e.target); t && (C.verbose('User clicked on dimmed page'), C.hide()), n && (C.verbose('User clicked on dimmable context (scaled out page)'), C.hide()); }, touch(e) {}, containScroll(e) { z.scrollTop <= 0 && (z.scrollTop = 1), z.scrollTop + z.offsetHeight >= z.scrollHeight && (z.scrollTop = z.scrollHeight - z.offsetHeight - 1); }, scroll(t) { e(t.target).closest(k.sidebar).length === 0 && t.preventDefault(); },
                },
                bind: { clickaway() { C.verbose('Adding clickaway events to context', O), w.closable && O.on(`click${h}`, C.event.clickaway).on(`touchend${h}`, C.event.clickaway); }, scrollLock() { w.scrollLock && (C.debug('Disabling page scroll'), r.on(`DOMMouseScroll${h}`, C.event.scroll)), C.verbose('Adding events to contain sidebar scroll'), s.on(`touchmove${h}`, C.event.touch), F.on(`scroll${P}`, C.event.containScroll); } },
                unbind: { clickaway() { C.verbose('Removing clickaway events from context', O), O.off(h); }, scrollLock() { C.verbose('Removing scroll lock from page'), s.off(h), r.off(h), F.off(`scroll${P}`); } },
                add: {
                    inlineCSS() {
                        let t; const n = C.cache.width || F.outerWidth(); const i = C.cache.height || F.outerHeight(); const o = C.is.rtl(); const r = C.get.direction(); const s = {
                            left: n, right: -n, top: i, bottom: -i,
                        }; o && (C.verbose('RTL detected, flipping widths'), s.left = -n, s.right = n), t = '<style>', r === 'left' || r === 'right' ? (C.debug('Adding CSS rules for animation distance', n), t += ` .ui.visible.${r}.sidebar ~ .fixed, .ui.visible.${r}.sidebar ~ .pusher {   -webkit-transform: translate3d(${s[r]}px, 0, 0);           transform: translate3d(${s[r]}px, 0, 0); }`) : r !== 'top' && r != 'bottom' || (t += ` .ui.visible.${r}.sidebar ~ .fixed, .ui.visible.${r}.sidebar ~ .pusher {   -webkit-transform: translate3d(0, ${s[r]}px, 0);           transform: translate3d(0, ${s[r]}px, 0); }`), C.is.ie() && (r === 'left' || r === 'right' ? (C.debug('Adding CSS rules for animation distance', n), t += ` body.pushable > .ui.visible.${r}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(${s[r]}px, 0, 0);           transform: translate3d(${s[r]}px, 0, 0); }`) : r !== 'top' && r != 'bottom' || (t += ` body.pushable > .ui.visible.${r}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0, ${s[r]}px, 0);           transform: translate3d(0, ${s[r]}px, 0); }`), t += ' body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after, body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0px, 0, 0);           transform: translate3d(0px, 0, 0); }'), t += '</style>', a = e(t).appendTo(c), C.debug('Adding sizing css to head', a);
                    },
                },
                refresh() { C.verbose('Refreshing selector cache'), O = e(w.context), D = O.children(k.sidebar), j = O.children(k.pusher), q = O.children(k.fixed), C.clear.cache(); },
                refreshSidebars() { C.verbose('Refreshing other sidebars'), D = O.children(k.sidebar); },
                repaint() { C.verbose('Forcing repaint event'), z.style.display = 'none'; z.offsetHeight; z.scrollTop = z.scrollTop, z.style.display = ''; },
                setup: { cache() { C.cache = { width: F.outerWidth(), height: F.outerHeight(), rtl: F.css('direction') == 'rtl' }; }, layout() { O.children(k.pusher).length === 0 && (C.debug('Adding wrapper element for sidebar'), C.error(R.pusher), j = e('<div class="pusher" />'), O.children().not(k.omitted).not(D).wrapAll(j), C.refresh()), F.nextAll(k.pusher).length !== 0 && F.nextAll(k.pusher)[0] === j[0] || (C.debug('Moved sidebar to correct parent element'), C.error(R.movedSidebar, z), F.detach().prependTo(O), C.refresh()), C.clear.cache(), C.set.pushable(), C.set.direction(); } },
                attachEvents(t, n) { const i = e(t); n = e.isFunction(C[n]) ? C[n] : C.toggle, i.length > 0 ? (C.debug('Attaching sidebar events to element', t, n), i.on(`click${P}`, n)) : C.error(R.notFound, t); },
                show(t) { if (t = e.isFunction(t) ? t : function() {}, C.is.hidden()) { if (C.refreshSidebars(), w.overlay && (C.error(R.overlay), w.transition = 'overlay'), C.refresh(), C.othersActive()) if (C.debug('Other sidebars currently visible'), w.exclusive) { if (w.transition != 'overlay') return void C.hideOthers(C.show); C.hideOthers(); } else w.transition = 'overlay'; C.pushPage(function() { t.call(z), w.onShow.call(z); }), w.onChange.call(z), w.onVisible.call(z); } else C.debug('Sidebar is already visible'); },
                hide(t) { t = e.isFunction(t) ? t : function() {}, (C.is.visible() || C.is.animating()) && (C.debug('Hiding sidebar', t), C.refreshSidebars(), C.pullPage(function() { t.call(z), w.onHidden.call(z); }), w.onChange.call(z), w.onHide.call(z)); },
                othersAnimating() { return D.not(F).filter(`.${S.animating}`).length > 0; },
                othersVisible() { return D.not(F).filter(`.${S.visible}`).length > 0; },
                othersActive() { return C.othersVisible() || C.othersAnimating(); },
                hideOthers(e) { const t = D.not(F).filter(`.${S.visible}`); const n = t.length; let i = 0; e = e || function() {}, t.sidebar('hide', function() { ++i == n && e(); }); },
                toggle() { C.verbose('Determining toggled direction'), C.is.hidden() ? C.show() : C.hide(); },
                pushPage(t) { let n; let i; let o; const a = C.get.transition(); const r = a === 'overlay' || C.othersActive() ? F : j; t = e.isFunction(t) ? t : function() {}, w.transition == 'scale down' && C.scrollToTop(), C.set.transition(a), C.repaint(), n = function() { C.bind.clickaway(), C.add.inlineCSS(), C.set.animating(), C.set.visible(); }, i = function() { C.set.dimmed(); }, o = function(e) { e.target == r[0] && (r.off(x + h, o), C.remove.animating(), C.bind.scrollLock(), t.call(z)); }, r.off(x + h), r.on(x + h, o), p(n), w.dimPage && !C.othersVisible() && p(i); },
                pullPage(t) { let n; let i; const o = C.get.transition(); const a = o == 'overlay' || C.othersActive() ? F : j; t = e.isFunction(t) ? t : function() {}, C.verbose('Removing context push state', C.get.direction()), C.unbind.clickaway(), C.unbind.scrollLock(), n = function() { C.set.transition(o), C.set.animating(), C.remove.visible(), w.dimPage && !C.othersVisible() && j.removeClass(S.dimmed); }, i = function(e) { e.target == a[0] && (a.off(x + h, i), C.remove.animating(), C.remove.transition(), C.remove.inlineCSS(), (o == 'scale down' || w.returnScroll && C.is.mobile()) && C.scrollBack(), t.call(z)); }, a.off(x + h), a.on(x + h, i), p(n); },
                scrollToTop() { C.verbose('Scrolling to top of page to avoid animation issues'), y = e(t).scrollTop(), F.scrollTop(0), t.scrollTo(0, 0); },
                scrollBack() { C.verbose('Scrolling back to original page position'), t.scrollTo(0, y); },
                clear: { cache() { C.verbose('Clearing cached dimensions'), C.cache = {}; } },
                set: {
                    ios() { l.addClass(S.ios); }, pushed() { O.addClass(S.pushed); }, pushable() { O.addClass(S.pushable); }, dimmed() { j.addClass(S.dimmed); }, active() { F.addClass(S.active); }, animating() { F.addClass(S.animating); }, transition(e) { e = e || C.get.transition(), F.addClass(e); }, direction(e) { e = e || C.get.direction(), F.addClass(S[e]); }, visible() { F.addClass(S.visible); }, overlay() { F.addClass(S.overlay); },
                },
                remove: {
                    inlineCSS() { C.debug('Removing inline css styles', a), a && a.length > 0 && a.remove(); }, ios() { l.removeClass(S.ios); }, pushed() { O.removeClass(S.pushed); }, pushable() { O.removeClass(S.pushable); }, active() { F.removeClass(S.active); }, animating() { F.removeClass(S.animating); }, transition(e) { e = e || C.get.transition(), F.removeClass(e); }, direction(e) { e = e || C.get.direction(), F.removeClass(S[e]); }, visible() { F.removeClass(S.visible); }, overlay() { F.removeClass(S.overlay); },
                },
                get: {
                    direction() { return F.hasClass(S.top) ? S.top : F.hasClass(S.right) ? S.right : F.hasClass(S.bottom) ? S.bottom : S.left; },
                    transition() { let e; const t = C.get.direction(); return e = C.is.mobile() ? w.mobileTransition == 'auto' ? w.defaultTransition.mobile[t] : w.mobileTransition : w.transition == 'auto' ? w.defaultTransition.computer[t] : w.transition, C.verbose('Determined transition', e), e; },
                    transitionEvent() {
                        let e; const t = n.createElement('element'); const i = {
                            transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
                        }; for (e in i) if (void 0 !== t.style[e]) return i[e];
                    },
                },
                is: {
                    ie() { const e = !t.ActiveXObject && 'ActiveXObject' in t; const n = 'ActiveXObject' in t; return e || n; }, ios() { const e = navigator.userAgent; const t = e.match(A.ios); const n = e.match(A.mobileChrome); return !(!t || n) && (C.verbose('Browser was found to be iOS', e), !0); }, mobile() { const e = navigator.userAgent; return e.match(A.mobile) ? (C.verbose('Browser was found to be mobile', e), !0) : (C.verbose('Browser is not mobile, using regular transition', e), !1); }, hidden() { return !C.is.visible(); }, visible() { return F.hasClass(S.visible); }, open() { return C.is.visible(); }, closed() { return C.is.hidden(); }, vertical() { return F.hasClass(S.top); }, animating() { return O.hasClass(S.animating); }, rtl() { return void 0 === C.cache.rtl && (C.cache.rtl = F.css('direction') == 'rtl'), C.cache.rtl; },
                },
                setting(t, n) { if (C.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, w, t); else { if (void 0 === n) return w[t]; e.isPlainObject(w[t]) ? e.extend(!0, w[t], n) : w[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, C, t); else { if (void 0 === n) return C[t]; C[t] = n; } },
                debug() { !w.silent && w.debug && (w.performance ? C.performance.log(arguments) : (C.debug = Function.prototype.bind.call(console.info, console, `${w.name}:`), C.debug.apply(console, arguments))); },
                verbose() { !w.silent && w.verbose && w.debug && (w.performance ? C.performance.log(arguments) : (C.verbose = Function.prototype.bind.call(console.info, console, `${w.name}:`), C.verbose.apply(console, arguments))); },
                error() { w.silent || (C.error = Function.prototype.bind.call(console.error, console, `${w.name}:`), C.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; w.performance && (t = (new Date()).getTime(), i = d || t, n = t - i, d = t, f.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: z, 'Execution Time': n,
                        })), clearTimeout(C.performance.timer), C.performance.timer = setTimeout(C.performance.display, 500);
                    },
                    display() { let t = `${w.name}:`; let n = 0; d = !1, clearTimeout(C.performance.timer), e.each(f, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, u && (t += ` '${u}'`), (void 0 !== console.group || void 0 !== console.table) && f.length > 0 && (console.groupCollapsed(t), console.table ? console.table(f) : e.each(f, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), f = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = I; return n = n || v, i = z || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (C.error(R.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, g ? (void 0 === I && C.initialize(), C.invoke(m)) : (void 0 !== I && C.invoke('destroy'), C.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.sidebar.settings = {
        name: 'Sidebar',
        namespace: 'sidebar',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        transition: 'auto',
        mobileTransition: 'auto',
        defaultTransition: {
            computer: {
                left: 'uncover', right: 'uncover', top: 'overlay', bottom: 'overlay',
            },
            mobile: {
                left: 'uncover', right: 'uncover', top: 'overlay', bottom: 'overlay',
            },
        },
        context: 'body',
        exclusive: !1,
        closable: !0,
        dimPage: !0,
        scrollLock: !1,
        returnScroll: !1,
        delaySetup: !1,
        duration: 500,
        onChange() {},
        onShow() {},
        onHide() {},
        onHidden() {},
        onVisible() {},
        className: {
            active: 'active', animating: 'animating', dimmed: 'dimmed', ios: 'ios', pushable: 'pushable', pushed: 'pushed', right: 'right', top: 'top', left: 'left', bottom: 'bottom', visible: 'visible',
        },
        selector: {
            fixed: '.fixed', omitted: 'script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed', pusher: '.pusher', sidebar: '.ui.sidebar',
        },
        regExp: { ios: /(iPad|iPhone|iPod)/g, mobileChrome: /(CriOS)/g, mobile: /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g },
        error: {
            method: 'The method you called is not defined.', pusher: 'Had to add pusher element. For optimal performance make sure body content is inside a pusher element', movedSidebar: 'Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag', overlay: 'The overlay setting is no longer supported, use animation: overlay', notFound: 'There were no elements that matched the specified selector',
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.sticky = function(i) {
        let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let l = []; const c = arguments[0]; const u = typeof c === 'string'; const d = [].slice.call(arguments, 1); return a.each(function() {
            let a; let f; let m; let g; let v; const p = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.sticky.settings, i) : e.extend({}, e.fn.sticky.settings); const h = p.className; const b = p.namespace; const y = p.error; const x = `.${b}`; const C = `module-${b}`; const w = e(this); const k = e(t); const S = e(p.scrollContext); let T = (w.selector, w.data(C)); const A = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; const R = this; v = {
                initialize() { v.determineContainer(), v.determineContext(), v.verbose('Initializing sticky', p, a), v.save.positions(), v.checkErrors(), v.bind.events(), p.observeChanges && v.observeChanges(), v.instantiate(); },
                instantiate() { v.verbose('Storing instance of module', v), T = v, w.data(C, v); },
                destroy() { v.verbose('Destroying previous instance'), v.reset(), m && m.disconnect(), g && g.disconnect(), k.off(`load${x}`, v.event.load).off(`resize${x}`, v.event.resize), S.off(`scrollchange${x}`, v.event.scrollchange), w.removeData(C); },
                observeChanges() { 'MutationObserver' in t && (m = new MutationObserver(v.event.documentChanged), g = new MutationObserver(v.event.changed), m.observe(n, { childList: !0, subtree: !0 }), g.observe(R, { childList: !0, subtree: !0 }), g.observe(f[0], { childList: !0, subtree: !0 }), v.debug('Setting up mutation observer', g)); },
                determineContainer() { a = p.container ? e(p.container) : w.offsetParent(); },
                determineContext() { if (f = p.context ? e(p.context) : a, f.length === 0) return void v.error(y.invalidContext, p.context, w); },
                checkErrors() { if (v.is.hidden() && v.error(y.visible, w), v.cache.element.height > v.cache.context.height) return v.reset(), void v.error(y.elementSize, w); },
                bind: { events() { k.on(`load${x}`, v.event.load).on(`resize${x}`, v.event.resize), S.off(`scroll${x}`).on(`scroll${x}`, v.event.scroll).on(`scrollchange${x}`, v.event.scrollchange); } },
                event: {
                    changed(e) { clearTimeout(v.timer), v.timer = setTimeout(function() { v.verbose('DOM tree modified, updating sticky menu', e), v.refresh(); }, 100); }, documentChanged(t) { [].forEach.call(t, function(t) { t.removedNodes && [].forEach.call(t.removedNodes, function(t) { (t == R || e(t).find(R).length > 0) && (v.debug('Element removed from DOM, tearing down events'), v.destroy()); }); }); }, load() { v.verbose('Page contents finished loading'), A(v.refresh); }, resize() { v.verbose('Window resized'), A(v.refresh); }, scroll() { A(function() { S.triggerHandler(`scrollchange${x}`, S.scrollTop()); }); }, scrollchange(e, t) { v.stick(t), p.onScroll.call(R); },
                },
                refresh(e) { v.reset(), p.context || v.determineContext(), e && v.determineContainer(), v.save.positions(), v.stick(), p.onReposition.call(R); },
                supports: { sticky() { const t = e('<div/>'); t[0]; return t.addClass(h.supported), t.css('position').match('sticky'); } },
                save: {
                    lastScroll(e) { v.lastScroll = e; },
                    elementScroll(e) { v.elementScroll = e; },
                    positions() {
                        const e = { height: S.height() }; const t = {
                            margin: { top: parseInt(w.css('margin-top'), 10), bottom: parseInt(w.css('margin-bottom'), 10) }, offset: w.offset(), width: w.outerWidth(), height: w.outerHeight(),
                        }; const n = { offset: f.offset(), height: f.outerHeight() }; a.outerHeight(); v.is.standardScroll() || (v.debug('Non-standard scroll. Removing scroll offset from element offset'), e.top = S.scrollTop(), e.left = S.scrollLeft(), t.offset.top += e.top, n.offset.top += e.top, t.offset.left += e.left, n.offset.left += e.left), v.cache = {
                            fits: t.height + p.offset <= e.height,
                            sameHeight: t.height == n.height,
                            scrollContext: { height: e.height },
                            element: {
                                margin: t.margin, top: t.offset.top - t.margin.top, left: t.offset.left, width: t.width, height: t.height, bottom: t.offset.top + t.height,
                            },
                            context: { top: n.offset.top, height: n.height, bottom: n.offset.top + n.height },
                        }, v.set.containerSize(), v.stick(), v.debug('Caching element positions', v.cache);
                    },
                },
                get: {
                    direction(e) { let t = 'down'; return e = e || S.scrollTop(), void 0 !== v.lastScroll && (v.lastScroll < e ? t = 'down' : v.lastScroll > e && (t = 'up')), t; }, scrollChange(e) { return e = e || S.scrollTop(), v.lastScroll ? e - v.lastScroll : 0; }, currentElementScroll() { return v.elementScroll ? v.elementScroll : v.is.top() ? Math.abs(parseInt(w.css('top'), 10)) || 0 : Math.abs(parseInt(w.css('bottom'), 10)) || 0; }, elementScroll(e) { e = e || S.scrollTop(); const t = v.cache.element; const n = v.cache.scrollContext; const i = v.get.scrollChange(e); const o = t.height - n.height + p.offset; let a = v.get.currentElementScroll(); const r = a + i; return a = v.cache.fits || r < 0 ? 0 : r > o ? o : r; },
                },
                remove: {
                    lastScroll() { delete v.lastScroll; }, elementScroll(e) { delete v.elementScroll; }, minimumSize() { a.css('min-height', ''); }, offset() { w.css('margin-top', ''); },
                },
                set: {
                    offset() { v.verbose('Setting offset on element', p.offset), w.css('margin-top', p.offset); }, containerSize() { const e = a.get(0).tagName; e === 'HTML' || e == 'body' ? v.determineContainer() : Math.abs(a.outerHeight() - v.cache.context.height) > p.jitter && (v.debug('Context has padding, specifying exact height for container', v.cache.context.height), a.css({ height: v.cache.context.height })); }, minimumSize() { const e = v.cache.element; a.css('min-height', e.height); }, scroll(e) { v.debug('Setting scroll on element', e), v.elementScroll != e && (v.is.top() && w.css('bottom', '').css('top', -e), v.is.bottom() && w.css('top', '').css('bottom', e)); }, size() { v.cache.element.height !== 0 && v.cache.element.width !== 0 && (R.style.setProperty('width', `${v.cache.element.width}px`, 'important'), R.style.setProperty('height', `${v.cache.element.height}px`, 'important')); },
                },
                is: {
                    standardScroll() { return S[0] == t; }, top() { return w.hasClass(h.top); }, bottom() { return w.hasClass(h.bottom); }, initialPosition() { return !v.is.fixed() && !v.is.bound(); }, hidden() { return !w.is(':visible'); }, bound() { return w.hasClass(h.bound); }, fixed() { return w.hasClass(h.fixed); },
                },
                stick(e) { const t = e || S.scrollTop(); const n = v.cache; const i = n.fits; const o = n.sameHeight; const a = n.element; const r = n.scrollContext; const s = n.context; const l = v.is.bottom() && p.pushing ? p.bottomOffset : p.offset; var e = { top: t + l, bottom: t + l + r.height }; const c = (v.get.direction(e.top), i ? 0 : v.get.elementScroll(e.top)); const u = !i; a.height !== 0 && !o && (v.is.initialPosition() ? e.top >= s.bottom ? (v.debug('Initial element position is bottom of container'), v.bindBottom()) : e.top > a.top && (a.height + e.top - c >= s.bottom ? (v.debug('Initial element position is bottom of container'), v.bindBottom()) : (v.debug('Initial element position is fixed'), v.fixTop())) : v.is.fixed() ? v.is.top() ? e.top <= a.top ? (v.debug('Fixed element reached top of container'), v.setInitialPosition()) : a.height + e.top - c >= s.bottom ? (v.debug('Fixed element reached bottom of container'), v.bindBottom()) : u && (v.set.scroll(c), v.save.lastScroll(e.top), v.save.elementScroll(c)) : v.is.bottom() && (e.bottom - a.height <= a.top ? (v.debug('Bottom fixed rail has reached top of container'), v.setInitialPosition()) : e.bottom >= s.bottom ? (v.debug('Bottom fixed rail has reached bottom of container'), v.bindBottom()) : u && (v.set.scroll(c), v.save.lastScroll(e.top), v.save.elementScroll(c))) : v.is.bottom() && (e.top <= a.top ? (v.debug('Jumped from bottom fixed to top fixed, most likely used home/end button'), v.setInitialPosition()) : p.pushing ? v.is.bound() && e.bottom <= s.bottom && (v.debug('Fixing bottom attached element to bottom of browser.'), v.fixBottom()) : v.is.bound() && e.top <= s.bottom - a.height && (v.debug('Fixing bottom attached element to top of browser.'), v.fixTop()))); },
                bindTop() {
                    v.debug('Binding element to top of parent container'), v.remove.offset(), w.css({ left: '', top: '', marginBottom: '' }).removeClass(h.fixed).removeClass(h.bottom).addClass(h.bound)
                        .addClass(h.top), p.onTop.call(R), p.onUnstick.call(R);
                },
                bindBottom() {
                    v.debug('Binding element to bottom of parent container'), v.remove.offset(), w.css({ left: '', top: '' }).removeClass(h.fixed).removeClass(h.top).addClass(h.bound)
                        .addClass(h.bottom), p.onBottom.call(R), p.onUnstick.call(R);
                },
                setInitialPosition() { v.debug('Returning to initial position'), v.unfix(), v.unbind(); },
                fixTop() {
                    v.debug('Fixing element to top of page'), p.setSize && v.set.size(), v.set.minimumSize(), v.set.offset(), w.css({ left: v.cache.element.left, bottom: '', marginBottom: '' }).removeClass(h.bound).removeClass(h.bottom).addClass(h.fixed)
                        .addClass(h.top), p.onStick.call(R);
                },
                fixBottom() {
                    v.debug('Sticking element to bottom of page'), p.setSize && v.set.size(), v.set.minimumSize(), v.set.offset(), w.css({ left: v.cache.element.left, bottom: '', marginBottom: '' }).removeClass(h.bound).removeClass(h.top).addClass(h.fixed)
                        .addClass(h.bottom), p.onStick.call(R);
                },
                unbind() { v.is.bound() && (v.debug('Removing container bound position on element'), v.remove.offset(), w.removeClass(h.bound).removeClass(h.top).removeClass(h.bottom)); },
                unfix() { v.is.fixed() && (v.debug('Removing fixed position on element'), v.remove.minimumSize(), v.remove.offset(), w.removeClass(h.fixed).removeClass(h.top).removeClass(h.bottom), p.onUnstick.call(R)); },
                reset() { v.debug('Resetting elements position'), v.unbind(), v.unfix(), v.resetCSS(), v.remove.offset(), v.remove.lastScroll(); },
                resetCSS() { w.css({ width: '', height: '' }), a.css({ height: '' }); },
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (void 0 === n) return p[t]; p[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, v, t); else { if (void 0 === n) return v[t]; v[t] = n; } },
                debug() { !p.silent && p.debug && (p.performance ? v.performance.log(arguments) : (v.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), v.debug.apply(console, arguments))); },
                verbose() { !p.silent && p.verbose && p.debug && (p.performance ? v.performance.log(arguments) : (v.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), v.verbose.apply(console, arguments))); },
                error() { p.silent || (v.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), v.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; p.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: R, 'Execution Time': n,
                        })), clearTimeout(v.performance.timer), v.performance.timer = setTimeout(v.performance.display, 0);
                    },
                    display() { let t = `${p.name}:`; let n = 0; s = !1, clearTimeout(v.performance.timer), e.each(l, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = T; return n = n || d, i = R || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, u ? (void 0 === T && v.initialize(), v.invoke(c)) : (void 0 !== T && T.invoke('destroy'), v.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.sticky.settings = {
        name: 'Sticky',
        namespace: 'sticky',
        silent: !1,
        debug: !1,
        verbose: !0,
        performance: !0,
        pushing: !1,
        context: !1,
        container: !1,
        scrollContext: t,
        offset: 0,
        bottomOffset: 0,
        jitter: 5,
        setSize: !0,
        observeChanges: !1,
        onReposition() {},
        onScroll() {},
        onStick() {},
        onUnstick() {},
        onTop() {},
        onBottom() {},
        error: {
            container: 'Sticky element must be inside a relative container', visible: 'Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.', method: 'The method you called is not defined.', invalidContext: 'Context specified does not exist', elementSize: 'Sticky element is larger than its container, cannot create sticky.',
        },
        className: {
            bound: 'bound', fixed: 'fixed', supported: 'native', top: 'top', bottom: 'bottom',
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.tab = function(i) {
        let o; const a = e(e.isFunction(this) ? t : this); const r = a.selector || ''; let s = (new Date()).getTime(); let l = []; const c = arguments[0]; const u = typeof c === 'string'; const d = [].slice.call(arguments, 1); let f = !1; return a.each(function() {
            let m; let g; let v; let p; let h; let b; let y = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.tab.settings, i) : e.extend({}, e.fn.tab.settings); const x = y.className; const C = y.metadata; const w = y.selector; const k = y.error; const S = `.${y.namespace}`; const T = `module-${y.namespace}`; const A = e(this); const R = {}; let P = !0; let E = 0; const F = this; let O = A.data(T); h = {
                initialize() { h.debug('Initializing tab menu item', A), h.fix.callbacks(), h.determineTabs(), h.debug('Determining tabs', y.context, g), y.auto && h.set.auto(), h.bind.events(), y.history && !f && (h.initializeHistory(), f = !0), h.instantiate(); },
                instantiate() { h.verbose('Storing instance of module', h), O = h, A.data(T, h); },
                destroy() { h.debug('Destroying tabs', A), A.removeData(T).off(S); },
                bind: { events() { e.isWindow(F) || (h.debug('Attaching tab activation events to element', A), A.on(`click${S}`, h.event.click)); } },
                determineTabs() { let t; y.context === 'parent' ? (A.closest(w.ui).length > 0 ? (t = A.closest(w.ui), h.verbose('Using closest UI element as parent', t)) : t = A, m = t.parent(), h.verbose('Determined parent element for creating context', m)) : y.context ? (m = e(y.context), h.verbose('Using selector for tab context', y.context, m)) : m = e('body'), y.childrenOnly ? (g = m.children(w.tabs), h.debug('Searching tab context children for tabs', m, g)) : (g = m.find(w.tabs), h.debug('Searching tab context for tabs', m, g)); },
                fix: { callbacks() { e.isPlainObject(i) && (i.onTabLoad || i.onTabInit) && (i.onTabLoad && (i.onLoad = i.onTabLoad, delete i.onTabLoad, h.error(k.legacyLoad, i.onLoad)), i.onTabInit && (i.onFirstLoad = i.onTabInit, delete i.onTabInit, h.error(k.legacyInit, i.onFirstLoad)), y = e.extend(!0, {}, e.fn.tab.settings, i)); } },
                initializeHistory() { if (h.debug('Initializing page state'), void 0 === e.address) return h.error(k.state), !1; if (y.historyType == 'state') { if (h.debug('Using HTML5 to manage state'), !1 === y.path) return h.error(k.path), !1; e.address.history(!0).state(y.path); }e.address.bind('change', h.event.history.change); },
                event: { click(t) { const n = e(this).data(C.tab); void 0 !== n ? (y.history ? (h.verbose('Updating page state', t), e.address.value(n)) : (h.verbose('Changing tab', t), h.changeTab(n)), t.preventDefault()) : h.debug('No tab specified'); }, history: { change(t) { const n = t.pathNames.join('/') || h.get.initialPath(); const i = y.templates.determineTitle(n) || !1; h.performance.display(), h.debug('History change event', n, t), b = t, void 0 !== n && h.changeTab(n), i && e.address.title(i); } } },
                refresh() { v && (h.debug('Refreshing tab', v), h.changeTab(v)); },
                cache: { read(e) { return void 0 !== e && R[e]; }, add(e, t) { e = e || v, h.debug('Adding cached content for', e), R[e] = t; }, remove(e) { e = e || v, h.debug('Removing cached content for', e), delete R[e]; } },
                set: { auto() { const t = typeof y.path === 'string' ? `${y.path.replace(/\/$/, '')}/{$tab}` : '/{$tab}'; h.verbose('Setting up automatic tab retrieval from server', t), e.isPlainObject(y.apiSettings) ? y.apiSettings.url = t : y.apiSettings = { url: t }; }, loading(e) { const t = h.get.tabElement(e); t.hasClass(x.loading) || (h.verbose('Setting loading state for', t), t.addClass(x.loading).siblings(g).removeClass(`${x.active} ${x.loading}`), t.length > 0 && y.onRequest.call(t[0], e)); }, state(t) { e.address.value(t); } },
                changeTab(n) {
                    const i = t.history && t.history.pushState; const o = i && y.ignoreFirstLoad && P; const a = y.auto || e.isPlainObject(y.apiSettings); const r = a && !o ? h.utilities.pathToArray(n) : h.get.defaultPathArray(n); n = h.utilities.arrayToPath(r), e.each(r, function(t, i) {
                        let s; let l; let c; let u; const d = r.slice(0, t + 1); let f = h.utilities.arrayToPath(d); const g = h.is.tab(f); const w = t + 1 == r.length; let S = h.get.tabElement(f); if (h.verbose('Looking for tab', i), g) { if (h.verbose('Tab was found', i), v = f, p = h.utilities.filterArray(r, d), w ? u = !0 : (l = r.slice(0, t + 2), c = h.utilities.arrayToPath(l), (u = !h.is.tab(c)) && h.verbose('Tab parameters found', l)), u && a) return o ? (h.debug('Ignoring remote content on first tab load', f), P = !1, h.cache.add(n, S.html()), h.activate.all(f), y.onFirstLoad.call(S[0], f, p, b), y.onLoad.call(S[0], f, p, b)) : (h.activate.navigation(f), h.fetch.content(f, n)), !1; h.debug('Opened local tab', f), h.activate.all(f), h.cache.read(f) || (h.cache.add(f, !0), h.debug('First time tab loaded calling tab init'), y.onFirstLoad.call(S[0], f, p, b)), y.onLoad.call(S[0], f, p, b); } else {
                            if (n.search('/') != -1 || n === '') return h.error(k.missingTab, A, m, f), !1; if (s = e(`#${n}, a[name="${n}"]`), f = s.closest('[data-tab]').data(C.tab), S = h.get.tabElement(f),
                            s && s.length > 0 && f) return h.debug('Anchor link used, opening parent tab', S, s), S.hasClass(x.active) || setTimeout(function() { h.scrollTo(s); }, 0), h.activate.all(f), h.cache.read(f) || (h.cache.add(f, !0), h.debug('First time tab loaded calling tab init'), y.onFirstLoad.call(S[0], f, p, b)), y.onLoad.call(S[0], f, p, b), !1;
                        }
                    });
                },
                scrollTo(t) { const i = !!(t && t.length > 0) && t.offset().top; !1 !== i && (h.debug('Forcing scroll to an in-page link in a hidden tab', i, t), e(n).scrollTop(i)); },
                update: { content(t, n, i) { const o = h.get.tabElement(t); const a = o[0]; i = void 0 !== i ? i : y.evaluateScripts, typeof y.cacheType === 'string' && y.cacheType.toLowerCase() == 'dom' && typeof n !== 'string' ? o.empty().append(e(n).clone(!0)) : i ? (h.debug('Updating HTML and evaluating inline scripts', t, n), o.html(n)) : (h.debug('Updating HTML', t, n), a.innerHTML = n); } },
                fetch: {
                    content(t, n) {
                        let i; let o; const a = h.get.tabElement(t); const r = {
                            dataType: 'html', encodeParameters: !1, on: 'now', cache: y.alwaysRefresh, headers: { 'X-Remote': !0 }, onSuccess(e) { y.cacheType == 'response' && h.cache.add(n, e), h.update.content(t, e), t == v ? (h.debug('Content loaded', t), h.activate.tab(t)) : h.debug('Content loaded in background', t), y.onFirstLoad.call(a[0], t, p, b), y.onLoad.call(a[0], t, p, b), y.loadOnce ? h.cache.add(n, !0) : typeof y.cacheType === 'string' && y.cacheType.toLowerCase() == 'dom' && a.children().length > 0 ? setTimeout(function() { let e = a.children().clone(!0); e = e.not('script'), h.cache.add(n, e); }, 0) : h.cache.add(n, a.html()); }, urlData: { tab: n },
                        }; const s = a.api('get request') || !1; const l = s && s.state() === 'pending'; n = n || t, o = h.cache.read(n), y.cache && o ? (h.activate.tab(t), h.debug('Adding cached content', n), y.loadOnce || (y.evaluateScripts == 'once' ? h.update.content(t, o, !1) : h.update.content(t, o)), y.onLoad.call(a[0], t, p, b)) : l ? (h.set.loading(t), h.debug('Content is already loading', n)) : void 0 !== e.api ? (i = e.extend(!0, {}, y.apiSettings, r), h.debug('Retrieving remote content', n, i), h.set.loading(t), a.api(i)) : h.error(k.api);
                    },
                },
                activate: { all(e) { h.activate.tab(e), h.activate.navigation(e); }, tab(e) { const t = h.get.tabElement(e); const n = y.deactivate == 'siblings' ? t.siblings(g) : g.not(t); const i = t.hasClass(x.active); h.verbose('Showing tab content for', t), i || (t.addClass(x.active), n.removeClass(`${x.active} ${x.loading}`), t.length > 0 && y.onVisible.call(t[0], e)); }, navigation(e) { const t = h.get.navElement(e); const n = y.deactivate == 'siblings' ? t.siblings(a) : a.not(t); const i = t.hasClass(x.active); h.verbose('Activating tab navigation for', t, e), i || (t.addClass(x.active), n.removeClass(`${x.active} ${x.loading}`)); } },
                deactivate: { all() { h.deactivate.navigation(), h.deactivate.tabs(); }, navigation() { a.removeClass(x.active); }, tabs() { g.removeClass(`${x.active} ${x.loading}`); } },
                is: { tab(e) { return void 0 !== e && h.get.tabElement(e).length > 0; } },
                get: {
                    initialPath() { return a.eq(0).data(C.tab) || g.eq(0).data(C.tab); }, path() { return e.address.value(); }, defaultPathArray(e) { return h.utilities.pathToArray(h.get.defaultPath(e)); }, defaultPath(e) { const t = a.filter(`[data-${C.tab}^="${e}/"]`).eq(0); const n = t.data(C.tab) || !1; if (n) { if (h.debug('Found default tab', n), E < y.maxDepth) return E++, h.get.defaultPath(n); h.error(k.recursion); } else h.debug('No default tabs found for', e, g); return E = 0, e; }, navElement(e) { return e = e || v, a.filter(`[data-${C.tab}="${e}"]`); }, tabElement(e) { let t; let n; let i; let o; return e = e || v, i = h.utilities.pathToArray(e), o = h.utilities.last(i), t = g.filter(`[data-${C.tab}="${e}"]`), n = g.filter(`[data-${C.tab}="${o}"]`), t.length > 0 ? t : n; }, tab() { return v; },
                },
                utilities: {
                    filterArray(t, n) { return e.grep(t, function(t) { return e.inArray(t, n) == -1; }); }, last(t) { return !!e.isArray(t) && t[t.length - 1]; }, pathToArray(e) { return void 0 === e && (e = v), typeof e === 'string' ? e.split('/') : [e]; }, arrayToPath(t) { return !!e.isArray(t) && t.join('/'); },
                },
                setting(t, n) { if (h.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, y, t); else { if (void 0 === n) return y[t]; e.isPlainObject(y[t]) ? e.extend(!0, y[t], n) : y[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, h, t); else { if (void 0 === n) return h[t]; h[t] = n; } },
                debug() { !y.silent && y.debug && (y.performance ? h.performance.log(arguments) : (h.debug = Function.prototype.bind.call(console.info, console, `${y.name}:`), h.debug.apply(console, arguments))); },
                verbose() { !y.silent && y.verbose && y.debug && (y.performance ? h.performance.log(arguments) : (h.verbose = Function.prototype.bind.call(console.info, console, `${y.name}:`), h.verbose.apply(console, arguments))); },
                error() { y.silent || (h.error = Function.prototype.bind.call(console.error, console, `${y.name}:`), h.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; y.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: F, 'Execution Time': n,
                        })), clearTimeout(h.performance.timer), h.performance.timer = setTimeout(h.performance.display, 500);
                    },
                    display() { let t = `${y.name}:`; let n = 0; s = !1, clearTimeout(h.performance.timer), e.each(l, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = O; return n = n || d, i = F || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (h.error(k.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, u ? (void 0 === O && h.initialize(), h.invoke(c)) : (void 0 !== O && O.invoke('destroy'), h.initialize());
        }), void 0 !== o ? o : this;
    }, e.tab = function() { e(t).tab.apply(this, arguments); }, e.fn.tab.settings = {
        name: 'Tab',
        namespace: 'tab',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        auto: !1,
        history: !1,
        historyType: 'hash',
        path: !1,
        context: !1,
        childrenOnly: !1,
        maxDepth: 25,
        deactivate: 'siblings',
        alwaysRefresh: !1,
        cache: !0,
        loadOnce: !1,
        cacheType: 'response',
        ignoreFirstLoad: !1,
        apiSettings: !1,
        evaluateScripts: 'once',
        onFirstLoad(e, t, n) {},
        onLoad(e, t, n) {},
        onVisible(e, t, n) {},
        onRequest(e, t, n) {},
        templates: { determineTitle(e) {} },
        error: {
            api: 'You attempted to load content without API module', method: 'The method you called is not defined', missingTab: 'Activated tab cannot be found. Tabs are case-sensitive.', noContent: 'The tab you specified is missing a content url.', path: 'History enabled, but no path was specified', recursion: 'Max recursive depth reached', legacyInit: 'onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.', legacyLoad: 'onTabLoad has been renamed to onLoad in 2.0. Please adjust your code', state: "History requires Asual's Address library <https://github.com/asual/jquery-address>",
        },
        metadata: { tab: 'tab', loaded: 'loaded', promise: 'promise' },
        className: { loading: 'loading', active: 'active' },
        selector: { tabs: '.ui.tab', ui: '.ui' },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.transition = function() {
        let i; const o = e(this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const l = arguments; const c = l[0]; const u = [].slice.call(arguments, 1); let d = typeof c === 'string'; t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame; return o.each(function(t) {
            let f; let m; let g; let v; let p; let h; let b; let y; let x; const C = e(this); const w = this; x = {
                initialize() { f = x.get.settings.apply(w, l), v = f.className, g = f.error, p = f.metadata, y = `.${f.namespace}`, b = `module-${f.namespace}`, m = C.data(b) || x, h = x.get.animationEndEvent(), d && (d = x.invoke(c)), !1 === d && (x.verbose('Converted arguments into settings object', f), f.interval ? x.delay(f.animate) : x.animate(), x.instantiate()); },
                instantiate() { x.verbose('Storing instance of module', x), m = x, C.data(b, m); },
                destroy() { x.verbose('Destroying previous module for', w), C.removeData(b); },
                refresh() { x.verbose('Refreshing display type on next animation'), delete x.displayType; },
                forceRepaint() { x.verbose('Forcing element repaint'); const e = C.parent(); const t = C.next(); t.length === 0 ? C.detach().appendTo(e) : C.detach().insertBefore(t); },
                repaint() { x.verbose('Repainting element'); w.offsetWidth; },
                delay(e) { let n; let i; let a = x.get.animationDirection(); a || (a = x.can.transition() ? x.get.direction() : 'static'), e = void 0 !== e ? e : f.interval, n = f.reverse == 'auto' && a == v.outward, i = n || f.reverse == 1 ? (o.length - t) * f.interval : t * f.interval, x.debug('Delaying animation by', i), setTimeout(x.animate, i); },
                animate(e) { if (f = e || f, !x.is.supported()) return x.error(g.support), !1; if (x.debug('Preparing animation', f.animation), x.is.animating()) { if (f.queue) return !f.allowRepeats && x.has.direction() && x.is.occurring() && !0 !== x.queuing ? x.debug('Animation is currently occurring, preventing queueing same animation', f.animation) : x.queue(f.animation), !1; if (!f.allowRepeats && x.is.occurring()) return x.debug('Animation is already occurring, will not execute repeated animation', f.animation), !1; x.debug('New animation started, completing previous early', f.animation), m.complete(); }x.can.animate() ? x.set.animating(f.animation) : x.error(g.noAnimation, f.animation, w); },
                reset() { x.debug('Resetting animation to beginning conditions'), x.remove.animationCallbacks(), x.restore.conditions(), x.remove.animating(); },
                queue(e) { x.debug('Queueing animation of', e), x.queuing = !0, C.one(`${h}.queue${y}`, function() { x.queuing = !1, x.repaint(), x.animate.apply(this, f); }); },
                complete(e) { x.debug('Animation complete', f.animation), x.remove.completeCallback(), x.remove.failSafe(), x.is.looping() || (x.is.outward() ? (x.verbose('Animation is outward, hiding element'), x.restore.conditions(), x.hide()) : x.is.inward() ? (x.verbose('Animation is outward, showing element'), x.restore.conditions(), x.show()) : (x.verbose('Static animation completed'), x.restore.conditions(), f.onComplete.call(w))); },
                force: { visible() { const e = C.attr('style'); const t = x.get.userStyle(); const n = x.get.displayType(); const i = `${t}display: ${n} !important;`; const o = C.css('display'); const a = void 0 === e || e === ''; o !== n ? (x.verbose('Overriding default display to show element', n), C.attr('style', i)) : a && C.removeAttr('style'); }, hidden() { const e = C.attr('style'); const t = C.css('display'); const n = void 0 === e || e === ''; t === 'none' || x.is.hidden() ? n && C.removeAttr('style') : (x.verbose('Overriding default display to hide element'), C.css('display', 'none')); } },
                has: { direction(t) { let n = !1; return t = t || f.animation, typeof t === 'string' && (t = t.split(' '), e.each(t, function(e, t) { t !== v.inward && t !== v.outward || (n = !0); })), n; }, inlineDisplay() { const t = C.attr('style') || ''; return e.isArray(t.match(/display.*?;/, '')); } },
                set: {
                    animating(e) { let t; x.remove.completeCallback(), e = e || f.animation, t = x.get.animationClass(e), x.save.animation(t), x.force.visible(), x.remove.hidden(), x.remove.direction(), x.start.animation(t); }, duration(e, t) { t = t || f.duration, ((t = typeof t === 'number' ? `${t}ms` : t) || t === 0) && (x.verbose('Setting animation duration', t), C.css({ 'animation-duration': t })); }, direction(e) { e = e || x.get.direction(), e == v.inward ? x.set.inward() : x.set.outward(); }, looping() { x.debug('Transition set to loop'), C.addClass(v.looping); }, hidden() { C.addClass(v.transition).addClass(v.hidden); }, inward() { x.debug('Setting direction to inward'), C.removeClass(v.outward).addClass(v.inward); }, outward() { x.debug('Setting direction to outward'), C.removeClass(v.inward).addClass(v.outward); }, visible() { C.addClass(v.transition).addClass(v.visible); },
                },
                start: { animation(e) { e = e || x.get.animationClass(), x.debug('Starting tween', e), C.addClass(e).one(`${h}.complete${y}`, x.complete), f.useFailSafe && x.add.failSafe(), x.set.duration(f.duration), f.onStart.call(w); } },
                save: { animation(e) { x.cache || (x.cache = {}), x.cache.animation = e; }, displayType(e) { e !== 'none' && C.data(p.displayType, e); }, transitionExists(t, n) { e.fn.transition.exists[t] = n, x.verbose('Saving existence of transition', t, n); } },
                restore: { conditions() { const e = x.get.currentAnimation(); e && (C.removeClass(e), x.verbose('Removing animation class', x.cache)), x.remove.duration(); } },
                add: { failSafe() { const e = x.get.duration(); x.timer = setTimeout(function() { C.triggerHandler(h); }, e + f.failSafeDelay), x.verbose('Adding fail safe timer', x.timer); } },
                remove: {
                    animating() { C.removeClass(v.animating); }, animationCallbacks() { x.remove.queueCallback(), x.remove.completeCallback(); }, queueCallback() { C.off(`.queue${y}`); }, completeCallback() { C.off(`.complete${y}`); }, display() { C.css('display', ''); }, direction() { C.removeClass(v.inward).removeClass(v.outward); }, duration() { C.css('animation-duration', ''); }, failSafe() { x.verbose('Removing fail safe timer', x.timer), x.timer && clearTimeout(x.timer); }, hidden() { C.removeClass(v.hidden); }, visible() { C.removeClass(v.visible); }, looping() { x.debug('Transitions are no longer looping'), x.is.looping() && (x.reset(), C.removeClass(v.looping)); }, transition() { C.removeClass(v.visible).removeClass(v.hidden); },
                },
                get: {
                    settings(t, n, i) { return typeof t === 'object' ? e.extend(!0, {}, e.fn.transition.settings, t) : typeof i === 'function' ? e.extend({}, e.fn.transition.settings, { animation: t, onComplete: i, duration: n }) : typeof n === 'string' || typeof n === 'number' ? e.extend({}, e.fn.transition.settings, { animation: t, duration: n }) : typeof n === 'object' ? e.extend({}, e.fn.transition.settings, n, { animation: t }) : typeof n === 'function' ? e.extend({}, e.fn.transition.settings, { animation: t, onComplete: n }) : e.extend({}, e.fn.transition.settings, { animation: t }); },
                    animationClass(e) { const t = e || f.animation; const n = x.can.transition() && !x.has.direction() ? `${x.get.direction()} ` : ''; return `${v.animating} ${v.transition} ${n}${t}`; },
                    currentAnimation() { return !(!x.cache || void 0 === x.cache.animation) && x.cache.animation; },
                    currentDirection() { return x.is.inward() ? v.inward : v.outward; },
                    direction() { return x.is.hidden() || !x.is.visible() ? v.inward : v.outward; },
                    animationDirection(t) { let n; return t = t || f.animation, typeof t === 'string' && (t = t.split(' '), e.each(t, function(e, t) { t === v.inward ? n = v.inward : t === v.outward && (n = v.outward); })), n || !1; },
                    duration(e) { return e = e || f.duration, !1 === e && (e = C.css('animation-duration') || 0), typeof e === 'string' ? e.indexOf('ms') > -1 ? parseFloat(e) : 1e3 * parseFloat(e) : e; },
                    displayType(e) { return e = void 0 === e || e, f.displayType ? f.displayType : (e && void 0 === C.data(p.displayType) && x.can.transition(!0), C.data(p.displayType)); },
                    userStyle(e) { return e = e || C.attr('style') || '', e.replace(/display.*?;/, ''); },
                    transitionExists(t) { return e.fn.transition.exists[t]; },
                    animationStartEvent() {
                        let e; const t = n.createElement('div'); const i = {
                            animation: 'animationstart', OAnimation: 'oAnimationStart', MozAnimation: 'mozAnimationStart', WebkitAnimation: 'webkitAnimationStart',
                        }; for (e in i) if (void 0 !== t.style[e]) return i[e]; return !1;
                    },
                    animationEndEvent() {
                        let e; const t = n.createElement('div'); const i = {
                            animation: 'animationend', OAnimation: 'oAnimationEnd', MozAnimation: 'mozAnimationEnd', WebkitAnimation: 'webkitAnimationEnd',
                        }; for (e in i) if (void 0 !== t.style[e]) return i[e]; return !1;
                    },
                },
                can: {
                    transition(t) {
                        let n; let i; let o; let a; let r; let s; const l = f.animation; const c = x.get.transitionExists(l); let u = x.get.displayType(!1); if (void 0 === c || t) {
                            if (x.verbose('Determining whether animation exists'), n = C.attr('class'), i = C.prop('tagName'), o = e(`<${i} />`).addClass(n).insertAfter(C), a = o.addClass(l).removeClass(v.inward).removeClass(v.outward).addClass(v.animating)
                                .addClass(v.transition)
                                .css('animationName'), r = o.addClass(v.inward).css('animationName'), u || (u = o.attr('class', n).removeAttr('style').removeClass(v.hidden).removeClass(v.visible)
                                .show()
                                .css('display'), x.verbose('Determining final display state', u), x.save.displayType(u)), o.remove(), a != r)x.debug('Direction exists for animation', l), s = !0; else { if (a == 'none' || !a) return void x.debug('No animation defined in css', l); x.debug('Static animation found', l, u), s = !1; }x.save.transitionExists(l, s);
                        } return void 0 !== c ? c : s;
                    },
                    animate() { return void 0 !== x.can.transition(); },
                },
                is: {
                    animating() { return C.hasClass(v.animating); }, inward() { return C.hasClass(v.inward); }, outward() { return C.hasClass(v.outward); }, looping() { return C.hasClass(v.looping); }, occurring(e) { return e = e || f.animation, e = `.${e.replace(' ', '.')}`, C.filter(e).length > 0; }, visible() { return C.is(':visible'); }, hidden() { return C.css('visibility') === 'hidden'; }, supported() { return !1 !== h; },
                },
                hide() { x.verbose('Hiding element'), x.is.animating() && x.reset(), w.blur(), x.remove.display(), x.remove.visible(), x.set.hidden(), x.force.hidden(), f.onHide.call(w), f.onComplete.call(w); },
                show(e) { x.verbose('Showing element', e), x.remove.hidden(), x.set.visible(), x.force.visible(), f.onShow.call(w), f.onComplete.call(w); },
                toggle() { x.is.visible() ? x.hide() : x.show(); },
                stop() { x.debug('Stopping current animation'), C.triggerHandler(h); },
                stopAll() { x.debug('Stopping all animation'), x.remove.queueCallback(), C.triggerHandler(h); },
                clear: { queue() { x.debug('Clearing animation queue'), x.remove.queueCallback(); } },
                enable() { x.verbose('Starting animation'), C.removeClass(v.disabled); },
                disable() { x.debug('Stopping animation'), C.addClass(v.disabled); },
                setting(t, n) { if (x.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, x, t); else { if (void 0 === n) return x[t]; x[t] = n; } },
                debug() { !f.silent && f.debug && (f.performance ? x.performance.log(arguments) : (x.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), x.debug.apply(console, arguments))); },
                verbose() { !f.silent && f.verbose && f.debug && (f.performance ? x.performance.log(arguments) : (x.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), x.verbose.apply(console, arguments))); },
                error() { f.silent || (x.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), x.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: w, 'Execution Time': n,
                        })), clearTimeout(x.performance.timer), x.performance.timer = setTimeout(x.performance.display, 500);
                    },
                    display() { let t = `${f.name}:`; let n = 0; r = !1, clearTimeout(x.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, n, o) { let a; let r; let s; let l = m; return n = n || u, o = w || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), void 0 !== r && r; },
            }, x.initialize();
        }), void 0 !== i ? i : this;
    }, e.fn.transition.exists = {}, e.fn.transition.settings = {
        name: 'Transition',
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        namespace: 'transition',
        interval: 0,
        reverse: 'auto',
        onStart() {},
        onComplete() {},
        onShow() {},
        onHide() {},
        useFailSafe: !0,
        failSafeDelay: 100,
        allowRepeats: !1,
        displayType: !1,
        animation: 'fade',
        duration: !1,
        queue: !0,
        metadata: { displayType: 'display' },
        className: {
            animating: 'animating', disabled: 'disabled', hidden: 'hidden', inward: 'in', loading: 'loading', looping: 'looping', outward: 'out', transition: 'transition', visible: 'visible',
        },
        error: {
            noAnimation: 'Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.', repeated: 'That animation is already occurring, cancelling repeated animation', method: 'The method you called is not defined', support: 'This browser does not support CSS animations',
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    var t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); e.api = e.fn.api = function(n) {
        let i; const o = e(e.isFunction(this) ? t : this); const a = o.selector || ''; let r = (new Date()).getTime(); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); return o.each(function() {
            let o; let d; let f; let m; let g; const v = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.api.settings, n) : e.extend({}, e.fn.api.settings); const p = v.namespace; const h = v.metadata; const b = v.selector; const y = v.error; const x = v.className; const C = `.${p}`; const w = `module-${p}`; const k = e(this); const S = k.closest(b.form); const T = v.stateContext ? e(v.stateContext) : k; const A = this; const R = T[0]; let P = k.data(w); g = {
                initialize() { c || g.bind.events(), g.instantiate(); },
                instantiate() { g.verbose('Storing instance of module', g), P = g, k.data(w, P); },
                destroy() { g.verbose('Destroying previous module for', A), k.removeData(w).off(C); },
                bind: { events() { const e = g.get.event(); e ? (g.verbose('Attaching API events to element', e), k.on(e + C, g.event.trigger)) : v.on == 'now' && (g.debug('Querying API endpoint immediately'), g.query()); } },
                decode: { json(e) { if (void 0 !== e && typeof e === 'string') try { e = JSON.parse(e); } catch (e) {} return e; } },
                read: { cachedResponse(e) { let n; return void 0 === t.Storage ? void g.error(y.noStorage) : (n = sessionStorage.getItem(e), g.debug('Using cached response', e, n), n = g.decode.json(n)); } },
                write: { cachedResponse(n, i) { return i && i === '' ? void g.debug('Response empty, not caching', i) : void 0 === t.Storage ? void g.error(y.noStorage) : (e.isPlainObject(i) && (i = JSON.stringify(i)), sessionStorage.setItem(n, i), void g.verbose('Storing cached response for url', n, i)); } },
                query() {
                    if (g.is.disabled()) return void g.debug('Element is disabled API request aborted'); if (g.is.loading()) { if (!v.interruptRequests) return void g.debug('Cancelling request, previous request is still pending'); g.debug('Interrupting previous request'), g.abort(); } if (v.defaultData && e.extend(!0, v.urlData, g.get.defaultData()), v.serializeForm && (v.data = g.add.formData(v.data)), !1 === (d = g.get.settings())) return g.cancelled = !0, void g.error(y.beforeSend); if (g.cancelled = !1, !(f = g.get.templatedURL()) && !g.is.mocked()) return void g.error(y.missingURL); if ((f = g.add.urlData(f)) || g.is.mocked()) {
                        if (d.url = v.base + f, o = e.extend(!0, {}, v, {
                            type: v.method || v.type, data: void 0, url: v.base + f, beforeSend: v.beforeXHR, success() {}, failure() {}, complete() {},
                        }), g.debug('Querying URL', o.url), g.verbose('Using AJAX settings', o), v.cache === 'local' && g.read.cachedResponse(f)) return g.debug('Response returned from local cache'), g.request = g.create.request(), void g.request.resolveWith(R, [g.read.cachedResponse(f)]); v.throttle ? v.throttleFirstRequest || g.timer ? (g.debug('Throttling request', v.throttle), clearTimeout(g.timer), g.timer = setTimeout(function() { g.timer && delete g.timer, g.debug('Sending throttled request', void 0, o.method), g.send.request(); }, v.throttle)) : (g.debug('Sending request', void 0, o.method), g.send.request(), g.timer = setTimeout(function() {}, v.throttle)) : (g.debug('Sending request', void 0, o.method), g.send.request());
                    }
                },
                should: { removeError() { return !0 === v.hideError || v.hideError === 'auto' && !g.is.form(); } },
                is: {
                    disabled() { return k.filter(b.disabled).length > 0; }, expectingJSON() { return v.dataType === 'json' || v.dataType === 'jsonp'; }, form() { return k.is('form') || T.is('form'); }, mocked() { return v.mockResponse || v.mockResponseAsync || v.response || v.responseAsync; }, input() { return k.is('input'); }, loading() { return !!g.request && g.request.state() == 'pending'; }, abortedRequest(e) { return e && void 0 !== e.readyState && e.readyState === 0 ? (g.verbose('XHR request determined to be aborted'), !0) : (g.verbose('XHR request was not aborted'), !1); }, validResponse(t) { return g.is.expectingJSON() && e.isFunction(v.successTest) ? (g.debug('Checking JSON returned success', v.successTest, t), v.successTest(t) ? (g.debug('Response passed success test', t), !0) : (g.debug('Response failed success test', t), !1)) : (g.verbose('Response is not JSON, skipping validation', v.successTest, t), !0); },
                },
                was: {
                    cancelled() { return g.cancelled || !1; }, succesful() { return g.request && g.request.state() == 'resolved'; }, failure() { return g.request && g.request.state() == 'rejected'; }, complete() { return g.request && (g.request.state() == 'resolved' || g.request.state() == 'rejected'); },
                },
                add: { urlData(t, n) { let i; let o; return t && (i = t.match(v.regExp.required), o = t.match(v.regExp.optional), n = n || v.urlData, i && (g.debug('Looking for required URL variables', i), e.each(i, function(i, o) { const a = o.indexOf('$') !== -1 ? o.substr(2, o.length - 3) : o.substr(1, o.length - 2); let r = e.isPlainObject(n) && void 0 !== n[a] ? n[a] : void 0 !== k.data(a) ? k.data(a) : void 0 !== T.data(a) ? T.data(a) : n[a]; if (void 0 === r) return g.error(y.requiredParameter, a, t), t = !1, !1; g.verbose('Found required variable', a, r), r = v.encodeParameters ? g.get.urlEncodedValue(r) : r, t = t.replace(o, r); })), o && (g.debug('Looking for optional URL variables', i), e.each(o, function(i, o) { const a = o.indexOf('$') !== -1 ? o.substr(3, o.length - 4) : o.substr(2, o.length - 3); const r = e.isPlainObject(n) && void 0 !== n[a] ? n[a] : void 0 !== k.data(a) ? k.data(a) : void 0 !== T.data(a) ? T.data(a) : n[a]; void 0 !== r ? (g.verbose('Optional variable Found', a, r), t = t.replace(o, r)) : (g.verbose('Optional variable not found', a), t = t.indexOf(`/${o}`) !== -1 ? t.replace(`/${o}`, '') : t.replace(o, '')); }))), t; }, formData(t) { let n; const i = void 0 !== e.fn.serializeObject; const o = i ? S.serializeObject() : S.serialize(); return t = t || v.data, n = e.isPlainObject(t), n ? i ? (g.debug('Extending existing data with form data', t, o), t = e.extend(!0, {}, t, o)) : (g.error(y.missingSerialize), g.debug('Cant extend data. Replacing data with form data', t, o), t = o) : (g.debug('Adding form data', o), t = o), t; } },
                send: { request() { g.set.loading(), g.request = g.create.request(), g.is.mocked() ? g.mockedXHR = g.create.mockedXHR() : g.xhr = g.create.xhr(), v.onRequest.call(R, g.request, g.xhr); } },
                event: { trigger(e) { g.query(), e.type != 'submit' && e.type != 'click' || e.preventDefault(); }, xhr: { always() {}, done(t, n, i) { const o = this; const a = (new Date()).getTime() - m; let r = v.loadingDuration - a; const s = !!e.isFunction(v.onResponse) && (g.is.expectingJSON() ? v.onResponse.call(o, e.extend(!0, {}, t)) : v.onResponse.call(o, t)); r = r > 0 ? r : 0, s && (g.debug('Modified API response in onResponse callback', v.onResponse, s, t), t = s), r > 0 && g.debug('Response completed early delaying state change by', r), setTimeout(function() { g.is.validResponse(t) ? g.request.resolveWith(o, [t, i]) : g.request.rejectWith(o, [i, 'invalid']); }, r); }, fail(e, t, n) { const i = this; const o = (new Date()).getTime() - m; let a = v.loadingDuration - o; a = a > 0 ? a : 0, a > 0 && g.debug('Response completed early delaying state change by', a), setTimeout(function() { g.is.abortedRequest(e) ? g.request.rejectWith(i, [e, 'aborted', n]) : g.request.rejectWith(i, [e, 'error', t, n]); }, a); } }, request: { done(e, t) { g.debug('Successful API Response', e), v.cache === 'local' && f && (g.write.cachedResponse(f, e), g.debug('Saving server response locally', g.cache)), v.onSuccess.call(R, e, k, t); }, complete(e, t) { let n; let i; g.was.succesful() ? (i = e, n = t) : (n = e, i = g.get.responseFromXHR(n)), g.remove.loading(), v.onComplete.call(R, i, k, n); }, fail(e, t, n) { const i = g.get.responseFromXHR(e); const a = g.get.errorFromRequest(i, t, n); if (t == 'aborted') return g.debug('XHR Aborted (Most likely caused by page navigation or CORS Policy)', t, n), v.onAbort.call(R, t, k, e), !0; t == 'invalid' ? g.debug('JSON did not pass success test. A server-side error has most likely occurred', i) : t == 'error' && void 0 !== e && (g.debug('XHR produced a server error', t, n), e.status != 200 && void 0 !== n && n !== '' && g.error(y.statusMessage + n, o.url), v.onError.call(R, a, k, e)), v.errorDuration && t !== 'aborted' && (g.debug('Adding error state'), g.set.error(), g.should.removeError() && setTimeout(g.remove.error, v.errorDuration)), g.debug('API Request failed', a, e), v.onFailure.call(R, i, k, e); } } },
                create: { request() { return e.Deferred().always(g.event.request.complete).done(g.event.request.done).fail(g.event.request.fail); }, mockedXHR() { let t; let n; let i; const o = v.mockResponse || v.response; const a = v.mockResponseAsync || v.responseAsync; return i = e.Deferred().always(g.event.xhr.complete).done(g.event.xhr.done).fail(g.event.xhr.fail), o ? (e.isFunction(o) ? (g.debug('Using specified synchronous callback', o), n = o.call(R, d)) : (g.debug('Using settings specified response', o), n = o), i.resolveWith(R, [n, !1, { responseText: n }])) : e.isFunction(a) && (t = function(e) { g.debug('Async callback returned response', e), e ? i.resolveWith(R, [e, !1, { responseText: e }]) : i.rejectWith(R, [{ responseText: e }, !1, !1]); }, g.debug('Using specified async response callback', a), a.call(R, d, t)), i; }, xhr() { let t; return t = e.ajax(o).always(g.event.xhr.always).done(g.event.xhr.done).fail(g.event.xhr.fail), g.verbose('Created server request', t, o), t; } },
                set: { error() { g.verbose('Adding error state to element', T), T.addClass(x.error); }, loading() { g.verbose('Adding loading state to element', T), T.addClass(x.loading), m = (new Date()).getTime(); } },
                remove: { error() { g.verbose('Removing error state from element', T), T.removeClass(x.error); }, loading() { g.verbose('Removing loading state from element', T), T.removeClass(x.loading); } },
                get: {
                    responseFromXHR(t) { return !!e.isPlainObject(t) && (g.is.expectingJSON() ? g.decode.json(t.responseText) : t.responseText); }, errorFromRequest(t, n, i) { return e.isPlainObject(t) && void 0 !== t.error ? t.error : void 0 !== v.error[n] ? v.error[n] : i; }, request() { return g.request || !1; }, xhr() { return g.xhr || !1; }, settings() { let t; return t = v.beforeSend.call(R, v), t && (void 0 !== t.success && (g.debug('Legacy success callback detected', t), g.error(y.legacyParameters, t.success), t.onSuccess = t.success), void 0 !== t.failure && (g.debug('Legacy failure callback detected', t), g.error(y.legacyParameters, t.failure), t.onFailure = t.failure), void 0 !== t.complete && (g.debug('Legacy complete callback detected', t), g.error(y.legacyParameters, t.complete), t.onComplete = t.complete)), void 0 === t && g.error(y.noReturnedValue), !1 === t ? t : void 0 !== t ? e.extend(!0, {}, t) : e.extend(!0, {}, v); }, urlEncodedValue(e) { const n = t.decodeURIComponent(e); const i = t.encodeURIComponent(e); return n !== e ? (g.debug('URL value is already encoded, avoiding double encoding', e), e) : (g.verbose('Encoding value using encodeURIComponent', e, i), i); }, defaultData() { const t = {}; return e.isWindow(A) || (g.is.input() ? t.value = k.val() : g.is.form() || (t.text = k.text())), t; }, event() { return e.isWindow(A) || v.on == 'now' ? (g.debug('API called without element, no events attached'), !1) : v.on == 'auto' ? k.is('input') ? void 0 !== A.oninput ? 'input' : void 0 !== A.onpropertychange ? 'propertychange' : 'keyup' : k.is('form') ? 'submit' : 'click' : v.on; }, templatedURL(e) { if (e = e || k.data(h.action) || v.action || !1, f = k.data(h.url) || v.url || !1) return g.debug('Using specified url', f), f; if (e) { if (g.debug('Looking up url for action', e, v.api), void 0 === v.api[e] && !g.is.mocked()) return void g.error(y.missingAction, v.action, v.api); f = v.api[e]; } else g.is.form() && (f = k.attr('action') || T.attr('action') || !1, g.debug('No url or action specified, defaulting to form action', f)); return f; },
                },
                abort() { const e = g.get.xhr(); e && e.state() !== 'resolved' && (g.debug('Cancelling API request'), e.abort()); },
                reset() { g.remove.error(), g.remove.loading(); },
                setting(t, n) { if (g.debug('Changing setting', t, n), e.isPlainObject(t))e.extend(!0, v, t); else { if (void 0 === n) return v[t]; e.isPlainObject(v[t]) ? e.extend(!0, v[t], n) : v[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, g, t); else { if (void 0 === n) return g[t]; g[t] = n; } },
                debug() { !v.silent && v.debug && (v.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), g.debug.apply(console, arguments))); },
                verbose() { !v.silent && v.verbose && v.debug && (v.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), g.verbose.apply(console, arguments))); },
                error() {
                    v.silent || (g.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), g.error.apply(console, arguments));
                },
                performance: { log(e) { let t; let n; let i; v.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': n })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500); }, display() { let t = `${v.name}:`; let n = 0; r = !1, clearTimeout(g.performance.timer), e.each(s, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; } },
                invoke(t, n, o) { let a; let r; let s; let l = P; return n = n || u, o = A || o, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (g.error(y.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r; },
            }, c ? (void 0 === P && g.initialize(), g.invoke(l)) : (void 0 !== P && P.invoke('destroy'), g.initialize());
        }), void 0 !== i ? i : this;
    }, e.api.settings = {
        name: 'API',
        namespace: 'api',
        debug: !1,
        verbose: !1,
        performance: !0,
        api: {},
        cache: !0,
        interruptRequests: !0,
        on: 'auto',
        stateContext: !1,
        loadingDuration: 0,
        hideError: 'auto',
        errorDuration: 2e3,
        encodeParameters: !0,
        action: !1,
        url: !1,
        base: '',
        urlData: {},
        defaultData: !0,
        serializeForm: !1,
        throttle: 0,
        throttleFirstRequest: !0,
        method: 'get',
        data: {},
        dataType: 'json',
        mockResponse: !1,
        mockResponseAsync: !1,
        response: !1,
        responseAsync: !1,
        beforeSend(e) { return e; },
        beforeXHR(e) {},
        onRequest(e, t) {},
        onResponse: !1,
        onSuccess(e, t) {},
        onComplete(e, t) {},
        onFailure(e, t) {},
        onError(e, t) {},
        onAbort(e, t) {},
        successTest: !1,
        error: {
            beforeSend: 'The before send function has aborted the request', error: 'There was an error with your request', exitConditions: 'API Request Aborted. Exit conditions met', JSONParse: 'JSON could not be parsed during error handling', legacyParameters: 'You are using legacy API success callback names', method: 'The method you called is not defined', missingAction: 'API action used but no url was defined', missingSerialize: 'jquery-serialize-object is required to add form data to an existing data object', missingURL: 'No URL specified for api event', noReturnedValue: 'The beforeSend callback must return a settings object, beforeSend ignored.', noStorage: 'Caching responses locally requires session storage', parseError: 'There was an error parsing your request', requiredParameter: 'Missing a required URL parameter: ', statusMessage: 'Server gave an error: ', timeout: 'Your request timed out',
        },
        regExp: { required: /\{\$*[A-z0-9]+\}/g, optional: /\{\/\$*[A-z0-9]+\}/g },
        className: { loading: 'loading', error: 'error' },
        selector: { disabled: '.disabled', form: 'form' },
        metadata: { action: 'action', url: 'url' },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.state = function(t) {
        let i; const o = e(this); const a = o.selector || ''; let r = (n.documentElement, (new Date()).getTime()); let s = []; const l = arguments[0]; const c = typeof l === 'string'; const u = [].slice.call(arguments, 1); return o.each(function() {
            let n; const d = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.state.settings, t) : e.extend({}, e.fn.state.settings); const f = d.error; const m = d.metadata; const g = d.className; const v = d.namespace; const p = d.states; const h = d.text; const b = `.${v}`; const y = `${v}-module`; let x = e(this); const C = this; let w = x.data(y); n = {
                initialize() { n.verbose('Initializing module'), d.automatic && n.add.defaults(), d.context && a !== '' ? e(d.context).on(a, `mouseenter${b}`, n.change.text).on(a, `mouseleave${b}`, n.reset.text).on(a, `click${b}`, n.toggle.state) : x.on(`mouseenter${b}`, n.change.text).on(`mouseleave${b}`, n.reset.text).on(`click${b}`, n.toggle.state), n.instantiate(); },
                instantiate() { n.verbose('Storing instance of module', n), w = n, x.data(y, n); },
                destroy() { n.verbose('Destroying previous module', w), x.off(b).removeData(y); },
                refresh() { n.verbose('Refreshing selector cache'), x = e(C); },
                add: { defaults() { const i = t && e.isPlainObject(t.states) ? t.states : {}; e.each(d.defaults, function(t, o) { void 0 !== n.is[t] && n.is[t]() && (n.verbose('Adding default states', t, C), e.extend(d.states, o, i)); }); } },
                is: {
                    active() { return x.hasClass(g.active); }, loading() { return x.hasClass(g.loading); }, inactive() { return !x.hasClass(g.active); }, state(e) { return void 0 !== g[e] && x.hasClass(g[e]); }, enabled() { return !x.is(d.filter.active); }, disabled() { return x.is(d.filter.active); }, textEnabled() { return !x.is(d.filter.text); }, button() { return x.is('.button:not(a, .submit)'); }, input() { return x.is('input'); }, progress() { return x.is('.ui.progress'); },
                },
                allow(e) { n.debug('Now allowing state', e), p[e] = !0; },
                disallow(e) { n.debug('No longer allowing', e), p[e] = !1; },
                allows(e) { return p[e] || !1; },
                enable() { x.removeClass(g.disabled); },
                disable() { x.addClass(g.disabled); },
                setState(e) { n.allows(e) && x.addClass(g[e]); },
                removeState(e) { n.allows(e) && x.removeClass(g[e]); },
                toggle: { state() { let t; if (n.allows('active') && n.is.enabled()) { if (n.refresh(), void 0 !== e.fn.api) if (t = x.api('get request'), x.api('was cancelled'))n.debug('API Request cancelled by beforesend'), d.activateTest = function() { return !1; }, d.deactivateTest = function() { return !1; }; else if (t) return void n.listenTo(t); n.change.state(); } } },
                listenTo(t) { n.debug('API request detected, waiting for state signal', t), t && (h.loading && n.update.text(h.loading), e.when(t).then(function() { t.state() == 'resolved' ? (n.debug('API request succeeded'), d.activateTest = function() { return !0; }, d.deactivateTest = function() { return !0; }) : (n.debug('API request failed'), d.activateTest = function() { return !1; }, d.deactivateTest = function() { return !1; }), n.change.state(); })); },
                change: { state() { n.debug('Determining state change direction'), n.is.inactive() ? n.activate() : n.deactivate(), d.sync && n.sync(), d.onChange.call(C); }, text() { n.is.textEnabled() && (n.is.disabled() ? (n.verbose('Changing text to disabled text', h.hover), n.update.text(h.disabled)) : n.is.active() ? h.hover ? (n.verbose('Changing text to hover text', h.hover), n.update.text(h.hover)) : h.deactivate && (n.verbose('Changing text to deactivating text', h.deactivate), n.update.text(h.deactivate)) : h.hover ? (n.verbose('Changing text to hover text', h.hover), n.update.text(h.hover)) : h.activate && (n.verbose('Changing text to activating text', h.activate), n.update.text(h.activate))); } },
                activate() { d.activateTest.call(C) && (n.debug('Setting state to active'), x.addClass(g.active), n.update.text(h.active), d.onActivate.call(C)); },
                deactivate() { d.deactivateTest.call(C) && (n.debug('Setting state to inactive'), x.removeClass(g.active), n.update.text(h.inactive), d.onDeactivate.call(C)); },
                sync() { n.verbose('Syncing other buttons to current state'), n.is.active() ? o.not(x).state('activate') : o.not(x).state('deactivate'); },
                get: { text() { return d.selector.text ? x.find(d.selector.text).text() : x.html(); }, textFor(e) { return h[e] || !1; } },
                flash: { text(e, t, i) { const o = n.get.text(); n.debug('Flashing text message', e, t), e = e || d.text.flash, t = t || d.flashDuration, i = i || function() {}, n.update.text(e), setTimeout(function() { n.update.text(o), i.call(C); }, t); } },
                reset: { text() { const e = h.active || x.data(m.storedText); const t = h.inactive || x.data(m.storedText); n.is.textEnabled() && (n.is.active() && e ? (n.verbose('Resetting active text', e), n.update.text(e)) : t && (n.verbose('Resetting inactive text', e), n.update.text(t))); } },
                update: { text(e) { const t = n.get.text(); e && e !== t ? (n.debug('Updating text', e), d.selector.text ? x.data(m.storedText, e).find(d.selector.text).text(e) : x.data(m.storedText, e).html(e)) : n.debug('Text is already set, ignoring update', e); } },
                setting(t, i) { if (n.debug('Changing setting', t, i), e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === i) return d[t]; e.isPlainObject(d[t]) ? e.extend(!0, d[t], i) : d[t] = i; } },
                internal(t, i) { if (e.isPlainObject(t))e.extend(!0, n, t); else { if (void 0 === i) return n[t]; n[t] = i; } },
                debug() { !d.silent && d.debug && (d.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), n.debug.apply(console, arguments))); },
                verbose() { !d.silent && d.verbose && d.debug && (d.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), n.verbose.apply(console, arguments))); },
                error() { d.silent || (n.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), n.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let i; let o; d.performance && (t = (new Date()).getTime(), o = r || t, i = t - o, r = t, s.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: C, 'Execution Time': i,
                        })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
                    },
                    display() { let t = `${d.name}:`; let i = 0; r = !1, clearTimeout(n.performance.timer), e.each(s, function(e, t) { i += t['Execution Time']; }), t += ` ${i}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), s = []; },
                },
                invoke(t, o, a) { let r; let s; let l; let c = w; return o = o || u, a = C || a, typeof t === 'string' && void 0 !== c && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, function(i, o) { const a = i != r ? o + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(c[a]) && i != r)c = c[a]; else { if (void 0 !== c[a]) return s = c[a], !1; if (!e.isPlainObject(c[o]) || i == r) return void 0 !== c[o] ? (s = c[o], !1) : (n.error(f.method, t), !1); c = c[o]; } })), e.isFunction(s) ? l = s.apply(a, o) : void 0 !== s && (l = s), e.isArray(i) ? i.push(l) : void 0 !== i ? i = [i, l] : void 0 !== l && (i = l), s; },
            }, c ? (void 0 === w && n.initialize(), n.invoke(l)) : (void 0 !== w && w.invoke('destroy'), n.initialize());
        }), void 0 !== i ? i : this;
    }, e.fn.state.settings = {
        name: 'State',
        debug: !1,
        verbose: !1,
        namespace: 'state',
        performance: !0,
        onActivate() {},
        onDeactivate() {},
        onChange() {},
        activateTest() { return !0; },
        deactivateTest() { return !0; },
        automatic: !0,
        sync: !1,
        flashDuration: 1e3,
        filter: { text: '.loading, .disabled', active: '.disabled' },
        context: !1,
        error: { beforeSend: 'The before send function has cancelled state change', method: 'The method you called is not defined.' },
        metadata: { promise: 'promise', storedText: 'stored-text' },
        className: {
            active: 'active', disabled: 'disabled', error: 'error', loading: 'loading', success: 'success', warning: 'warning',
        },
        selector: { text: !1 },
        defaults: {
            input: { disabled: !0, loading: !0, active: !0 },
            button: { disabled: !0, loading: !0, active: !0 },
            progress: {
                active: !0, success: !0, warning: !0, error: !0,
            },
        },
        states: {
            active: !0, disabled: !0, error: !0, loading: !0, success: !0, warning: !0,
        },
        text: {
            disabled: !1, flash: !1, hover: !1, active: !1, inactive: !1, activate: !1, deactivate: !1,
        },
    };
}(jQuery, window, document)), (function(e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.visibility = function(i) {
        let o; const a = e(this); const r = a.selector || ''; let s = (new Date()).getTime(); let l = []; const c = arguments[0]; const u = typeof c === 'string'; const d = [].slice.call(arguments, 1); const f = a.length; let m = 0; return a.each(function() {
            let a; let g; let v; let p; const h = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.visibility.settings, i) : e.extend({}, e.fn.visibility.settings); const b = h.className; const y = h.namespace; const x = h.error; const C = h.metadata; const w = `.${y}`; const k = `module-${y}`; const S = e(t); const T = e(this); const A = e(h.context); let R = (T.selector, T.data(k)); const P = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function(e) { setTimeout(e, 0); }; const E = this; let F = !1; p = {
                initialize() { p.debug('Initializing', h), p.setup.cache(), p.should.trackChanges() && (h.type == 'image' && p.setup.image(), h.type == 'fixed' && p.setup.fixed(), h.observeChanges && p.observeChanges(), p.bind.events()), p.save.position(), p.is.visible() || p.error(x.visible, T), h.initialCheck && p.checkVisibility(), p.instantiate(); },
                instantiate() { p.debug('Storing instance', p), T.data(k, p), R = p; },
                destroy() { p.verbose('Destroying previous module'), v && v.disconnect(), g && g.disconnect(), S.off(`load${w}`, p.event.load).off(`resize${w}`, p.event.resize), A.off(`scroll${w}`, p.event.scroll).off(`scrollchange${w}`, p.event.scrollchange), h.type == 'fixed' && (p.resetFixed(), p.remove.placeholder()), T.off(w).removeData(k); },
                observeChanges() { 'MutationObserver' in t && (g = new MutationObserver(p.event.contextChanged), v = new MutationObserver(p.event.changed), g.observe(n, { childList: !0, subtree: !0 }), v.observe(E, { childList: !0, subtree: !0 }), p.debug('Setting up mutation observer', v)); },
                bind: { events() { p.verbose('Binding visibility events to scroll and resize'), h.refreshOnLoad && S.on(`load${w}`, p.event.load), S.on(`resize${w}`, p.event.resize), A.off(`scroll${w}`).on(`scroll${w}`, p.event.scroll).on(`scrollchange${w}`, p.event.scrollchange); } },
                event: {
                    changed(e) { p.verbose('DOM tree modified, updating visibility calculations'), p.timer = setTimeout(function() { p.verbose('DOM tree modified, updating sticky menu'), p.refresh(); }, 100); }, contextChanged(t) { [].forEach.call(t, function(t) { t.removedNodes && [].forEach.call(t.removedNodes, function(t) { (t == E || e(t).find(E).length > 0) && (p.debug('Element removed from DOM, tearing down events'), p.destroy()); }); }); }, resize() { p.debug('Window resized'), h.refreshOnResize && P(p.refresh); }, load() { p.debug('Page finished loading'), P(p.refresh); }, scroll() { h.throttle ? (clearTimeout(p.timer), p.timer = setTimeout(function() { A.triggerHandler(`scrollchange${w}`, [A.scrollTop()]); }, h.throttle)) : P(function() { A.triggerHandler(`scrollchange${w}`, [A.scrollTop()]); }); }, scrollchange(e, t) { p.checkVisibility(t); },
                },
                precache(t, i) { t instanceof Array || (t = [t]); for (var o = t.length, a = 0, r = [], s = n.createElement('img'), l = function() { ++a >= t.length && e.isFunction(i) && i(); }; o--;)s = n.createElement('img'), s.onload = l, s.onerror = l, s.src = t[o], r.push(s); },
                enableCallbacks() { p.debug('Allowing callbacks to occur'), F = !1; },
                disableCallbacks() { p.debug('Disabling all callbacks temporarily'), F = !0; },
                should: { trackChanges() { return u ? (p.debug('One time query, no need to bind events'), !1) : (p.debug('Callbacks being attached'), !0); } },
                setup: { cache() { p.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = T.data(C.src); e && (p.verbose('Lazy loading image', e), h.once = !0, h.observeChanges = !1, h.onOnScreen = function() { p.debug('Image on screen', E), p.precache(e, function() { p.set.image(e, function() { m++, m == f && h.onAllLoaded.call(this), h.onLoad.call(this); }); }); }); }, fixed() { p.debug('Setting up fixed'), h.once = !1, h.observeChanges = !1, h.initialCheck = !0, h.refreshOnLoad = !0, i.transition || (h.transition = !1), p.create.placeholder(), p.debug('Added placeholder', a), h.onTopPassed = function() { p.debug('Element passed, adding fixed position', T), p.show.placeholder(), p.set.fixed(), h.transition && void 0 !== e.fn.transition && T.transition(h.transition, h.duration); }, h.onTopPassedReverse = function() { p.debug('Element returned to position, removing fixed', T), p.hide.placeholder(), p.remove.fixed(); }; } },
                create: { placeholder() { p.verbose('Creating fixed position placeholder'), a = T.clone(!1).css('display', 'none').addClass(b.placeholder).insertAfter(T); } },
                show: { placeholder() { p.verbose('Showing placeholder'), a.css('display', 'block').css('visibility', 'hidden'); } },
                hide: { placeholder() { p.verbose('Hiding placeholder'), a.css('display', 'none').css('visibility', ''); } },
                set: {
                    fixed() {
                        p.verbose('Setting element to fixed position'), T.addClass(b.fixed).css({
                            position: 'fixed', top: `${h.offset}px`, left: 'auto', zIndex: h.zIndex,
                        }), h.onFixed.call(E);
                    },
                    image(t, n) { if (T.attr('src', t), h.transition) if (void 0 !== e.fn.transition) { if (T.hasClass(b.visible)) return void p.debug('Transition already occurred on this image, skipping animation'); T.transition(h.transition, h.duration, n); } else T.fadeIn(h.duration, n); else T.show(); },
                },
                is: {
                    onScreen() { return p.get.elementCalculations().onScreen; }, offScreen() { return p.get.elementCalculations().offScreen; }, visible() { return !(!p.cache || !p.cache.element) && !(p.cache.element.width === 0 && p.cache.element.offset.top === 0); }, verticallyScrollableContext() { const e = A.get(0) !== t && A.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = A.get(0) !== t && A.css('overflow-x'); return e == 'auto' || e == 'scroll'; },
                },
                refresh() { p.debug('Refreshing constants (width/height)'), h.type == 'fixed' && p.resetFixed(), p.reset(), p.save.position(), h.checkOnRefresh && p.checkVisibility(), h.onRefresh.call(E); },
                resetFixed() { p.remove.fixed(), p.remove.occurred(); },
                reset() { p.verbose('Resetting all cached values'), e.isPlainObject(p.cache) && (p.cache.screen = {}, p.cache.element = {}); },
                checkVisibility(e) { p.verbose('Checking visibility of element', p.cache.element), !F && p.is.visible() && (p.save.scroll(e), p.save.calculations(), p.passed(), p.passingReverse(), p.topVisibleReverse(), p.bottomVisibleReverse(), p.topPassedReverse(), p.bottomPassedReverse(), p.onScreen(), p.offScreen(), p.passing(), p.topVisible(), p.bottomVisible(), p.topPassed(), p.bottomPassed(), h.onUpdate && h.onUpdate.call(E, p.get.elementCalculations())); },
                passed(t, n) { const i = p.get.elementCalculations(); if (t && n)h.onPassed[t] = n; else { if (void 0 !== t) return p.get.pixelsPassed(t) > i.pixelsPassed; i.passing && e.each(h.onPassed, function(e, t) { i.bottomVisible || i.pixelsPassed > p.get.pixelsPassed(e) ? p.execute(t, e) : h.once || p.remove.occurred(t); }); } },
                onScreen(e) { const t = p.get.elementCalculations(); const n = e || h.onOnScreen; if (e && (p.debug('Adding callback for onScreen', e), h.onOnScreen = e), t.onScreen ? p.execute(n, 'onScreen') : h.once || p.remove.occurred('onScreen'), void 0 !== e) return t.onOnScreen; },
                offScreen(e) { const t = p.get.elementCalculations(); const n = e || h.onOffScreen; if (e && (p.debug('Adding callback for offScreen', e), h.onOffScreen = e), t.offScreen ? p.execute(n, 'offScreen') : h.once || p.remove.occurred('offScreen'), void 0 !== e) return t.onOffScreen; },
                passing(e) { const t = p.get.elementCalculations(); const n = e || h.onPassing; if (e && (p.debug('Adding callback for passing', e), h.onPassing = e), t.passing ? p.execute(n, 'passing') : h.once || p.remove.occurred('passing'), void 0 !== e) return t.passing; },
                topVisible(e) { const t = p.get.elementCalculations(); const n = e || h.onTopVisible; if (e && (p.debug('Adding callback for top visible', e), h.onTopVisible = e), t.topVisible ? p.execute(n, 'topVisible') : h.once || p.remove.occurred('topVisible'), void 0 === e) return t.topVisible; },
                bottomVisible(e) { const t = p.get.elementCalculations(); const n = e || h.onBottomVisible; if (e && (p.debug('Adding callback for bottom visible', e), h.onBottomVisible = e), t.bottomVisible ? p.execute(n, 'bottomVisible') : h.once || p.remove.occurred('bottomVisible'), void 0 === e) return t.bottomVisible; },
                topPassed(e) { const t = p.get.elementCalculations(); const n = e || h.onTopPassed; if (e && (p.debug('Adding callback for top passed', e), h.onTopPassed = e), t.topPassed ? p.execute(n, 'topPassed') : h.once || p.remove.occurred('topPassed'), void 0 === e) return t.topPassed; },
                bottomPassed(e) { const t = p.get.elementCalculations(); const n = e || h.onBottomPassed; if (e && (p.debug('Adding callback for bottom passed', e), h.onBottomPassed = e), t.bottomPassed ? p.execute(n, 'bottomPassed') : h.once || p.remove.occurred('bottomPassed'), void 0 === e) return t.bottomPassed; },
                passingReverse(e) { const t = p.get.elementCalculations(); const n = e || h.onPassingReverse; if (e && (p.debug('Adding callback for passing reverse', e), h.onPassingReverse = e), t.passing ? h.once || p.remove.occurred('passingReverse') : p.get.occurred('passing') && p.execute(n, 'passingReverse'), void 0 !== e) return !t.passing; },
                topVisibleReverse(e) { const t = p.get.elementCalculations(); const n = e || h.onTopVisibleReverse; if (e && (p.debug('Adding callback for top visible reverse', e), h.onTopVisibleReverse = e), t.topVisible ? h.once || p.remove.occurred('topVisibleReverse') : p.get.occurred('topVisible') && p.execute(n, 'topVisibleReverse'), void 0 === e) return !t.topVisible; },
                bottomVisibleReverse(e) { const t = p.get.elementCalculations(); const n = e || h.onBottomVisibleReverse; if (e && (p.debug('Adding callback for bottom visible reverse', e), h.onBottomVisibleReverse = e), t.bottomVisible ? h.once || p.remove.occurred('bottomVisibleReverse') : p.get.occurred('bottomVisible') && p.execute(n, 'bottomVisibleReverse'), void 0 === e) return !t.bottomVisible; },
                topPassedReverse(e) { const t = p.get.elementCalculations(); const n = e || h.onTopPassedReverse; if (e && (p.debug('Adding callback for top passed reverse', e), h.onTopPassedReverse = e), t.topPassed ? h.once || p.remove.occurred('topPassedReverse') : p.get.occurred('topPassed') && p.execute(n, 'topPassedReverse'), void 0 === e) return !t.onTopPassed; },
                bottomPassedReverse(e) { const t = p.get.elementCalculations(); const n = e || h.onBottomPassedReverse; if (e && (p.debug('Adding callback for bottom passed reverse', e), h.onBottomPassedReverse = e), t.bottomPassed ? h.once || p.remove.occurred('bottomPassedReverse') : p.get.occurred('bottomPassed') && p.execute(n, 'bottomPassedReverse'), void 0 === e) return !t.bottomPassed; },
                execute(e, t) { const n = p.get.elementCalculations(); const i = p.get.screenCalculations(); e = e || !1, e && (h.continuous ? (p.debug('Callback being called continuously', t, n), e.call(E, n, i)) : p.get.occurred(t) || (p.debug('Conditions met', t, n), e.call(E, n, i))), p.save.occurred(t); },
                remove: {
                    fixed() {
                        p.debug('Removing fixed position'), T.removeClass(b.fixed).css({
                            position: '', top: '', left: '', zIndex: '',
                        }), h.onUnfixed.call(E);
                    },
                    placeholder() { p.debug('Removing placeholder content'), a && a.remove(); },
                    occurred(e) { if (e) { const t = p.cache.occurred; void 0 !== t[e] && !0 === t[e] && (p.debug('Callback can now be called again', e), p.cache.occurred[e] = !1); } else p.cache.occurred = {}; },
                },
                save: {
                    calculations() { p.verbose('Saving all calculations necessary to determine positioning'), p.save.direction(), p.save.screenCalculations(), p.save.elementCalculations(); }, occurred(e) { e && (void 0 !== p.cache.occurred[e] && !0 === p.cache.occurred[e] || (p.verbose('Saving callback occurred', e), p.cache.occurred[e] = !0)); }, scroll(e) { e = e + h.offset || A.scrollTop() + h.offset, p.cache.scroll = e; }, direction() { let e; const t = p.get.scroll(); const n = p.get.lastScroll(); return e = t > n && n ? 'down' : t < n && n ? 'up' : 'static', p.cache.direction = e, p.cache.direction; }, elementPosition() { const e = p.cache.element; const t = p.get.screenSize(); return p.verbose('Saving element position'), e.fits = e.height < t.height, e.offset = T.offset(), e.width = T.outerWidth(), e.height = T.outerHeight(), p.is.verticallyScrollableContext() && (e.offset.top += A.scrollTop() - A.offset().top), p.is.horizontallyScrollableContext() && (e.offset.left += A.scrollLeft - A.offset().left), p.cache.element = e, e; }, elementCalculations() { const e = p.get.screenCalculations(); const t = p.get.elementPosition(); return h.includeMargin ? (t.margin = {}, t.margin.top = parseInt(T.css('margin-top'), 10), t.margin.bottom = parseInt(T.css('margin-bottom'), 10), t.top = t.offset.top - t.margin.top, t.bottom = t.offset.top + t.height + t.margin.bottom) : (t.top = t.offset.top, t.bottom = t.offset.top + t.height), t.topPassed = e.top >= t.top, t.bottomPassed = e.top >= t.bottom, t.topVisible = e.bottom >= t.top && !t.bottomPassed, t.bottomVisible = e.bottom >= t.bottom && !t.topPassed, t.pixelsPassed = 0, t.percentagePassed = 0, t.onScreen = t.topVisible && !t.bottomPassed, t.passing = t.topPassed && !t.bottomPassed, t.offScreen = !t.onScreen, t.passing && (t.pixelsPassed = e.top - t.top, t.percentagePassed = (e.top - t.top) / t.height), p.cache.element = t, p.verbose('Updated element calculations', t), t; }, screenCalculations() { const e = p.get.scroll(); return p.save.direction(), p.cache.screen.top = e, p.cache.screen.bottom = e + p.cache.screen.height, p.cache.screen; }, screenSize() { p.verbose('Saving window position'), p.cache.screen = { height: A.height() }; }, position() { p.save.screenSize(), p.save.elementPosition(); },
                },
                get: {
                    pixelsPassed(e) { const t = p.get.elementCalculations(); return e.search('%') > -1 ? t.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return void 0 !== p.cache.occurred && (p.cache.occurred[e] || !1); }, direction() { return void 0 === p.cache.direction && p.save.direction(), p.cache.direction; }, elementPosition() { return void 0 === p.cache.element && p.save.elementPosition(), p.cache.element; }, elementCalculations() { return void 0 === p.cache.element && p.save.elementCalculations(), p.cache.element; }, screenCalculations() { return void 0 === p.cache.screen && p.save.screenCalculations(), p.cache.screen; }, screenSize() { return void 0 === p.cache.screen && p.save.screenSize(), p.cache.screen; }, scroll() { return void 0 === p.cache.scroll && p.save.scroll(), p.cache.scroll; }, lastScroll() { return void 0 === p.cache.screen ? (p.debug('First scroll event, no last scroll could be found'), !1) : p.cache.screen.top; },
                },
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, h, t); else { if (void 0 === n) return h[t]; h[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (void 0 === n) return p[t]; p[t] = n; } },
                debug() { !h.silent && h.debug && (h.performance ? p.performance.log(arguments) : (p.debug = Function.prototype.bind.call(console.info, console, `${h.name}:`), p.debug.apply(console, arguments))); },
                verbose() { !h.silent && h.verbose && h.debug && (h.performance ? p.performance.log(arguments) : (p.verbose = Function.prototype.bind.call(console.info, console, `${h.name}:`), p.verbose.apply(console, arguments))); },
                error() { h.silent || (p.error = Function.prototype.bind.call(console.error, console, `${h.name}:`), p.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let n; let i; h.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: E, 'Execution Time': n,
                        })), clearTimeout(p.performance.timer), p.performance.timer = setTimeout(p.performance.display, 500);
                    },
                    display() { let t = `${h.name}:`; let n = 0; s = !1, clearTimeout(p.performance.timer), e.each(l, function(e, t) { n += t['Execution Time']; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), l = []; },
                },
                invoke(t, n, i) { let a; let r; let s; let l = R; return n = n || d, i = E || i, typeof t === 'string' && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, function(n, i) { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (p.error(x.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r; },
            }, u ? (void 0 === R && p.initialize(), R.save.scroll(), R.save.calculations(), p.invoke(c)) : (void 0 !== R && R.invoke('destroy'), p.initialize());
        }), void 0 !== o ? o : this;
    }, e.fn.visibility.settings = {
        name: 'Visibility', namespace: 'visibility', debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: t, throttle: !1, type: !1, zIndex: '10', transition: 'fade in', duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onLoad() {}, onAllLoaded() {}, onFixed() {}, onUnfixed() {}, onUpdate: !1, onRefresh() {}, metadata: { src: 'src' }, className: { fixed: 'fixed', placeholder: 'placeholder', visible: 'visible' }, error: { method: 'The method you called is not defined.', visible: 'Element is hidden, you must call refresh after element becomes visible' },
    };
}(jQuery, window, document));
